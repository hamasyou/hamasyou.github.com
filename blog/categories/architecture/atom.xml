<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Architecture | それはBooks]]></title>
  <link href="http://hamasyou.com/blog/categories/architecture/atom.xml" rel="self"/>
  <link href="http://hamasyou.com/"/>
  <updated>2017-06-27T15:56:33+09:00</updated>
  <id>http://hamasyou.com/</id>
  <author>
    <name><![CDATA[hamasyou]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ゲームエンジン・アーキテクチャ 第2版]]></title>
    <link href="http://hamasyou.com/blog/2015/12/16/9784797377484/"/>
    <updated>2015-12-16T09:26:45+09:00</updated>
    <id>http://hamasyou.com/blog/2015/12/16/9784797377484</id>
    <content type="html"><![CDATA[<p>読了。後で書く。</p>

<!-- more -->


<h2>目次</h2>

<ul>
<li>第1部 基盤

<ul>
<li>第1章 イントロダクション</li>
<li>第2章 仕事用ツール</li>
<li>第3章 ゲームのためのソフトウェアエンジニアリングの基本</li>
<li>第4章 ゲームのための3D計算</li>
</ul>
</li>
<li>第2部 低レベルエンジンシステム

<ul>
<li>第5章 エンジンサポートシステム</li>
<li>第6章 リソースとファイルシステム</li>
<li>第7章 ゲームループとリアルタイムシミュレーション</li>
<li>第8章 ヒューマンインターフェイスデバイス（HID）</li>
<li>第9章 デバッグおよび開発のツール</li>
</ul>
</li>
<li>第3部 グラフィックス、モーション、サウンド

<ul>
<li>第10章 レンダリングエンジン</li>
<li>第11章 アニメーションシステム</li>
<li>第12章 コリジョンと剛体力学</li>
<li>第13章 オーディオ</li>
</ul>
</li>
<li>第4部 ゲームプレイ

<ul>
<li>第14章 ゲームプレイシステムの概要</li>
<li>第15章 ランタイムのゲームプレイ基本システム</li>
</ul>
</li>
<li>第5部 まとめ

<ul>
<li>第16章 まだやることがあるってこと？</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ゲームデザイナーのための空間設計 歴史的建造物から学ぶレベルデザイン]]></title>
    <link href="http://hamasyou.com/blog/2015/12/16/9784862462619/"/>
    <updated>2015-12-16T09:22:57+09:00</updated>
    <id>http://hamasyou.com/blog/2015/12/16/9784862462619</id>
    <content type="html"><![CDATA[<p>読了。後で書く。</p>

<!-- more -->


<h2>目次</h2>

<ul>
<li>Chapter1 建造物からレベルデザインを学ぶ準備

<ul>
<li>これから見ていく準備段階として、建築史の概要を学びます。</li>
</ul>
</li>
<li>Chapter2 レベルデザインのツールとテクニック

<ul>
<li>空間の設計に便利な意匠図や視覚化の方法を説明します。</li>
</ul>
</li>
<li>Chapter3 基本的な空間配置とゲーム空間の種類

<ul>
<li>ゲーム空間を分析して、設計に使用できるタイプを特定します。</li>
</ul>
</li>
<li>Chapter4 ビジュアル要素によるチュートリアル

<ul>
<li>プレイヤーにゲームのメカニクスを教える方法を紹介します。</li>
</ul>
</li>
<li>Chapter5 生存本能を利用したレベルデザイン

<ul>
<li>感情を動かし、プレイヤーを促すテクニックを取り上げます。</li>
</ul>
</li>
<li>Chapter6 報酬の空間でプレイヤーを誘い込む

<ul>
<li>心理学を利用し、プレイヤーに報酬を与える方法を説明します。</li>
</ul>
</li>
<li>Chapter7 ゲーム空間におけるストーリーテリング

<ul>
<li>ストーリーを語り、円滑に進める空間構築の方法を探求します。</li>
</ul>
</li>
<li>Chapter8 インタラクティブ空間とワールドデザイン

<ul>
<li>空間を概観し、庭園デザインの手法を活かす方法を紹介します。</li>
</ul>
</li>
<li>Chapter9 プレイヤーの交流を生み出すレベルデザイン

<ul>
<li>プレイヤーの交流を促す方法を、都市デザインに学びます。</li>
</ul>
</li>
<li>Chapter10 サウンドによるレベルデザインの強化

<ul>
<li>リズムの効果を知り、空間効果を増幅させる方法を見ていきます。</li>
</ul>
</li>
<li>Chapter11 現実世界を舞台にしたレベルデザイン

<ul>
<li>都市や屋外空間でプレイするゲームに、空間原理を応用します。</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[シングルページWebアプリケーション ―Node.js、MongoDBを活用したJavaScript SPA]]></title>
    <link href="http://hamasyou.com/blog/2015/12/16/9784873116730/"/>
    <updated>2015-12-16T09:12:25+09:00</updated>
    <id>http://hamasyou.com/blog/2015/12/16/9784873116730</id>
    <content type="html"><![CDATA[<p>読了。後で書く。</p>

<!-- more -->


<h2>目次</h2>

<ul>
<li>まえがき</li>
<li>はじめに</li>
<li>本書について</li>
<li>I部　SPAの紹介</li>
<li>1章　最初のシングルページアプリケーション

<ul>
<li>1.1　定義、簡単な歴史、重点事項</li>
<li>1.2　最初の SPAを構築する</li>
<li>1.3　適切に記述されたSPAのユーザメリット</li>
<li>1.4　まとめ</li>
</ul>
</li>
<li>2章　JavaScriptのおさらい

<ul>
<li>2.1　変数スコープ</li>
<li>2.2　変数の巻き上げ</li>
<li>2.3　高度な変数の巻き上げと実行コンテキストオブジェクト</li>
<li>2.4　スコープチェーン</li>
<li>2.5　JavaScriptオブジェクトとプロトタイプチェーン</li>
<li>2.6　関数 .詳しく調べる</li>
<li>2.7　まとめ</li>
</ul>
</li>
<li>II部　SPAクライアント</li>
<li>3章　シェルの開発

<ul>
<li>3.1　シェルを完全に把握する</li>
<li>3.2　ファイルと名前空間を用意する</li>
<li>3.3　機能コンテナを作成する</li>
<li>3.4　機能コンテナをレンダリングする</li>
<li>3.5　機能コンテナを管理する</li>
<li>3.6　アプリケーション状態を管理する</li>
<li>3.7　まとめ</li>
</ul>
</li>
<li>4章　機能モジュールの追加

<ul>
<li>4.1　機能モジュール方式</li>
<li>4.2　機能モジュールファイルを用意する</li>
<li>4.3　メソッド APIを設計する</li>
<li>4.4　機能 APIを実装する</li>
<li>4.5　頻繁に必要となるメソッドを追加する</li>
<li>4.6　まとめ</li>
</ul>
</li>
<li>5章　モデルの構築

<ul>
<li>5.1　モデルを理解する</li>
<li>5.2　モデルとその他のファイルを用意する</li>
<li>5.3　peopleオブジェクトを設計する</li>
<li>5.4　peopleオブジェクトを構築する</li>
<li>5.5　シェルでサインインとサインアウトを可能にする</li>
<li>5.6　まとめ</li>
</ul>
</li>
<li>6章　モデルとデータモジュールの完成

<ul>
<li>6.1　chatオブジェクトを設計する</li>
<li>6.2　chatオブジェクトを構築する</li>
<li>6.3　モデルにアバターサポートを追加する</li>
<li>6.4　チャット機能モジュールを完成させる</li>
<li>6.5　アバター機能モジュールを作成する</li>
<li>6.6　データバインディングと jQuery</li>
<li>6.7　データモジュールを作成する</li>
<li>6.8　まとめ</li>
</ul>
</li>
<li>III部　SPAサーバ</li>
<li>7章　 Webサーバ

<ul>
<li>7.1　サーバの役割</li>
<li>7.2　Node.js</li>
<li>7.3　高度なルーティング</li>
<li>7.4　認証と認可を追加する</li>
<li>7.5　WebSocketとSocket.IO</li>
<li>7.6　まとめ</li>
</ul>
</li>
<li>8章　サーバデータベース

<ul>
<li>8.1　データベースの役割</li>
<li>8.2　MongoDBとは</li>
<li>8.3　MongoDBドライバを使う</li>
<li>8.4　クライアントデータを検証する</li>
<li>8.5　個別の CRUDモジュールを作成する</li>
<li>8.6　チャットモジュールを構築する</li>
<li>8.7　まとめ</li>
</ul>
</li>
<li>9章　 SPAを本番環境に備える

<ul>
<li>9.1　SPAを検索エンジンに対して最適化する</li>
<li>9.2　クラウドサービスとサードパーティサービス</li>
<li>9.3　キャッシングとキャッシュバスティング</li>
<li>9.4　まとめ</li>
</ul>
</li>
<li>付録A　JavaScriptコーディング標準

<ul>
<li>A.1　なぜコーディング標準が必要なのか</li>
<li>A.2　コードレイアウトとコメント</li>
<li>A.3　変数名</li>
<li>A.4　変数の宣言と割り当て</li>
<li>A.5　関数</li>
<li>A.6　名前空間</li>
<li>A.7　ファイル名とレイアウト</li>
<li>A.8　構文</li>
<li>A.9　コードを検証する</li>
<li>A.10　モジュール用のテンプレート</li>
<li>A.11　まとめ</li>
</ul>
</li>
<li>付録B　SPAのテスト

<ul>
<li>B.1　テストモードを準備する</li>
<li>B.2　テストフレームワークを選ぶ</li>
<li>B.3　nodeunitを準備する</li>
<li>B.4　テストスイートを作成する</li>
<li>B.5　テストに合わせて SPAモジュールを調整する</li>
<li>B.6　まとめ</li>
</ul>
</li>
<li>索引</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[APIデザインの極意 Java/NetBeansアーキテクト探究ノート]]></title>
    <link href="http://hamasyou.com/blog/2014/08/30/484433591x/"/>
    <updated>2014-08-30T12:40:36+09:00</updated>
    <id>http://hamasyou.com/blog/2014/08/30/484433591x</id>
    <content type="html"><![CDATA[<p>本書は <strong>プログラミング API</strong> の設計本です。Web API の設計極意に関して知りたい人は 『<a href="http://www.amazon.co.jp/gp/product/4873113539?ie=UTF8&amp;camp=247&amp;creativeASIN=4873113539&amp;linkCode=xm2&amp;tag=sorehabooks-22">RESTful Webサービス</a>』や『<a href="http://www.amazon.co.jp/gp/product/4774142042?ie=UTF8&amp;tag=sorehabooks-22&amp;linkCode=xm2&amp;camp=247&amp;creativeASIN=4774142042">Webを支える技術 -HTTP、URI、HTML、そしてREST</a>』を読むのがいいと思います。本書は <a href="http://www.amazon.co.jp/gp/product/4797311126?ie=UTF8&amp;camp=247&amp;creativeASIN=4797311126&amp;linkCode=xm2&amp;tag=sorehabooks-22">GoF のデザインパターン
</a> や <a href="http://www.amazon.co.jp/gp/product/4621066056?ie=UTF8&amp;camp=247&amp;creativeASIN=4621066056&amp;linkCode=xm2&amp;tag=sorehabooks-22">EFFECTIVE JAVA</a> を読んだ開発者が次に読むべき本として紹介されています。</p>

<p><a href="http://www.amazon.co.jp/gp/product/4873113539?ie=UTF8&amp;camp=247&amp;creativeASIN=4873113539&amp;linkCode=xm2&amp;tag=sorehabooks-22"><img src="http://ecx.images-amazon.com/images/I/51ojIhXBP3L._SS140_.jpg" alt="RESTful Webサービス" /></a>
<a href="http://www.amazon.co.jp/gp/product/4774142042?ie=UTF8&amp;tag=sorehabooks-22&amp;linkCode=xm2&amp;camp=247&amp;creativeASIN=4774142042"><img src="http://ecx.images-amazon.com/images/I/51qo6pgjaSL._SS140_.jpg" alt="Webを支える技術 -HTTP、URI、HTML、そしてREST" /></a>
<a href="http://www.amazon.co.jp/gp/product/4797311126?ie=UTF8&amp;camp=247&amp;creativeASIN=4797311126&amp;linkCode=xm2&amp;tag=sorehabooks-22"><img src="http://ecx.images-amazon.com/images/I/61YX3ZDFIwL._SS140_.jpg" alt="オブジェクト指向における再利用のためのデザインパターン" /></a>
<a href="http://www.amazon.co.jp/gp/product/4621066056?ie=UTF8&amp;camp=247&amp;creativeASIN=4621066056&amp;linkCode=xm2&amp;tag=sorehabooks-22"><img src="http://ecx.images-amazon.com/images/I/91tYrFpKmLL._SS140_.jpg" alt="EFFECTIVE JAVA 第2版" /></a></p>

<p>本書は、NetBeans API を構築した筆者がデザインパターンやコーディング作法だけではうまくいかない問題、後方互換性を維持したままライブラリを発展させる方法、を重点的に解説しています。なるほど、 <strong>デザインパターンや設計方法を学んだ次に読むべき本</strong> として挙げられている理由がよくわかる内容になっています。</p>

<!-- more -->


<h3>社内ライブラリと API 設計は別物</h3>

<p>本書で扱う API という言葉は、例えばオープンソースライブラリのような、多くの人に共有されるものという位置づけになっています。社内で使うようなライブラリなどの API とはニュアンスが違う感じがしました。</p>

<p>一度リリースしたら、後方互換性を維持して発展させていかなければならない、そういった類のライブラリや API を作る開発者向けの本です。</p>

<h2>本書のテーマ</h2>

<p>本書のテーマは、次の2つに集約されると思います。</p>

<ul>
<li>後方互換性を維持する API のデザインパターン</li>
<li>優れた API であるためにどうするか</li>
</ul>


<p>NetBeans API で培った経験則を余す所なく記載してくれているため、ボリュームがスゴイことになっています。また、作って終わりの API の作り方を教えているわけではないので、おそらくほとんどの開発者には <em>なんとなくわかった気になるだけか難しくて後回しにする</em> ような内容かもしれません。</p>

<p>はっきり言って、本書が役に立った！と感じる開発者は少ないかもしれませんが、少なくとも GitHub でソースコードを公開している開発者は頑張って読んでもらうのがいいと思いました。それくらい内容が濃く、経験者しかわからないことが書いてあります。</p>

<h3>後方互換性を維持する API のデザインパターン</h3>

<p><blockquote><p>開発者は、API の現在のバージョンをコーディングしている場合に、未来について考えることが求められます。私に言えることは、それは、今までの API 設計でよく行われた方法ではないということです。また、今日までに書かれた書籍やその中の助言は、この種の思考にはあまり役に立ちません。それらには、単一バージョンの場合のデザインパターンが説明されていることがほとんどです。</p><footer><strong>本書</strong></footer></blockquote></p>

<p>これが、<strong>新しいデザイン本が必要な理由</strong> です。今日のシステムはコンポーネントの組み合わせで出来ています。おそらく今後もこの傾向は変わらないと思います。コンポーネント利用者の経験（投資）をムダにしない為に、よりよい発展を目指す上で、後方互換性を維持することは重要なことになります。これが、<strong>本書を読む理由</strong> です。</p>

<h3>優れた API であるためにどうするか</h3>

<p>では、どのように API 設計をすればいいか。その方法も本書に書かれています。</p>

<ul>
<li>メソッドとフィールドの優れたシグニチャ</li>
<li>ファイル操作</li>
<li>環境変数とコマンドラインオプション</li>
<li>API としてのテキストメッセージ</li>
<li>（ネットワーク）プロトコル</li>
<li>API の振る舞い</li>
<li>I18N と L10N のサポート</li>
<li>API の品質検査方法（正しさの証明）</li>
<li>理解しやすさ</li>
<li>一貫性</li>
<li>やりたいことが満たせる API を発見できること</li>
<li>単純なことを簡単に行えること</li>
<li>投資の保全（利用者を尊重すること）</li>
</ul>


<p>API に優れた名前をつけることや <strong>驚き最小の法則</strong>、シンプルで一貫性のある I/F にするというのは基本的にな事になります。こういったことを踏まえた上で、この API を利用してくれているユーザを尊重すること（次のバージョンでメソッド名を変更するなんてとんでもない！）が大切だと書かれています。</p>

<p>後方互換性を保ち、API のユーザの投資をムダにしない設計の方法を学びたい人、新しい視点を身につけたい人に本書はおすすめです。</p>

<p><blockquote><p>- オブジェクト指向アプリケーションフレームワークには、伝統的なデザインパターンとは異なるスキルが必要<br/>- クラスを API として扱って、頭痛の種を軽減<br/>- 将来、改善できるように API の発展計画を準備</p></blockquote></p>

<h2>目次</h2>

<ul>
<li>【第1部　理論と正当性】

<ul>
<li>第1章　 現代的なソフトウェア構築の技芸</li>
<li>第2章　 APIを作成する動機</li>
<li>第3章　 優れたAPIを決定づけるもの</li>
<li>第4章　 絶え間なく変わる標的</li>
</ul>
</li>
<li>【第2部　実践的設計】

<ul>
<li>第5章　 必要以上に公開しない</li>
<li>第6章　 実装ではなく、インタフェースに対してコーディングする</li>
<li>第7章　 モジュール方式アーキテクチャの使用</li>
<li>第8章　 クライアント用とプロバイダ用のAPIを分離</li>
<li>第9章　 テストの容易性に留意する</li>
<li>第10章　他のAPIとの協調</li>
<li>第11章　APIの実行時の側面</li>
<li>第12章　宣言型プログラミング</li>
</ul>
</li>
<li>【第3部　日々の生活】

<ul>
<li>第13章　有害で極端な助言</li>
<li>第14章　API設計のパラドックス</li>
<li>第15章　API宇宙の発展</li>
<li>第16章　チームワーク</li>
<li>第17章　ゲームでAPI設計スキルを向上させる</li>
<li>第18章　拡張可能なビジターパターンのケーススタディ</li>
<li>第19章　終焉の手続き</li>
</ul>
</li>
<li>終章：将来</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[バッドデータハンドブック ―データにまつわる問題への19の処方箋]]></title>
    <link href="http://hamasyou.com/blog/2013/11/14/4873116406/"/>
    <updated>2013-11-14T11:45:00+09:00</updated>
    <id>http://hamasyou.com/blog/2013/11/14/4873116406</id>
    <content type="html"><![CDATA[<p><blockquote><p>値の欠落、形式から外れたレコード、エンコーディング形式が不明な文字列。「バッドデータ」と聞いた時に思い浮べる典型例です。しかし、これら以外にも「そもそもデータにアクセスできない」「消えてしまった」「昨日と違っている」「データはあるが形式が処理に適していない」など、データを収集・分析するエンジニアは、これらの「バッドデータ」と正面から向きあわなければならないことが多々あります。本書では、これらの問題のあるデータのパターンを紹介し、その対処法を解説しています。<br/>19人のデータ分析の専門家が、自らの経験を通して得た、さまざまな教訓、実践的な方法論等を詳述した本書は、ビッグデータ時代のエンジニアにとって必携の一冊となるでしょう。</p></p><p><p></p><footer><strong>O'REILLY</strong></footer></blockquote></p>

<p>本書はプログラミングやデータ解析の時に扱うデータの内容やフォーマットについて書かれています。プログラミングの時に扱いやすいデータフォーマット、こういう点に気をつけてデータを扱え、こういうフォーマットが使いやすいなどについて書かれています。</p>

<p>コンピュータで扱うデータは大きく分けて<strong>コンピュータのためにフォーマットするデータ</strong>と<strong>人間のためにフォーマットするデータ</strong>があります。これらをごっちゃにしてしまうと扱いづらいデータ（<strong>バッドデータ</strong>）になってしまいます。本書はバッドデータをよりよく扱う方法、バッドデータにしない方法について、いろいろな点で考えられるようにアイデアや体験談を与えてくれます。</p>

<p>最近 API をよく作ってるんだけど通信データのフォーマットに困ってるというような Web プログラマにオススメです！</p>
]]></content>
  </entry>
  
</feed>
