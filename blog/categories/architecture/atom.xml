<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Architecture | それはBooks]]></title>
  <link href="http://hamasyou.com/blog/categories/architecture/atom.xml" rel="self"/>
  <link href="http://hamasyou.com/"/>
  <updated>2014-10-09T11:13:29+09:00</updated>
  <id>http://hamasyou.com/</id>
  <author>
    <name><![CDATA[hamasyou]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[APIデザインの極意 Java/NetBeansアーキテクト探究ノート]]></title>
    <link href="http://hamasyou.com/blog/2014/08/30/484433591x/"/>
    <updated>2014-08-30T12:40:36+09:00</updated>
    <id>http://hamasyou.com/blog/2014/08/30/484433591x</id>
    <content type="html"><![CDATA[<p>本書は <strong>プログラミング API</strong> の設計本です。Web API の設計極意に関して知りたい人は 『<a href="http://www.amazon.co.jp/gp/product/4873113539?ie=UTF8&amp;camp=247&amp;creativeASIN=4873113539&amp;linkCode=xm2&amp;tag=sorehabooks-22">RESTful Webサービス</a>』や『<a href="http://www.amazon.co.jp/gp/product/4774142042?ie=UTF8&amp;tag=sorehabooks-22&amp;linkCode=xm2&amp;camp=247&amp;creativeASIN=4774142042">Webを支える技術 -HTTP、URI、HTML、そしてREST</a>』を読むのがいいと思います。本書は <a href="http://www.amazon.co.jp/gp/product/4797311126?ie=UTF8&amp;camp=247&amp;creativeASIN=4797311126&amp;linkCode=xm2&amp;tag=sorehabooks-22">GoF のデザインパターン
</a> や <a href="http://www.amazon.co.jp/gp/product/4621066056?ie=UTF8&amp;camp=247&amp;creativeASIN=4621066056&amp;linkCode=xm2&amp;tag=sorehabooks-22">EFFECTIVE JAVA</a> を読んだ開発者が次に読むべき本として紹介されています。</p>

<p><a href="http://www.amazon.co.jp/gp/product/4873113539?ie=UTF8&amp;camp=247&amp;creativeASIN=4873113539&amp;linkCode=xm2&amp;tag=sorehabooks-22"><img src="http://ecx.images-amazon.com/images/I/51ojIhXBP3L._SS140_.jpg" alt="RESTful Webサービス" /></a>
<a href="http://www.amazon.co.jp/gp/product/4774142042?ie=UTF8&amp;tag=sorehabooks-22&amp;linkCode=xm2&amp;camp=247&amp;creativeASIN=4774142042"><img src="http://ecx.images-amazon.com/images/I/51qo6pgjaSL._SS140_.jpg" alt="Webを支える技術 -HTTP、URI、HTML、そしてREST" /></a>
<a href="http://www.amazon.co.jp/gp/product/4797311126?ie=UTF8&amp;camp=247&amp;creativeASIN=4797311126&amp;linkCode=xm2&amp;tag=sorehabooks-22"><img src="http://ecx.images-amazon.com/images/I/61YX3ZDFIwL._SS140_.jpg" alt="オブジェクト指向における再利用のためのデザインパターン" /></a>
<a href="http://www.amazon.co.jp/gp/product/4621066056?ie=UTF8&amp;camp=247&amp;creativeASIN=4621066056&amp;linkCode=xm2&amp;tag=sorehabooks-22"><img src="http://ecx.images-amazon.com/images/I/91tYrFpKmLL._SS140_.jpg" alt="EFFECTIVE JAVA 第2版" /></a></p>

<p>本書は、NetBeans API を構築した筆者がデザインパターンやコーディング作法だけではうまくいかない問題、後方互換性を維持したままライブラリを発展させる方法、を重点的に解説しています。なるほど、 <strong>デザインパターンや設計方法を学んだ次に読むべき本</strong> として挙げられている理由がよくわかる内容になっています。</p>

<!-- more -->


<h3>社内ライブラリと API 設計は別物</h3>

<p>本書で扱う API という言葉は、例えばオープンソースライブラリのような、多くの人に共有されるものという位置づけになっています。社内で使うようなライブラリなどの API とはニュアンスが違う感じがしました。</p>

<p>一度リリースしたら、後方互換性を維持して発展させていかなければならない、そういった類のライブラリや API を作る開発者向けの本です。</p>

<h2>本書のテーマ</h2>

<p>本書のテーマは、次の2つに集約されると思います。</p>

<ul>
<li>後方互換性を維持する API のデザインパターン</li>
<li>優れた API であるためにどうするか</li>
</ul>


<p>NetBeans API で培った経験則を余す所なく記載してくれているため、ボリュームがスゴイことになっています。また、作って終わりの API の作り方を教えているわけではないので、おそらくほとんどの開発者には <em>なんとなくわかった気になるだけか難しくて後回しにする</em> ような内容かもしれません。</p>

<p>はっきり言って、本書が役に立った！と感じる開発者は少ないかもしれませんが、少なくとも GitHub でソースコードを公開している開発者は頑張って読んでもらうのがいいと思いました。それくらい内容が濃く、経験者しかわからないことが書いてあります。</p>

<h3>後方互換性を維持する API のデザインパターン</h3>

<p><blockquote><p>開発者は、API の現在のバージョンをコーディングしている場合に、未来について考えることが求められます。私に言えることは、それは、今までの API 設計でよく行われた方法ではないということです。また、今日までに書かれた書籍やその中の助言は、この種の思考にはあまり役に立ちません。それらには、単一バージョンの場合のデザインパターンが説明されていることがほとんどです。</p><footer><strong>本書</strong></footer></blockquote></p>

<p>これが、<strong>新しいデザイン本が必要な理由</strong> です。今日のシステムはコンポーネントの組み合わせで出来ています。おそらく今後もこの傾向は変わらないと思います。コンポーネント利用者の経験（投資）をムダにしない為に、よりよい発展を目指す上で、後方互換性を維持することは重要なことになります。これが、<strong>本書を読む理由</strong> です。</p>

<h3>優れた API であるためにどうするか</h3>

<p>では、どのように API 設計をすればいいか。その方法も本書に書かれています。</p>

<ul>
<li>メソッドとフィールドの優れたシグニチャ</li>
<li>ファイル操作</li>
<li>環境変数とコマンドラインオプション</li>
<li>API としてのテキストメッセージ</li>
<li>（ネットワーク）プロトコル</li>
<li>API の振る舞い</li>
<li>I18N と L10N のサポート</li>
<li>API の品質検査方法（正しさの証明）</li>
<li>理解しやすさ</li>
<li>一貫性</li>
<li>やりたいことが満たせる API を発見できること</li>
<li>単純なことを簡単に行えること</li>
<li>投資の保全（利用者を尊重すること）</li>
</ul>


<p>API に優れた名前をつけることや <strong>驚き最小の法則</strong>、シンプルで一貫性のある I/F にするというのは基本的にな事になります。こういったことを踏まえた上で、この API を利用してくれているユーザを尊重すること（次のバージョンでメソッド名を変更するなんてとんでもない！）が大切だと書かれています。</p>

<p>後方互換性を保ち、API のユーザの投資をムダにしない設計の方法を学びたい人、新しい視点を身につけたい人に本書はおすすめです。</p>

<p><blockquote><p>- オブジェクト指向アプリケーションフレームワークには、伝統的なデザインパターンとは異なるスキルが必要<br/>- クラスを API として扱って、頭痛の種を軽減<br/>- 将来、改善できるように API の発展計画を準備</p></blockquote></p>

<h2>目次</h2>

<ul>
<li>【第1部　理論と正当性】

<ul>
<li>第1章　 現代的なソフトウェア構築の技芸</li>
<li>第2章　 APIを作成する動機</li>
<li>第3章　 優れたAPIを決定づけるもの</li>
<li>第4章　 絶え間なく変わる標的</li>
</ul>
</li>
<li>【第2部　実践的設計】

<ul>
<li>第5章　 必要以上に公開しない</li>
<li>第6章　 実装ではなく、インタフェースに対してコーディングする</li>
<li>第7章　 モジュール方式アーキテクチャの使用</li>
<li>第8章　 クライアント用とプロバイダ用のAPIを分離</li>
<li>第9章　 テストの容易性に留意する</li>
<li>第10章　他のAPIとの協調</li>
<li>第11章　APIの実行時の側面</li>
<li>第12章　宣言型プログラミング</li>
</ul>
</li>
<li>【第3部　日々の生活】

<ul>
<li>第13章　有害で極端な助言</li>
<li>第14章　API設計のパラドックス</li>
<li>第15章　API宇宙の発展</li>
<li>第16章　チームワーク</li>
<li>第17章　ゲームでAPI設計スキルを向上させる</li>
<li>第18章　拡張可能なビジターパターンのケーススタディ</li>
<li>第19章　終焉の手続き</li>
</ul>
</li>
<li>終章：将来</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[バッドデータハンドブック ―データにまつわる問題への19の処方箋]]></title>
    <link href="http://hamasyou.com/blog/2013/11/14/4873116406/"/>
    <updated>2013-11-14T11:45:00+09:00</updated>
    <id>http://hamasyou.com/blog/2013/11/14/4873116406</id>
    <content type="html"><![CDATA[<p><blockquote><p>値の欠落、形式から外れたレコード、エンコーディング形式が不明な文字列。「バッドデータ」と聞いた時に思い浮べる典型例です。しかし、これら以外にも「そもそもデータにアクセスできない」「消えてしまった」「昨日と違っている」「データはあるが形式が処理に適していない」など、データを収集・分析するエンジニアは、これらの「バッドデータ」と正面から向きあわなければならないことが多々あります。本書では、これらの問題のあるデータのパターンを紹介し、その対処法を解説しています。<br/>19人のデータ分析の専門家が、自らの経験を通して得た、さまざまな教訓、実践的な方法論等を詳述した本書は、ビッグデータ時代のエンジニアにとって必携の一冊となるでしょう。</p></p><p><p></p><footer><strong>O'REILLY</strong></footer></blockquote></p>

<p>本書はプログラミングやデータ解析の時に扱うデータの内容やフォーマットについて書かれています。プログラミングの時に扱いやすいデータフォーマット、こういう点に気をつけてデータを扱え、こういうフォーマットが使いやすいなどについて書かれています。</p>

<p>コンピュータで扱うデータは大きく分けて<strong>コンピュータのためにフォーマットするデータ</strong>と<strong>人間のためにフォーマットするデータ</strong>があります。これらをごっちゃにしてしまうと扱いづらいデータ（<strong>バッドデータ</strong>）になってしまいます。本書はバッドデータをよりよく扱う方法、バッドデータにしない方法について、いろいろな点で考えられるようにアイデアや体験談を与えてくれます。</p>

<p>最近 API をよく作ってるんだけど通信データのフォーマットに困ってるというような Web プログラマにオススメです！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Amazon Web Services クラウドデザインパターン 設計ガイド]]></title>
    <link href="http://hamasyou.com/blog/2012/09/13/4822211967/"/>
    <updated>2012-09-13T10:19:00+09:00</updated>
    <id>http://hamasyou.com/blog/2012/09/13/4822211967</id>
    <content type="html"><![CDATA[<!-- more -->



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Web開発者のための]大規模サービス技術入門 ―データ構造、メモリ、OS、DB、サーバ/インフラ]]></title>
    <link href="http://hamasyou.com/blog/2010/11/20/4774143073/"/>
    <updated>2010-11-20T19:32:00+09:00</updated>
    <id>http://hamasyou.com/blog/2010/11/20/4774143073</id>
    <content type="html"><![CDATA[<p>大規模サービスの運営、大変だということは分かっていても、じゃあ実際にどういうふうに大変なのか。実際に体験してみないとこの大変さはわからないと思います。</p>

<p>でも、実際に大規模サービスの開発・運営に携わることになったら！？</p>

<p>本書は、はてなで実際に運用されているサービスを元に、大規模サービス技術のノウハウを解説しています。実際にはてなのインターンシップで講義資料として使われているものがベースになっているので、分かりやすくかつ、実用的です。</p>

<p>Web サービスはいつユーザ数が爆発するかわからないという面白さがある一方、きちんとサービスのノウハウがないとシステムダウンにすぐに繋がってしまうという怖さがあります。</p>

<p>すべてのWeb サービス開発エンジニアにおすすめです。本書で本質的な知識を得て、準備万端にしておくと良いと思います。</p>

<!-- more -->




<h2>本書の目次</h2>




<ol>
<li>大規模Webサービスの開発オリエンテーション - <span class="fontSmall">全体像を把握する</span>
  <ol>
  <li>本書の源 - <span class="fontSmall">本書で説明すること、しないこと</span></li>
  <li>大規模なサービスと小規模なサービス</li>
  <li>成長し続けるサービスと、大規模化の壁</li>
  <li>サービス開発の現場</li>
  </ol>
</li>
<li>大規模データ処理入門 - <span class="fontSmall">メモリとディスク、Webアプリケーションと負荷</span>
  <ol>
  <li>はてなブックマークのデータ規模 - <span class="fontSmall">データが大きいと処理に時間がかかる</span></li>
  <li>大規模データ処理の難所 - <span class="fontSmall">メモリとディスク</span></li>
  <li>スケーリングの要所</li>
  <li>大規模データを扱うための基礎知識</li>
  </ol>
</li>
<li>OSのキャッシュと分散 - <span class="fontSmall">大きなデータを効率良く扱うしくみ</span>
  <ol>
  <li>OSのキャッシュ機構</li>
  <li>I/O負荷の軽減策</li>
  <li>局所性を活かす分散</li>
  </ol>
</li>
<li>DBのスケールアウト戦略 - <span class="fontSmall">分散を考慮したMySQLの運用</span>
  <ol>
  <li>インデックスを正しく運用する - <span class="fontSmall">分散を考慮したMySQL運用の大前提</span></li>
  <li>MySQLの分散 - <span class="fontSmall">スケーリング前提のシステム設計</span></li>
  <li>MySQLのスケールアウトとパーティショニング</li>
  </ol>
</li>
<li>大規模データ処理[実践]入門 - <span class="fontSmall">アプリケーション開発の勘所</span>
  <ol>
  <li>用途特化型インデクシング - <span class="fontSmall">大規模データを捌く</span></li>
  <li>理論と実践の両側から取り組む</li>
  </ol>
</li>
<li>[課題]圧縮プログラミング - <span class="fontSmall">データサイズ、I/O高速化との関係を意識する</span>
  <ol>
  <li>[課題]整数データをコンパクトに持つ</li>
  <li>VB Codeと速度感覚</li>
  <li>課題の詳細と回答例</li>
  </ol>  
</li>
<li>アルゴリズムの実用化 - <span class="fontSmall">身近な例で見る理論・研究の実戦投入</span>
  <ol>
  <li>アルゴリズムと評価</li>
  <li>はてなダイアリーのキーワードリンク</li>
  <li>はてなブックマークの記事カテゴライズ</li>
  </ol>
</li>
<li>[課題]はてなキーワードリンクの実装 - <span class="fontSmall">応用への道筋を知る</span>
  <ol>
  <li>[課題]はてなキーワードリンクを作る</li>
  <li>回答例と考え方</li>
  </ol>
</li>
<li>全文検索技術に挑戦 - <span class="fontSmall">大規模データ処理のノウハウ満載</span>
  <ol>
  <li>全文検索技術の応用範囲</li>
  <li>検索システムのアーキテクチャ</li>
  <li>検索エンジンの内部構造</li>
  </ol>
</li>
<li>[課題]全文検索エンジンの作成 - <span class="fontSmall">基本部分、作り込み、速度と精度の追求</span>
  <ol>
  <li>[課題]はてなブックマーク全文検索を作る</li>
  <li>回答例と考え方</li>
  </ol>
</li>
<li>大規模データ処理を支えるサーバ/インフラ入門 - <span class="fontSmall">Webサービスのバックエンド</span>
  <ol>
  <li>エンタープライズ vs. Webサービス</li>
  <li>クラウド vs. 自前インフラ</li>
  </ol>
</li>
<li>スケーラビリティの確保に必要な考え方 - <span class="fontSmall">規模の増大とシステムの拡張</span>
  <ol>
  <li>レイヤとスケーラビリティ</li>
  <li>負荷の把握、チューニング</li>
  </ol>
</li>
<li>冗長性の確保、システムの安定化 - <span class="fontSmall">ほぼ100%の稼働率を実現するしくみ</span>
  <ol>
  <li>冗長性の確保</li>
  <li>システムの安定化</li>
  <li>システムの安定化対策</li>
  </ol>
</li>
<li>効率向上作戦 - <span class="fontSmall">ハードウェアのリソースの使用率を上げる</span>
  <ol>
  <li>仮想化技術</li>
  <li>ハードウェアと効率向上 - <span class="fontSmall">低コストを実現する要素技術</span></li>
  </ol>
</li>
<li>Webサービスとネットワーク - <span class="fontSmall">ネットワークで見えてくるサービスの成長</span>
  <ol>
  <li>ネットワークの分岐点</li>
  <li>さらなる上限へ</li>
  </ol>
</li>
<li>いまどきのWebサービス構築に求められる実践技術 - <span class="fontSmall">大規模サービスに対応するために</span>
  <ol>
  <li>ジョブキューシステム - <span class="fontSmall">TheSchwartz, Gearman</span></li>
  <li>ストレージの選択 - <span class="fontSmall">RDBMSかkey-valueストアか</span></li>
  <li>キャッシュシステム - <span class="fontSmall">Squid、Varnish</span></li>
  <li>計算クラスタ - <span class="fontSmall">Hadoop</span></li>
  </ol>
</li>
</ol>




<h2>おぼえがき</h2>




<h3>小規模サービスと大規模サービスの違い</h3>




<h4>スケーラビリティの確保と負荷分散</h4>


<p><blockquote><p>大量のアクセスがあるサービスでは、サーバ1台では処理しきれない負荷を同処理するかが一番の問題です。ここ10年のトレンドとしてはいわゆる「スケールアウト」がこの問題に対する戦略の基礎になります。</p></blockquote></p>

<p>大量のアクセスのある大規模サービスでは、<strong>スケーラビリティの確保</strong>と<strong>負荷分散</strong>が重要な問題になります。</p>

<p>ハードウェアが安くなってきた最近では、高価なハードウェアを購入するよりもコストを削減できます。ただその代わりに考えないといけないことも増えます。</p>

<p>複数のハードウェアを効率良く使うための負荷分散のしくみや、データの同期の問題、ネットワークのレイテンシ（遅延時間）をどうするか。</p>

<h4>冗長性</h4>


<p>スケールアウトでサーバを複数台用意すると、サーバの故障率は高くなります。どこかのサーバが1台故障したからといって、サービスが停止してしまうことは避けなければなりません。</p>

<h4>省力運用</h4>


<p>サーバ台数が増えてくると、それぞれのサーバの状況を把握することが困難になってきます。セキュリティ設定、ソフトウェアのバージョンなど、管理しなければならないことも増えてきます。</p>

<p>監視用ソフトウェアを使って自動化を行ったとしても実際に確認するのは人間の役目になります。いかに手間を掛けずに健康状態を維持するか。</p>

<h4>開発方法の統制</h4>


<p>大規模サービスになると、当然そのサービスに携わる人は増えてきます。効率化を図るための標準化や標準ツールの策定、教育やマネージメントなどの必要性が出てきます。</p>

<h3>大規模データの処理</h3>


<p><blockquote><p>大規模Webアプリケーションを運用するにあたっての苦労の多くは、この大規模データの扱いに集約されます。</p></p><p><p>データが小さいうちは、とくに工夫をしなくてもすべてメモリで処理できますし、複雑なアルゴリズムを使うよりもナイーブなアルゴリズムのほうがオーバーヘッドがないため早い、なんてこともままあって、I/O負荷などはまず問題となりません。しかし、サービスがある程度以上の規模になるとデータは増加します。このデータ量が分水域を超えたところで問題が顕在化します。そしてその対策は、応急処置ではなかなかに難しい。ここが大規模サービスの難所です。</p></p><p><p></p></blockquote></p>

<h3>ミニマムスタートと、変化を見込んだ管理と設計</h3>


<p>サービスが小規模の時には、あれこれ考えて早過ぎる最適化を行うのはよくありません。かといって、何も考えずにシステムを設計するのもまたよくありません。</p>

<p>サービス設計時にある程度のキャパシティ管理とデータが莫大に増加してしまわないような設計を行った上で、ミニマムスタートをきる。それがサービスを開始するときのコツです。</p>

<h3>大規模データ処理の難所</h3>


<p>大規模データ処理の難しいポイントは、<strong>メモリ内で計算ができない</strong>ことです。</p>

<p>コンピュータはメモリとディスクとで、10<sup>5</sup>〜10<sup>6</sup>倍以上の探索速度の差があります。また、メモリとディスクの転送速度では、メモリが約7.5GB/秒ほど出るのに対して、ディスクは58MB/秒ほどしかでません。</p>

<p>SSD(Solid State Drive) などの記憶装置が出てきたことで探索速度の差は縮まってきていますが、転送速度の差は埋めることがまだ出来ていない状況です。</p>

<h4>単一ホストの負荷</h4>


<p><blockquote><p>「負荷分散」と言う言葉から思い浮かべるのは、多くの場合、複数のホストに処理を担当させる文字通りの「分散」です。しかし、そもそも1台で処理できるはずの負荷をサーバ10数台で分散するのは本末転倒です。単一のサーバの性能を十分に引き出すことができてはじめて、複数サーバでの負荷分散が意味をなします。</p></blockquote></p>

<h4>ボトルネック見極め作業の基本的な流れ</h4>




<p class="option"><em>推測するな、計測せよ</em></p>




<ul><li>ロードアベレージを見る</li>
<li>CPU、I/Oのいずれがボトルネックかを探る</li>
<li>CPUの場合、ディスクやメモリはボトルネックになっていないかを確認。プログラムのバグも確認する</li>
<li>I/Oの場合、スワップが発生していないかを確認。メモリの使い方が適切か、足りているかを確認する</li></ul>




<div class="row">
<div class="col-sm-2">
<a href="http://www.amazon.co.jp/gp/product/4774135666?ie=UTF8&amp;tag=sorehabooks-22&amp;linkCode=xm2&amp;camp=247&amp;creativeASIN=4774135666" rel="external nofollow">
<img src="http://ecx.images-amazon.com/images/I/51uK4ACymiL._SL160_.jpg" />
</a>
</div>
<div class="col-sm-10">
<ul><li>『<em><a href="http://www.amazon.co.jp/gp/product/4774135666?ie=UTF8&amp;tag=sorehabooks-22&amp;linkCode=xm2&amp;camp=247&amp;creativeASIN=4774135666" rel="external nofollow">[24時間365日] サーバ/インフラを支える技術 ~スケーラビリティ、ハイパフォーマンス、省力運用</a></em>』</li><li>著者: 安井 真伸, 横川 和哉, ひろせ まさあき, 伊藤 直也, 田中 慎司, 勝見 祐己</li><li>出版社: 技術評論社</li></ul>
</div>
</div>




<h3>大規模データを扱う勘所</h3>




<h4>プログラミングの3つの勘所</h4>




<ol><li>いかにメモリで済ませるか</li>
<li>データ量の増加に強いアルゴリズムを使う</li>
<li>データ圧縮や検索技術を駆使する</li></ol>




<h4>3つの基礎知識</h4>




<ol><li>OSのキャッシュ</li>
<li>分散を考慮したRDBMSの運用</li>
<li>アルゴリズムとデータ構造</li></ol>




<h3>OSのキャッシュのしくみ</h3>


<p><section></p>

<h4>参考</h4>




<ul><li><a href="http://d.hatena.ne.jp/naoya/20070521/1179754203" rel="external nofollow">Linux のページキャッシュ - Hatena::Diary::naoya</a></li></ul>


<p></section></p>

<p>キャッシュを前提に I/O を軽減するというのが、I/O 対策の基本です。扱うデータ規模に対して十分な物理メモリを用意しておくことで、データがすべてキャッシュにのるので I/O が軽減できます。</p>

<p>また、データを圧縮することによって、そのままではキャッシュに全部のらなかったものがのるようになって、効率化ができるようになります。</p>

<h3>分散のポイント</h3>


<p>CPU が追いついていないときにサーバを増やす分には単純に増やせばよいですが、<em>ディスクアクセスによる負荷を軽減する場合は単純に増やすことはできません。</em></p>

<p>OS のキャッシュによって I/O を軽減する目的でサーバを増設する場合には、アクセスパターンを考慮して十分にデータがキャッシュにのるようにサーバを増やす必要があります。つまり、<em>単純に同じサーバを増やすというのでは効果がないことがあります。</em></p>

<p>特に、データベースがボトルネックになっているときには、データ量が多いテーブルをメモリが潤沢なサーバに移すなどのアクセスパターンによってサーバを分散させるようにする必要があります。</p>

<h3>局所性を考慮した分散</h3>


<p>いかにしてデータをキャッシュにのせた状態で処理するかを考えて、分散を行う必要があります。例えば、データベースの分散の手法には様々ありますが、主なものには次のものがあります。</p>

<dl><dt>テーブル単位での分割</dt>
<dd><p>1台のサーバのメモリ上にのるように、テーブル単位でサーバを分割する方法。アプリケーション側の変更も必要になる</p></dd>
<dt>データの途中で分割</dt>
<dd><p>テーブル単位で分割ではなくデータの途中から別のサーバに分割する方法。たとえば、イニシャルがA〜M、N〜Zでサーバを分ける。これも、アプリケーション側の変更が必要になる</p></dd>
<dt>リクエストパターンによって分割する</dt>
<dd><p>最近のデータ、過去のデータなどといった感じでリクエストのパターンによってデータを分割し、サーバを分散する方法。API からのリクエスト、検索エンジンからのリクエストなどで分けたりもする</p></dd>
</dl>


<p><em>テーブルを分散させるときには、アプリケーション側で JOIN を極力使わないようにする必要があります。</em>多くの RDBMS では別サーバにあるテーブルどうしを JOIN することができません。</p>

<h3>サーバ再起動時には一度データをリードする</h3>


<p><blockquote><p>MySQLなどのDBサーバを運用するにあたって、大規模なデータを扱う場合にはここに注意が必要です。たとえば、メンテナンスなどでサーバを再起動した場合、それまでにメモリにキャッシュされていたページキャッシュは、すべてフラッシュされてしまいます。(中略）。一度必要なデータ全体に読み込みをかけてから、プロダクション環境に戻すといった工夫が必要になります。</p></blockquote></p>

<h3>Bツリーインデックスはハードディスクのアクセスと相性がいい</h3>


<p><section></p>

<h4>参考</h4>




<ul><li><a href="http://www.atmarkit.co.jp/fdb/rensai/oraobstacle03/oraobstacle03_1.html" rel="external nofollow">Bツリーインデックスに最高のパフォーマンスを - @IT</a></li></ul>


<p></section></p>

<p>Bツリーはそのデータ構造上、ページキャッシュと相性がいいです。なので、データベースでインデックスを貼る際にはBツリーインデックスを使うことが多いです。また、Bツリーをさらに最適化したものに、<a href="http://www.atmarkit.co.jp/icd/root/24/21256624.html" rel="external nofollow">B+ツリー</a>というものもあります。</p>

<h4>MySQLのインデックスの癖</h4>


<p><blockquote><p>複数のカラムがインデックス利用の対象になった場合です。(中略)。MySQLは1回のクエリでインデックスを1つしか使わない、という癖を持っているのが原因です。</p></blockquote></p>

<div class="row">
<div class="col-sm-2">
<a href="http://www.amazon.co.jp/gp/product/4873114268?ie=UTF8&amp;tag=sorehabooks-22&amp;linkCode=xm2&amp;camp=247&amp;creativeASIN=4873114268" rel="external nofollow">
<img src="https://images-na.ssl-images-amazon.com/images/I/51s%2Bp62hCgL._SL160_.jpg" alt="実践ハイパフォーマンスMySQL 第2版" />
</a>
</div>
<div class="col-sm-10">
<ul><li>『<em><a href="http://www.amazon.co.jp/gp/product/4873114268?ie=UTF8&amp;tag=sorehabooks-22&amp;linkCode=xm2&amp;camp=247&amp;creativeASIN=4873114268" rel="external nofollow">実践ハイパフォーマンスMySQL 第2版</a></em>』</li><li>著者: Baron Schwartz (著), Peter Zaitsev (著), Vadim Tkachenko (著), Jeremy D. Zawodny (著), Arjen Lentz (著), Derek J. Balling (著), 伊藤 直也 (監訳) (翻訳), 田中 慎司 (監訳) (翻訳), 吉川 英興 (監訳) (翻訳), 株式会社クイープ (翻訳)</li><li>出版社: オライリージャパン</li></ul>
</div>
</div>


<p>インデックスが効くかどうかは、explain コマンドを使うと確認できます。</p>

<ul><li><a href="http://nippondanji.blogspot.com/2009/03/mysqlexplain.html" rel="external nofollow">MySQLのEXPLAINを徹底解説!! - 漢のコンピュータ道</a></li></ul>




<h3>更新系のデータベースでもスケールしやすい kye-value ストア</h3>


<p>RDBMS を使っていると、参照系のクエリに関しては、キャッシュに注意すればサーバを増設するだけなのでスケールしやすいです。しかし、更新系のクエリとなるとサーバの増設はとたんに難しくなります。</p>

<p>そこで、そもそも RDBMS を使わないという選択肢をとることも考えられます。単に値を書きこんで取り出すだけで、RDBMS の統計処理やソートなどが不要なのであれば、key-value ストアを使用するという方法を考えるといいです。</p>

<p><blockquote><p>単に値を保存して取り出すだけで、RDBが持つ複雑な統計処理や汎用的なソート処理が必要ないなら、key-valueストアはオーバーヘッドも少なく圧倒的に速いし、スケールしやすいんです。</p></blockquote></p>

<h3>圧縮アルゴリズム</h3>




<ul><li><a href="http://d.hatena.ne.jp/naoya/20090804/1249380645" rel="external nofollow">γ符号、δ符号、ゴロム符号による圧縮効果 - Hatena::Diary::naoya</a></li></ul>




<h3>アルゴリズムのオーダー表記</h3>


<p>右に行くほど計算量が多くなります。</p>

<pre>O(1) &lt; O(log n) &lt; O(n) &lt; O(n log n) &lt; O(n<sup>2</sup>) &lt; O(n<sup>3</sup>) ... O(n<sup>k</sup>) &lt; O(2<sup>n</sup>)</pre>




<h3>はてなで使っている（使っていたいた）マッチングアルゴリズムやデータ構造</h3>




<ul><li>パターンマッチング: <a href="http://ja.wikipedia.org/wiki/%E3%83%88%E3%83%A9%E3%82%A4%E6%9C%A8" rel="external nofollow">Trie(トライ木)</a></li>
<li>パターンマッチング: <a href="http://ja.wikipedia.org/wiki/%E3%82%A8%E3%82%A4%E3%83%9B-%E3%82%B3%E3%83%A9%E3%82%B7%E3%83%83%E3%82%AF%E6%B3%95" rel="external nofollow">Aho-Corasick法(AC法)</a></li>
<li>カテゴリ判定: <a href="http://ja.wikipedia.org/wiki/%E3%83%99%E3%82%A4%E3%82%B8%E3%82%A2%E3%83%B3%E3%83%95%E3%82%A3%E3%83%AB%E3%82%BF" rel="external nofollow">ベイジアンフィルタ</a></li>
</ul>




<h3>検索システムの6つのステージ</h3>


<p>全文検索システムを作る上で、大まかに作業を分けると、6つのステージに分解できます。</p>

<dl><dt>クロール</dt>
<dd><p>検索する対象のドキュメントを見つける</p></dd>
<dt>格納</dt>
<dd><p>ドキュメントを保存・格納する</p></dd>
<dt>インデクシング</dt>
<dd><p>ドキュメントからインデックスを構築する</p></dd>
<dt>検索</dt>
<dd><p>インデックスを元にクエリを含むドキュメントを検索する</p></dd>
<dt>スコアリング/ランキング</dt>
<dd><p>検索結果をどのような順番で表示するかを決める</p></dd>
<dt>結果表示</dt>
<dd><p>結果を表示する</p></dd>
</dl>




<div class="row">
<div class="col-sm-2">
<a href="http://www.amazon.co.jp/gp/product/0521865719?ie=UTF8&amp;tag=sorehabooks-22&amp;linkCode=xm2&amp;camp=247&amp;creativeASIN=0521865719" rel="external nofollow">
<img src="https://images-na.ssl-images-amazon.com/images/I/41xVx99-4yL._SL160_.jpg" alt="Introduction to Information Retrieval" />
</a>
</div>
<div class="col-sm-10">
<ul><li>『<em><a href="http://www.amazon.co.jp/gp/product/0521865719?ie=UTF8&amp;tag=sorehabooks-22&amp;linkCode=xm2&amp;camp=247&amp;creativeASIN=0521865719" rel="external nofollow">Introduction to Information Retrieval</a></em>』</li><li>著者: Christopher D. Manning (著), Prabhakar Raghavan (著), Hinrich Schuetze (著)</li><li>出版社: Cambridge University Press; Anniversary</li></ul>
</div>
</div>




<h3>仮想化のデメリット</h3>


<p>はてなでの経験則だそうですが、だいたい、</p>

<ul><li>CPUで2〜3%</li>
<li>メモリの性能も1割くらい</li>
<li>ネットワークの性能は半分くらい</li>
<li>I/O性能が5%くらい</li></ul>


<p>落ちるようです。</p>

<h3>SSDの寿命</h3>


<p><blockquote><p>SSDを扱う上で一番気になるのは、いつどのように壊れるのか、ということです。HDDが時間と共に消耗して壊れるのは周知の事実なのですが、SSDも時間とともに消耗して壊れる、と考えるのが自然です。</p></blockquote></p>

<p>フラッシュメモリも書き込みの消耗で壊れてしまうようです。新しいメディアを使うときは、それがどのように壊れるのかをきちんと確認して、監視する仕組みを整えておくことが必要です。</p>

<h3>ネットワークの限界</h3>


<p>1つのサブネットは500ホストくらいが限界のようです。サブネット内にホストがたくさんあると、ブロードキャストパケットの受信だけでも結構 CPU を食うようです。</p>

<h3>ジョブキュー、ストレージ、キャッシュシステム、計算クラスタ</h3>


<p><section></p>

<h4>いまどきのWebサービスに求められる実践技術</h4>




<ul><li>ジョブキューシステム -- TheSchwartz, Gearman</li>
<li>ストレージ -- RDBMS, key-valueストア</li>
<li>キャッシュシステム -- Squid, Varnish</li>
<li>計算クラスタ -- Hadoop</li></ul>


<p></section></p>

<h4>ストレージ選択のフローチャート</h4>


<p>本書より</p>

<p><img alt="flowchart.png" src="http://hamasyou.com/images/flowchart.png" width="558" height="474" class="mt-image-none" style="" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Webを支える技術 -HTTP、URI、HTML、そしてREST]]></title>
    <link href="http://hamasyou.com/blog/2010/05/31/4774142042/"/>
    <updated>2010-05-31T18:31:00+09:00</updated>
    <id>http://hamasyou.com/blog/2010/05/31/4774142042</id>
    <content type="html"><![CDATA[<p>Webで成功するサービスを作る究極の指針は「シンプルであること」だと思います。これは別にWebに限らずそうだと思います。例えば、AppleやSONYやDELLなどの起業が成功したのは、シンプルな製品、サービスを作り出したからではないかと思います。Googleの検索窓なんかは、究極のシンプルだと思います（だんだんといろんなものがつき始めましたが。。。）</p>

<p>業務で使用するWebサービス、コンシューマ向けのWebアプリケーションAPIなどもこの設計指針が当てはまると思いますし、本書はこのことだけが追求されて書かれている良書です。</p>

<p>Webの成り立ち、ここまで成長してきたのは何故か、Webをより良く使うための設計方針が本書には詰まっています。Web開発の初心者にはもちろん、Web開発をバンバンにやってきた人にも、一度は目を通して欲しい本です。かなりオススメですし、読めば必ず目から鱗間違いなしです。</p>

<!-- more -->


<p>RESTについては、<a href="http://hamasyou.com/archives/000343" rel="external nofollow">RESTful Webサービス</a>の記事も参考にしてください。</p>

<h2>Webを支える技術</h2>




<dl>
  <dt>HTTP、URI、HTML</dt>
  <dd><p>HTTPというシンプルなプロトコルの上で、リソースを一意に特定するURIを用いて、HTMLで記述されたメディアを読む。Webはそんなシンプルな技術によって成り立っています。</p></dd>
  <dt>ハイパーメディア</dt>
  <dd><p>テキスト、画像、音声、動画などをハイパーリンクで結びつけたシステムをハイパーメディアと呼びます。Webで最も重要なのはこのハイパーリンクによってメディアがリンクしているということです。</p></dd>  
  <dt>分散システム</dt>
  <dd><p>Webはひとつのシステムで成り立っているわけではなく、大量のコンピュータが組み合わさっています。ネットワーク上に散らばったこれらのコンピュータが相互動作するのは、シンプルなプロトコルだからこそと言えるでしょう。</p></dd>
</dl>




<h2>REST-Webのアーキテクチャスタイル</h2>


<p>RESTとはアーキテクチャスタイルでRESTアーキテクチャスタイルなアーキテクチャのことをRESTfulアーキテクチャと呼びます。</p>

<p><blockquote><p>RESTはWeb全体のアーキテクチャスタイルでもあり、個別のWebサービスやWeb APIのアーキテクチャスタイルでもあります。一人一人が作る個別のWebサービスやWeb APIでも、RESTの約束を守ることが重要です。個別のWebサービスが全体の調和を乱しては、全体が統一したアーキテクチャスタイルを守れないからです。</p></p><p><p></p><footer><strong>本書 P.27</strong></footer></blockquote></p>

<h3>リソース</h3>


<p>RESTの重要な概念の一つにリソースがあります。<strong>リソースとはWeb上に存在する名前を持った情報</strong>の事をいいます。WebではこれをURIで表します。</p>

<p>RESTfulアーキテクチャではこのリソースを「アドレス可能な状態」にしておくことで、システムとして綺麗な形（シンプルなプログラムが可能）になります。</p>

<p><blockquote><p>URIが備える、リソースを簡単に指し示せる性質のことを「アドレス可能性」（Addressability）と呼びます。リソースをアドレス可能な状態、すなわちきちんと名前が付いており適切な手段でアクセスできる状態にすると、プログラムをとても作りやすくなります。</p></p><p><p></p><footer><strong>本書 P.29</strong></footer></blockquote></p>

<p>リソースは複数のURIを持つことができます。例えば、</p>

<pre>
http://www.hamasyou.com/reports/newest
</pre>




<pre>
http://www.hamasyou.com/reports/system/2010-05-31/1
</pre>


<p>は同じリソースを指すことができます。ただし、一つ目のURIは時間の経過とともに指し示すリソースが変わってしまうことがあります。常に同じリソースを表したい場合には、パーマネントリンクなどを参考にすると良いでしょう。</p>

<h3>クールなURIは変わらない</h3>


<p>良いURIやきれいなURIの事を「<strong>クールURI</strong>」と呼ぶそうです。「URIが変わらないべきである。変わらないURIこそが最上のURIである。」</p>

<p>クールURIにするためには、次のことに気をつければ良さそうです。</p>

<ul>
  <li>プログラミング言語に依存した拡張子やパスを含めない</li>
  <li>メソッド名やセッションIDを含めない</li>
  <li>URIはリソースを表現する名詞にする</li>
</ul>




<h4>プログラミング言語に依存した拡張子やパスを含めない</h4>


<p>例えば、JavaのStrutsを使うと、スタンダードなURIは「.do」という拡張子がつけることが多くあります。また、CGIなどの場合には、スクリプト言語の拡張子（.pl、.rb、.cgi など）をそのまま使うことがあります。</p>

<p>また、CGIなどの場合、「cgi-bin」などのディレクトリ名をパスに含めることがあります。これもプログラミング言語に依存したパスを含めていることになります。</p>

<p>こういった、プログラミング言語のデファクト、パス情報、ファイル拡張子などをURIに含めないようにすると、URIが変わりにくくなります。</p>

<h4>メソッド名やセッションIDを含めない</h4>


<p>リソースに対する処理メソッド名をURIに含めると、使っているフレームワークや仕様変更によりURIが変わりやすくなってしまいます。また、セッションIDなどをURIに含めるとアクセスする度にURIが変わってしまいかねないという状況になってしまいます。</p>

<pre>
http://www.hamasyou.com/sample/execute?cmdName=showPage&page=3;jssessionid=1234567890
</pre>


<p>URIにはメソッド名やセッションIDを含めないようにすると良いです。RESTfulアーキテクチャでは、統一インターフェースとしてHTTPのメソッド（GET, POST, PUT, DELETE）を使用すると良いでしょう。</p>

<h4>URIはリソースを表現する名詞にする</h4>


<p>URIにはメソッド名を含めずに、HTTPメソッドを使用して処理を分けると良いです。</p>

<pre>
悪い（×）： http://www.hamasyou.com/show/articles?id=10 （POSTでアクセスする）
</pre>




<pre>
良い（◯）： http://www.hamasyou.com/articles/10  (GETでアクセスする）
</pre>




<h2>URI設計のテクニック</h2>




<h3>拡張子で表現を指定する</h3>


<p><blockquote><p>ここまで、拡張子はURIの設計にとって悪であると述べてきました。しかし、悪いのは「.cgi」や「.pl」など実装に依存した拡張子です。実装に依存していない拡張子は良い側面を持つ場合もあります。</p></p><p><p></p><footer><strong>本書 P.60</strong></footer></blockquote></p>

<dl>
  <dt>言語を指定する拡張子</dt>
  <dd>言語を指定する拡張子「.ja」「.en」をリソースに含める。</dd>
  <dt>フォーマットを指定する拡張子</dt>
  <dd>「.html」「.atom」「.xml」「.json」などの表現フォーマットを指定する拡張子をリソースに含める。</dd>
</dl>




<h2>その他</h2>




<h3>統一インターフェース</h3>




<dl>
  <dt>GET</dt>
  <dd>リソースを取得する場合に使う。冪等（べきとう）。</dd>
  <dt>POST</dt>
  <dd>リソースを作成するときに使う。レスポンスとしてリソースのURIを返してくれることを希望する（新規作成の場合など）。新しいリソースのURIはLocationヘッダで返される（POST後はリダイレクトされる）。冪等ではない。</dd>
  <dt>PUT</dt>
  <dd>リソースを更新するときに使う。リソースのURIは変わらない。冪等だがリソースの状態は変わる。</dd>
  <dt>DELETE</dt>
  <dd>リソースを削除する時に使う。リソースのURIがわかっている場合に使い、なんど呼び出しても結果は変わらないべき。つまり、存在しないリソースに対してのDELETEは何もいわずに成功するし、DELETEによって他のリソースのURI表現が変わることはないようにする。冪等。</dd>
</dl>




<h3>検索結果にリソース表現</h3>




<pre>
http://www.hamasyou.com/articles/search?q={query}
</pre>


<p>searchというメソッド名をURIを含めているじゃないかと思うが、そうではなく、これは検索結果というリソースを表している（searchは名詞の方の検索）。</p>

<h3>オブジェクトモデルにおける関連のリソース表現</h3>


<p>関連のどちらがトップレベルリソース（上にくるリソース）かを考え、URIの階層構造でURIを表す。</p>

<p>記事群-設計カテゴリ-最新記事の場合。</p>

<pre>
http://www.hamasyou.com/articles/system/newest
</pre>


<p>設計カテゴリ-記事群-最新記事の場合。</p>

<pre>
http://www.hamasyou.com/system/articles/newest
</pre>




<h3>ロック機構をリソースで表す</h3>


<p>Web APIによってはロック機構を組み込みたい場合があります。この場合は、ロックを表す子リソースを作ることで対応できます。</p>

<p>リソースに対して、ロックリソースを作成し、そのロックリソースをDELETEすることでロック解除を表す。</p>

<p>本書 P.289より抜粋。</p>

<pre>
POST /1120034 HTTP/1.1
Host: zip.ricollab.jp
Content-Type: application/x-www-form-urlencoded
Authorization: Basic ...
 
scope=exclusive&timeout=300
</pre>


<p>ロック用のパラメータをリソースに対して送信し、ロックリソースを作成する。</p>

<pre>
HTTP/1.1 201 Created
Location: http://zip.ricollab.jp/1120034/lock
Content-Type: application/json
 
{
 "locktype": "exclusive",
 "timeout": "2010-09-07T10:00:30Z",
 "owner": "yohei"
}
</pre>


<p>ロック解除は、POSTで作成された子リソース（lock）を削除することで行う。</p>

<pre>
DELETE /1120034/lock HTTP/1.1
Host: zip.ricollab.jp
Authorization: Basic ... 
</pre>




<pre>
HTTP/1.1 200 OK
</pre>




<h2>参考</h2>




<div class="rakuten">
<table width="400" border="0" cellpadding="5"><tr><td colspan="2"><a href="http://www.amazon.co.jp/RESTful-Web%E3%82%B5%E3%83%BC%E3%83%93%E3%82%B9-Leonard-Richardson/dp/4873113539%3FSubscriptionId%3D15SMZCTB9V8NGR2TW082%26tag%3Dsorehabooks-22%26linkCode%3Dxm2%26camp%3D2025%26creative%3D165953%26creativeASIN%3D4873113539" rel="external nofollow">G-Tools</a></font></td></tr></table>
</div>




<div class="rakuten">
<table width="400" border="0" cellpadding="5"><tr><td colspan="2"><a href="http://www.amazon.co.jp/Web%E3%82%B5%E3%83%BC%E3%83%93%E3%82%B9%E3%83%97%E3%83%A9%E3%83%83%E3%83%88%E3%83%95%E3%82%A9%E3%83%BC%E3%83%A0%E3%82%A2%E3%83%BC%E3%82%AD%E3%83%86%E3%82%AF%E3%83%81%E3%83%A3-Sanjiva-Weerawarana/dp/4434073435%3FSubscriptionId%3D15SMZCTB9V8NGR2TW082%26tag%3Dsorehabooks-22%26linkCode%3Dxm2%26camp%3D2025%26creative%3D165953%26creativeASIN%3D4434073435" rel="external nofollow">G-Tools</a></font></td></tr></table>
</div>



]]></content>
  </entry>
  
</feed>
