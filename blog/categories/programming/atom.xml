<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Programming | それはBooks]]></title>
  <link href="http://hamasyou.com/blog/categories/programming/atom.xml" rel="self"/>
  <link href="http://hamasyou.com/"/>
  <updated>2014-09-21T14:00:23+09:00</updated>
  <id>http://hamasyou.com/</id>
  <author>
    <name><![CDATA[hamasyou]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[iOS] ReactiveCocoa の RACCommand で、実行中にローディングを出す方法]]></title>
    <link href="http://hamasyou.com/blog/2014/09/19/reactivecocoa-raccommand-executing/"/>
    <updated>2014-09-19T18:13:11+09:00</updated>
    <id>http://hamasyou.com/blog/2014/09/19/reactivecocoa-raccommand-executing</id>
    <content type="html"><![CDATA[<p>最近 <a href="https://github.com/ReactiveCocoa/ReactiveCocoa">ReactiveCocoa</a> を使いまくってます。そのなかで調べた Signal の使い方イディオムのメモです。</p>

<p>RACCommand で検索処理とかしてるときに、ローディング画面やインジケータを表示したいということがあると思います。そういうときに使える Signal のイディオムです。コードは Swift で書いています。</p>

<p><em>MVVM</em> で viewModel が searchCommand を実装しているとします。また、ローディングインジケータの表示には <a href="https://github.com/jdg/MBProgressHUD">MBProgressHUD</a> を使っているとします。</p>

<pre><code class="swift MyViewController#viewDidLoad">searchButton.rac_command = viewModel.searchCommand
searchButton.rac_command.executing
    .subscribeNext({ [weak self] (executing) in
        if let weakSelf = self {
            if executing as Bool {
                MBProgressHUD.showHUDAddedTo(weakSelf.view, animated: true)
            } else {
                MBProgressHUD.hideHUDForView(weakSelf.view, animated: true)
            }
        }
    })
searchButton.rac_command.errors
    .subscribeNext({ (error) in
        // エラー時のメッセージ表示処理
        println(error.localizedDescription)
    })
</code></pre>

<p><code>executing</code> Signal はこういう風につかうんですね。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Swift] 多次元配列の定義の謎]]></title>
    <link href="http://hamasyou.com/blog/2014/09/12/swift-mysterious-multi-dimensional-array/"/>
    <updated>2014-09-12T11:21:20+09:00</updated>
    <id>http://hamasyou.com/blog/2014/09/12/swift-mysterious-multi-dimensional-array</id>
    <content type="html"><![CDATA[<p>Xcode6 GM でましたね！ Beta1 の頃から Swift 触ってますが、まぁ言語仕様がよく変わること（笑。</p>

<p>で、いつか直るだろうと思ってたけど、GM でも直っていない Swift の多次元配列の定義の謎に関してです。だれか理由分かる人いたら教えてください。。</p>

<p>下のようなコードがあるとします。</p>

<pre><code class="swift">
typealias NameAndValue = Dictionary&lt;String, String&gt;

let dict: [[NameAndValue]] = [
  [
     ["name": "",    "value": ""],
  ],
  [
     ["name": "",    "value": ""],
  ]]
</code></pre>

<p><code>typealias</code> で別名つけて2次元配列を定義しているだけです。要素が <code>Dictionary</code> になっています。ここまでは普通にコンパイルが通ります。</p>

<p>ですが、これをこんなふうに&hellip;</p>

<pre><code class="swift">
let dict: [[NameAndValue]] = [
  [
     ["name": "",    "value": ""],
     ["name": "",    "value": ""],
     ["name": "",    "value": ""],
     ["name": "",    "value": ""],
     ["name": "",    "value": ""],
     ["name": "",    "value": ""],
     ["name": "",    "value": ""],
     ["name": "",    "value": ""],
     ["name": "",    "value": ""],
     ["name": "",    "value": ""],
     ["name": "",    "value": ""],
     ["name": "",    "value": ""],
     ["name": "",    "value": ""],
     ["name": "",    "value": ""],     
     ["name": "",    "value": ""],
     ["name": "",    "value": ""],
     ["name": "",    "value": ""],
     ["name": "",    "value": ""],
     ["name": "",    "value": ""],                         
  ],
  [
     ["name": "",    "value": ""],
  ]]
</code></pre>

<p>配列の要素を増やしていきます。そうするとだいたい <strong>10件くらい</strong> からコンパイルが遅くなり、<strong>15件過ぎたくらいから</strong> コンパイルエラーが出るようになります。</p>

<pre><code>Cannot convert the expression's type '[[NameAndValue]]' to type 'StringLiteralConvertible'
</code></pre>

<p>意味がわからんです。。</p>

<p>仕方ないので</p>

<pre><code class="swift">var dict: [[NameAndValue]] = [[],[]]
dict[0].append(["name": "",    "value": ""])
dict[0].append(["name": "",    "value": ""])
dict[0].append(["name": "",    "value": ""])
dict[0].append(["name": "",    "value": ""])
dict[0].append(["name": "",    "value": ""])
dict[0].append(["name": "",    "value": ""])
dict[0].append(["name": "",    "value": ""])
dict[0].append(["name": "",    "value": ""])
dict[0].append(["name": "",    "value": ""])
dict[0].append(["name": "",    "value": ""])
dict[0].append(["name": "",    "value": ""])
dict[0].append(["name": "",    "value": ""])
dict[0].append(["name": "",    "value": ""])
dict[0].append(["name": "",    "value": ""])
dict[0].append(["name": "",    "value": ""])
dict[0].append(["name": "",    "value": ""])
dict[0].append(["name": "",    "value": ""])
dict[0].append(["name": "",    "value": ""])

dict[1].append(["name": "",    "value": ""])
dict[1].append(["name": "",    "value": ""])
dict[1].append(["name": "",    "value": ""])
dict[1].append(["name": "",    "value": ""])
dict[1].append(["name": "",    "value": ""])
</code></pre>

<p>こうやって、プログラムでデータ登録するようにしました。。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[ReactiveCocoa] catchTo の使いどころ]]></title>
    <link href="http://hamasyou.com/blog/2014/08/29/reactivecocoa-catchto/"/>
    <updated>2014-08-29T19:44:49+09:00</updated>
    <id>http://hamasyou.com/blog/2014/08/29/reactivecocoa-catchto</id>
    <content type="html"><![CDATA[<p><strong>ReactiveCocoa</strong> で <code>catchTo</code> の使い方を覚えたのでメモ。</p>

<p><a href="https://github.com/ReactiveCocoa/ReactiveCocoa">ReactiveCocoa</a></p>

<p>リアクティブプログラミングの詳細は省くとして、<code>RACSignal</code> のイベントには <code>next</code> と <code>completed</code> と <code>error</code> があります。それぞれ、<code>subscribeNext</code>、<code>subscribeCompleted</code>、<code>subscribeError</code> でハンドリングできるやつです。</p>

<p>で、HTTP API 等を呼び出す際に API 呼び出しの結果を JSON にパースして、結果をモデルに設定するみたいなことをやりたい時に、次のように行います。（Swift で記述しています。）</p>

<pre><code class="swift">RAC(self, "model") &lt;~ API.loadData()

class API {
    class func loadData() -&gt; RACSignal {
        return RACSignal.createSignal({ (subscriber: RACSubscriber!) in
            let url = NSURL(string: "http://localhost:300/search")
            let configuration = NSURLSessionConfiguration.defaultSessionConfiguration()
            configuration.HTTPAdditionalHeaders = ["Accept": "application/json"]
            let session: NSURLSession = NSURLSession(configuration: configuration)
            let task: NSURLSessionDataTask = session.dataTaskWithURL(url, completionHandler: { (data: NSData!, response: NSURLResponse!, error: NSError!) in
                if error == nil {
                    // data をパースしてモデル化
                    subscriber.sendNext(model)
                    subscriber.sendCompleted()
                } else {
                    subscriber.sendError(error)
                }
                session.invalidateAndCancel()
            })
            task.resume()
            return nil
        })
    }
}
</code></pre>

<p>こうすると、API の呼び出しが成功した場合には <code>subscriber.sendNext</code> の結果がきちんと <code>self.model</code> に設定されるわけですが、API の呼び出しが失敗して <code>subscriber.sendError</code> が呼び出されてしまうと、例外がなげられます。</p>

<p>ではどうするか。</p>

<h3>catchTo を使って sendError に備える</h3>

<p>そこで <code>catchTo</code> を使います。</p>

<pre><code class="swift">RAC(self, "model") &lt;~ API.loadData().catchTo(RACSignal.empty())
</code></pre>

<p><code>catchTo</code> は <code>sendError</code> が呼び出された場合に代わりに投げる <code>RACSignal</code> を指定します。そうすることで、ネットワークエラー等で API の呼び出しが失敗した場合には、<code>RACSignal.empty()</code> で何も起きなかったことになる（正確には sendCompleted が呼び出される）ようになります。</p>

<p>sendError 時に処理を行いたい場合には <code>catch</code> を代わりに使用します。</p>

<pre><code class="swift">RAC(self, "model") &lt;~ API.loadData()
    .catch({ (error: NSError!) -&gt; RACSignal! in
        return RACSignal.empty()
    })
</code></pre>

<p>以上です。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift での Dictionary<String, AnyObject> の扱いメモ]]></title>
    <link href="http://hamasyou.com/blog/2014/08/28/swift-dictionary-anyobject/"/>
    <updated>2014-08-28T00:12:25+09:00</updated>
    <id>http://hamasyou.com/blog/2014/08/28/swift-dictionary-anyobject</id>
    <content type="html"><![CDATA[<p>Swift で <code>Dictionary</code> を扱うときのメモです。API 呼び出しのレスポンスを JSON で扱いたい時に <code>Dictionary&lt;String, AnyObject&gt;</code> として扱う際のポイントです。</p>

<pre><code class="swift">typealias JSONDictionary = Dictionary&lt;String, AnyObject&gt;
let json = NSJSONSerialization.JSONObjectWithData(data, options: .MutableContainers, error: nil) as JSONDictionary

let str1 = json["foobar"]! as String    // String
let str2 = json["foobar"] as AnyObject? as? String  // String?

let str3 = json["foobar"] as String     // これはコンパイルエラー '(String, AnyObject)' is not convertible to 'String'
</code></pre>

<p>最後のはなぜコンパイルエラーになるかというと、<code>Dictionary</code> の <code>subscript</code> が2種類定義されていて、期待したのと違う方が呼び出されているからです。</p>

<pre><code class="swift">struct Dictionary&lt;Key : Hashable, Value&gt; : CollectionType, DictionaryLiteralConvertible {
    ...
    subscript (i: DictionaryIndex&lt;Key, Value&gt;) -&gt; (Key, Value) { get }
    subscript (key: Key) -&gt; Value?
    ...
}
</code></pre>

<p><code>json["foobar"]</code> の戻り値は <code>(Key, Value)</code> か <code>Value?</code> のどちらかですが、<code>as String</code> を付けた際に Optional ではないと判断されてしまい <code>(Key, Value)</code> が戻り値の型と判定されます。それでコンパイルエラーになるわけですね。</p>

<p>期待した通りに取得するには、<code>json["foobar"]</code> の戻り値を <code>Value?</code> として扱う必要があるので、</p>

<pre><code class="swift">json["foobar"]!
json["foobar"] as AnyObject?
</code></pre>

<p>のどちらかでアクセスする必要があるわけです。<code>!</code> を付けると unwrap されるので <code>nil</code> が入っていると実行時エラーになります。逆に <code>as AnyObject? as? String</code> でアクセスすると Optional 型になってしまいます。</p>

<p>API のインターフェースと相談して、どちらの型で処理するか決めるといいんじゃないかと思います。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SwiftでForce Unwrapping型の配列に値を追加できない]]></title>
    <link href="http://hamasyou.com/blog/2014/07/31/swift-array-force-unwrapping/"/>
    <updated>2014-07-31T11:28:11+09:00</updated>
    <id>http://hamasyou.com/blog/2014/07/31/swift-array-force-unwrapping</id>
    <content type="html"><![CDATA[<p>この記事は Xcode6 beta4 を元に記述しています。</p>

<h3>Swift の配列は mutable か immutable</h3>

<p>Swift では配列を <strong>mutable/immutable</strong> の区別なく定義することができるようになりました。</p>

<pre><code class="swift">var numbers = [1, 2, 3]
numbers[0] = 0
println(numbers)    // [0, 2, 3]
</code></pre>

<p><code>let</code> で定義すると <strong>immutable</strong>、<code>var</code> で定義すると <strong>mutable</strong> になり、配列の代入はすべてコピーで行われるようになっています。</p>

<h3>Force UnWrapping 型!</h3>

<p>で、ハマったのが次のようなコードです。</p>

<pre><code class="swift">var numbers: [Int]! = [1, 2, 3]
numbers[0] = 0    // error: '@lvalue $T7' is not identical to 'Int'
</code></pre>

<p>Force Unwrapping 型とでも言うんでしょうかね？変数に必ず値が入ってることを保証するために <code>!</code> が付いた型です。
この型で定義した配列には、値の追加や変更ができなくなっています。。</p>

<p>これで何が困るかというと、<code>UIKit</code> 使って <code>UIViewController</code> のサブクラスにプロパティを定義する際に
初期化を <code>viewDidLoad</code> で行う時には、<code>!</code> をつけないと <code>initializer</code> が必要になってしまうので、プロパティの定義には <code>!</code> を付けていました。</p>

<p>そうすると、<em>mutable</em> で扱いたかったプロパティなのに、変更できないという問題にぶち当たったわけです。。どうすんだこれ。。。</p>

<h4>コンパイルエラーの例</h4>

<pre><code class="swift">class MyViewController: UIViewController {

  var numbers: [Int]!

  override func viewDidLoad() {
    super.viewDidLoad()

    self.numbers = [1, 2, 3]
  }


  func myFunc() {
    self.numbers[0] = 0     // コンパイルエラー
  }
}
</code></pre>

<h4>うまくいく例</h4>

<p>対応としては、一旦変数で受けて、変更後に元に戻すっていうので何とかなりますが、コンパイラの方でなんとかならんもんですかね。。</p>

<pre><code class="swift">  func myFunc() {
    var nums: [Int] = self.numbers
    nums[0] = 0
    self.numbers = nums
  }
</code></pre>
]]></content>
  </entry>
  
</feed>
