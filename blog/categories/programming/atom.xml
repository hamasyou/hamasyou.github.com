<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Programming | それはBooks]]></title>
  <link href="http://hamasyou.com/blog/categories/programming/atom.xml" rel="self"/>
  <link href="http://hamasyou.com/"/>
  <updated>2014-08-30T11:57:48+09:00</updated>
  <id>http://hamasyou.com/</id>
  <author>
    <name><![CDATA[hamasyou]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[ReactiveCocoa] catchTo の使いどころ]]></title>
    <link href="http://hamasyou.com/blog/2014/08/29/reactivecocoa-catchto/"/>
    <updated>2014-08-29T19:44:49+09:00</updated>
    <id>http://hamasyou.com/blog/2014/08/29/reactivecocoa-catchto</id>
    <content type="html"><![CDATA[<p><strong>ReactiveCocoa</strong> で <code>catchTo</code> の使い方を覚えたのでメモ。</p>

<p><a href="https://github.com/ReactiveCocoa/ReactiveCocoa">ReactiveCocoa</a></p>

<p>リアクティブプログラミングの詳細は省くとして、<code>RACSignal</code> のイベントには <code>next</code> と <code>completed</code> と <code>error</code> があります。それぞれ、<code>subscribeNext</code>、<code>subscribeCompleted</code>、<code>subscribeError</code> でハンドリングできるやつです。</p>

<p>で、HTTP API 等を呼び出す際に API 呼び出しの結果を JSON にパースして、結果をモデルに設定するみたいなことをやりたい時に、次のように行います。（Swift で記述しています。）</p>

<pre><code class="swift">RAC(self, "model") &lt;~ API.loadData()

class API {
    class func loadData() -&gt; RACSignal {
        return RACSignal.createSignal({ (subscriber: RACSubscriber!) in
            let url = NSURL(string: "http://localhost:300/search")
            let configuration = NSURLSessionConfiguration.defaultSessionConfiguration()
            configuration.HTTPAdditionalHeaders = ["Accept": "application/json"]
            let session: NSURLSession = NSURLSession(configuration: configuration)
            let task: NSURLSessionDataTask = session.dataTaskWithURL(url, completionHandler: { (data: NSData!, response: NSURLResponse!, error: NSError!) in
                if error == nil {
                    // data をパースしてモデル化
                    subscriber.sendNext(model)
                    subscriber.sendCompleted()
                } else {
                    subscriber.sendError(error)
                }
                session.invalidateAndCancel()
            })
            task.resume()
            return nil
        })
    }
}
</code></pre>

<p>こうすると、API の呼び出しが成功した場合には <code>subscriber.sendNext</code> の結果がきちんと <code>self.model</code> に設定されるわけですが、API の呼び出しが失敗して <code>subscriber.sendError</code> が呼び出されてしまうと、例外がなげられます。</p>

<p>ではどうするか。</p>

<h3>catchTo を使って sendError に備える</h3>

<p>そこで <code>catchTo</code> を使います。</p>

<pre><code class="swift">RAC(self, "model") &lt;~ API.loadData().catchTo(RACSignal.empty())
</code></pre>

<p><code>catchTo</code> は <code>sendError</code> が呼び出された場合に代わりに投げる <code>RACSignal</code> を指定します。そうすることで、ネットワークエラー等で API の呼び出しが失敗した場合には、<code>RACSignal.empty()</code> で何も起きなかったことになる（正確には sendCompleted が呼び出される）ようになります。</p>

<p>sendError 時に処理を行いたい場合には <code>catch</code> を代わりに使用します。</p>

<pre><code class="swift">RAC(self, "model") &lt;~ API.loadData()
    .catch({ (error: NSError!) -&gt; RACSignal! in
        return RACSignal.empty()
    })
</code></pre>

<p>以上です。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift での Dictionary<String, AnyObject> の扱いメモ]]></title>
    <link href="http://hamasyou.com/blog/2014/08/28/swift-dictionary-anyobject/"/>
    <updated>2014-08-28T00:12:25+09:00</updated>
    <id>http://hamasyou.com/blog/2014/08/28/swift-dictionary-anyobject</id>
    <content type="html"><![CDATA[<p>Swift で <code>Dictionary</code> を扱うときのメモです。API 呼び出しのレスポンスを JSON で扱いたい時に <code>Dictionary&lt;String, AnyObject&gt;</code> として扱う際のポイントです。</p>

<pre><code class="swift">typealias JSONDictionary = Dictionary&lt;String, AnyObject&gt;
let json = NSJSONSerialization.JSONObjectWithData(data, options: .MutableContainers, error: nil) as JSONDictionary

let str1 = json["foobar"]! as String    // String
let str2 = json["foobar"] as AnyObject? as? String  // String?

let str3 = json["foobar"] as String     // これはコンパイルエラー '(String, AnyObject)' is not convertible to 'String'
</code></pre>

<p>最後のはなぜコンパイルエラーになるかというと、<code>Dictionary</code> の <code>subscript</code> が2種類定義されていて、期待したのと違う方が呼び出されているからです。</p>

<pre><code class="swift">struct Dictionary&lt;Key : Hashable, Value&gt; : CollectionType, DictionaryLiteralConvertible {
    ...
    subscript (i: DictionaryIndex&lt;Key, Value&gt;) -&gt; (Key, Value) { get }
    subscript (key: Key) -&gt; Value?
    ...
}
</code></pre>

<p><code>json["foobar"]</code> の戻り値は <code>(Key, Value)</code> か <code>Value?</code> のどちらかですが、<code>as String</code> を付けた際に Optional ではないと判断されてしまい <code>(Key, Value)</code> が戻り値の型と判定されます。それでコンパイルエラーになるわけですね。</p>

<p>期待した通りに取得するには、<code>json["foobar"]</code> の戻り値を <code>Value?</code> として扱う必要があるので、</p>

<pre><code class="swift">json["foobar"]!
json["foobar"] as AnyObject?
</code></pre>

<p>のどちらかでアクセスする必要があるわけです。<code>!</code> を付けると unwrap されるので <code>nil</code> が入っていると実行時エラーになります。逆に <code>as AnyObject? as? String</code> でアクセスすると Optional 型になってしまいます。</p>

<p>API のインターフェースと相談して、どちらの型で処理するか決めるといいんじゃないかと思います。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SwiftでForce Unwrapping型の配列に値を追加できない]]></title>
    <link href="http://hamasyou.com/blog/2014/07/31/swift-array-force-unwrapping/"/>
    <updated>2014-07-31T11:28:11+09:00</updated>
    <id>http://hamasyou.com/blog/2014/07/31/swift-array-force-unwrapping</id>
    <content type="html"><![CDATA[<p>この記事は Xcode6 beta4 を元に記述しています。</p>

<h3>Swift の配列は mutable か immutable</h3>

<p>Swift では配列を <strong>mutable/immutable</strong> の区別なく定義することができるようになりました。</p>

<pre><code class="swift">var numbers = [1, 2, 3]
numbers[0] = 0
println(numbers)    // [0, 2, 3]
</code></pre>

<p><code>let</code> で定義すると <strong>immutable</strong>、<code>var</code> で定義すると <strong>mutable</strong> になり、配列の代入はすべてコピーで行われるようになっています。</p>

<h3>Force UnWrapping 型!</h3>

<p>で、ハマったのが次のようなコードです。</p>

<pre><code class="swift">var numbers: [Int]! = [1, 2, 3]
numbers[0] = 0    // error: '@lvalue $T7' is not identical to 'Int'
</code></pre>

<p>Force Unwrapping 型とでも言うんでしょうかね？変数に必ず値が入ってることを保証するために <code>!</code> が付いた型です。
この型で定義した配列には、値の追加や変更ができなくなっています。。</p>

<p>これで何が困るかというと、<code>UIKit</code> 使って <code>UIViewController</code> のサブクラスにプロパティを定義する際に
初期化を <code>viewDidLoad</code> で行う時には、<code>!</code> をつけないと <code>initializer</code> が必要になってしまうので、プロパティの定義には <code>!</code> を付けていました。</p>

<p>そうすると、<em>mutable</em> で扱いたかったプロパティなのに、変更できないという問題にぶち当たったわけです。。どうすんだこれ。。。</p>

<h4>コンパイルエラーの例</h4>

<pre><code class="swift">class MyViewController: UIViewController {

  var numbers: [Int]!

  override func viewDidLoad() {
    super.viewDidLoad()

    self.numbers = [1, 2, 3]
  }


  func myFunc() {
    self.numbers[0] = 0     // コンパイルエラー
  }
}
</code></pre>

<h4>うまくいく例</h4>

<p>対応としては、一旦変数で受けて、変更後に元に戻すっていうので何とかなりますが、コンパイラの方でなんとかならんもんですかね。。</p>

<pre><code class="swift">  func myFunc() {
    var nums: [Int] = self.numbers
    nums[0] = 0
    self.numbers = nums
  }
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SwiftはenumをAnyObject型の変数に入れられない]]></title>
    <link href="http://hamasyou.com/blog/2014/07/31/swift-enum-anyobject/"/>
    <updated>2014-07-31T10:39:48+09:00</updated>
    <id>http://hamasyou.com/blog/2014/07/31/swift-enum-anyobject</id>
    <content type="html"><![CDATA[<p>Swift で <em>enum</em> を扱う際にハマった問題です。確認は <em>Xcode6 beta4</em> で行っています。</p>

<h3>Swift の enum は AnyObject 型変数に代入できない</h3>

<p>Swift では <code>enum</code> を <code>AnyObject</code> 型の変数に入れることができません。コンパイルエラーになります。<code>Any</code> 型なら代入できます。</p>

<pre><code class="swift">enum SomeType: Int {
    case None = 0
    case Something
}

let something = SomeType.None
something                                     // Enum Value

let anything: AnyObject = SomeType.Something  // error: type 'SomeType' does not conform to protocol 'AnyObject'

let any: Any = SomeType.Something             // Enum Value
</code></pre>

<p>Swift の <code>enum</code> は <code>AnyObject</code> protocol を実装していないので、<code>AnyObject</code> 型の変数に入れることが出来ません。</p>

<h4>ReactiveCocoa とかと組み合わせるときにこまる</h4>

<p>これの何が不便かというと、<code>enum</code> は UIKit でよく使われていて、<a href="https://github.com/ReactiveCocoa/ReactiveCocoa">ReactiveCocoa</a> を Swift で使う際に
<code>enum</code> で設定する例えば <code>UITableViewCellAccessoryType</code> なんかを使いたい場合にコンパイルエラーになってしまいます。</p>

<pre><code class="swift">// これはコンパイルエラーになる
RAC(self, "cell.accessoryType") = RACObserve(self, "viewModel.checked").map { ($0 as Bool) ? UITableViewCellAccessoryType.Checkmark : UITableViewCellAccessoryType.None }

// こうしないといけない。。
RACObserve(self.viewModel, "checked")
    .subscribeNext { [weak self] arg in
        let checked = arg as Bool
        self!.accessoryType = checked ? .Checkmark : .None
}
</code></pre>

<p>既存の Objective-C ライブラリで <code>id</code> が使われている箇所が、Swift では <code>AnyObject</code> に対応するので、
Closure 等で <code>id</code> を引数に取ったり、<code>id</code> を戻り値にしていたりする箇所が <code>AnyObject</code> になってしまい、
<code>enum</code> を利用することができません。</p>

<p>変数に代入するだけなら <code>Any</code> 型にすればいいんですが、既存ライブラリとの連携では難しそうです。 <sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>
これ、何かやり方ないんでしょうかね。。ReactiveSwift 待ちかなぁ</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>Any 型にすれば代入できることを <a href="https://twitter.com/takabosoft">@takabosoft</a> さんに教えてもらいました。ありがとうございます！<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift で UITableView 関連の操作をする際に NSIndexPath を作る方法]]></title>
    <link href="http://hamasyou.com/blog/2014/07/03/swift-uitableview-nsindexpath/"/>
    <updated>2014-07-03T11:53:41+09:00</updated>
    <id>http://hamasyou.com/blog/2014/07/03/swift-uitableview-nsindexpath</id>
    <content type="html"><![CDATA[<p>Swift で <code>UITableView</code> 関連のロジックを書くときに、<code>NSIndexPath</code> を作るときは</p>

<pre><code class="swift">let row = 0, section = 0
NSIndexPath(forRow: row, inSection: section)
</code></pre>

<p>のイニシャライザを使うべし。<code>NSIndexPath(index: row)</code> だと <code>row</code> の参照ができなくてエラーになる。</p>
]]></content>
  </entry>
  
</feed>
