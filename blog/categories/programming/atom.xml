<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Programming | それはBooks]]></title>
  <link href="http://hamasyou.com/blog/categories/programming/atom.xml" rel="self"/>
  <link href="http://hamasyou.com/"/>
  <updated>2015-11-25T15:36:39+09:00</updated>
  <id>http://hamasyou.com/</id>
  <author>
    <name><![CDATA[hamasyou]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[Swift] RxSwift で iBeacon の RangeBeaconsInRegion を 5秒間隔で受け取る方法]]></title>
    <link href="http://hamasyou.com/blog/2015/11/25/rxswift-de-ibeacon-false-rangebeaconsinregion-wo-5miao-jian-ge-deshou-kequ-rufang-fa/"/>
    <updated>2015-11-25T15:25:47+09:00</updated>
    <id>http://hamasyou.com/blog/2015/11/25/rxswift-de-ibeacon-false-rangebeaconsinregion-wo-5miao-jian-ge-deshou-kequ-rufang-fa</id>
    <content type="html"><![CDATA[<p>CoreLocation を使って iBeacon の Ranging を行う場合、iOS だと 1秒間隔で通知されます。</p>

<p><a href="http://enamelsystems.com/0011/z">[参考] iBeacon(3) - リージョン監視とレンジング - Enamel Systems</a></p>

<p>そこで、1秒間隔だと通知間隔が短すぎるので、5秒間隔とか1分間隔とかに変えたい時にどうするかですが、<code>CLLocationManager</code> クラスに設定があればよかったのですが、特になさそうなので、<code>RxSwift</code> を使ってストリームのフィルタで対応する方法のメモです。</p>

<p><code>CLLocationManager</code> の初期設定とかは参考サイトを見てください。</p>

<p><a href="https://github.com/ReactiveX/RxSwift/">ReactiveX/RxSwift</a></p>

<pre><code class="swift">locationManager.rx_didRangeBeaconsInRegion
    .sample(interval(5, MainScheduler.sharedInstance))
    .subscribeNext { (tuple: ([CLBeacon]!, CLBeaconRegion!)) in
        debugPrint("beacons: \(tuple.0), region: \(tuple.1)")
    }
    .addDisposableTo(disposeBag)
</code></pre>

<p><code>Rx</code> の <code>sample</code> を使って、ストリームを <code>interval</code> 毎にサンプリングしてやるだけです。</p>

<p><a href="http://www.introtorx.com/content/v1.0.10621.0/13_TimeShiftedSequences.html#Sample">Time-shifted sequences - Introduction to Rx</a></p>

<p><code>RxSwift</code> も使いやすくて、めっちゃ便利です！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[iOS/Swift]ReactiveCocoa 3.0 で ViewModel から Signal をセルフ・コントロールするイディオム]]></title>
    <link href="http://hamasyou.com/blog/2015/08/13/ios-swift-reactivecocoa-signal-viewmodel/"/>
    <updated>2015-08-13T11:57:28+09:00</updated>
    <id>http://hamasyou.com/blog/2015/08/13/ios-swift-reactivecocoa-signal-viewmodel</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/ReactiveCocoa/ReactiveCocoa">ReactiveCocoa</a> が v.3.0-RC.1 がでて、そろそろ製品に Swift で ReactiveCocoa が使えるようになりそうな感じになってきました。</p>

<p>いつも <code>Signal</code> を自分で制御するイディオムを忘れてしまうので、メモ書きです。</p>

<pre><code class="swift">import Foundation
import UIKit
import ReactiveCocoa

class MyViewModel {
    let (changed, sink) = Signal&lt;Void, NoError&gt;.pipe()

    func doAction() {
        // do something
        sendNext(sink, ())
    }    
}


class MyViewController : UIViewController {
    let viewModel = MyViewModel()

    override func viewDidLoad() {
        super.viewDidLoad()

        viewModel.changed |&gt; observe(next: debugPrintln)

        viewModel.doAction()              
    }
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[iOS]Swift の Dollar ライブラリの each 関数を SequenceType に対応する拡張]]></title>
    <link href="http://hamasyou.com/blog/2015/08/12/ios-swift-dollar-each-sequencetype/"/>
    <updated>2015-08-12T16:47:11+09:00</updated>
    <id>http://hamasyou.com/blog/2015/08/12/ios-swift-dollar-each-sequencetype</id>
    <content type="html"><![CDATA[<p>Swift のメモ書きです。</p>

<p><a href="https://github.com/ankurp/Dollar.swift">ankurp/Dollar.swift</a> という JavaScript の Lo-Dash や Underscore と同じ感じでコレクションを扱うためのライブラリがありますが、 <code>each</code> が配列しか受け付けることが出来ないので、<code>SequenceType</code> を受け取れるように拡張する方法のメモです。</p>

<pre><code class="swift">import Dollar

extension $ {
    class func each&lt;T: SequenceType&gt;(array: T, callback: (T.Generator.Element) -&gt; ()) -&gt; T {
        for elem in array {
            callback(elem)
        }
        return array
    }
}

$.each(["a", "b", "c"]) { (s: String) in println(s) }
$.each(["key": "val"]) { (e: (String, String)) in println("\(e.0) = \(e.1)") }
// a
// b
// c
// key = val
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift の Array と Dictionary の Extension（each と map を実装した）]]></title>
    <link href="http://hamasyou.com/blog/2015/06/10/swift-array-dictionary-extension/"/>
    <updated>2015-06-10T12:01:16+09:00</updated>
    <id>http://hamasyou.com/blog/2015/06/10/swift-array-dictionary-extension</id>
    <content type="html"><![CDATA[<h2>Array に each を実装してみた。</h2>

<pre><code class="swift">extension Array {
    func each(block: (T) -&gt; ()) {
        for item in self {
            block(item)
        }
    }

    func each&lt;U&gt;(block: (U) -&gt; ()) {
        for item in self {
            block(item as! U)
        }
    }

    func eachWithIndex(block: (T, Int) -&gt; ()) {
        for (i, item) in enumerate(self) {
            block(item, i)
        }
    }

    func eachWithIndex&lt;U&gt;(block: (U, Int) -&gt; ()) {
        for (i, item) in enumerate(self) {
            block(item as! U, i)
        }
    }
}
</code></pre>

<p>使い方はこんな感じ。</p>

<pre><code class="swift">[1, 2, 3].each { (n: Int) in println(n) }
[1, 2, 3].each { println($0) }
[1, 2, 3].eachWithIndex { (n: Int, i: Int) in println("index \(i), n \(n)") }
[1, 2, 3].eachWithIndex { println("index \($1), n \($0)") }
</code></pre>

<p>配列の中身が <code>AnyObject</code> だった時に、型指定するときとしない時でどっちも動くようにするのに、メソッドを2つ定義しました。</p>

<p>このへん、<em>Generics</em> の達人のかたに、もっといい書き方あるよって教えて欲しいです。</p>

<h2>Swift の Dictionary に map を実装してみた。</h2>

<p>ついでに <code>reduce</code> も。</p>

<pre><code class="swift">extension Dictionary {
    func map&lt;T&gt;(transform: (Key, Value) -&gt; T) -&gt; [T] {
        return Swift.map(self, transform)
    }

    func reduce&lt;T&gt;(initial: T, combine: (T, (Key, Value)) -&gt; T) -&gt; T {
        return Swift.reduce(self, initial, combine)
    }
}
</code></pre>

<p>使い方はこんな感じ。</p>

<pre><code class="swift">var dict = [String: String]()
dict["hello"] = "world"

let array = dict.map { (k: String, v: String) -&gt; String in
    return v
}
println(array)      // ["world"]


dict = [String: Int]()
dict["a"] = 1
dict["b"] = 2
dict["c"] = 3
dict["d"] = 4
dict["e"] = 5
let n = dict.reduce(0) { (n, d) -&gt; Int in n + d.1 }    // 15
</code></pre>

<p>Ruby の map っぽい感じで使えるにしたかったので。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[iOS8対応]UITableViewのSeparatorInsetsをゼロにする方法]]></title>
    <link href="http://hamasyou.com/blog/2014/12/25/ios8-swift-uitableview-separatorinsets/"/>
    <updated>2014-12-25T11:03:14+09:00</updated>
    <id>http://hamasyou.com/blog/2014/12/25/ios8-swift-uitableview-separatorinsets</id>
    <content type="html"><![CDATA[<h2>iOS8 から separatorInset だけだと区切り線が広がらない</h2>

<p>こんにちは。iOS8 から SeparatorInsets をゼロにする方法が変わりました。今までの <code>UITableView</code> の <code>separatorInset</code> に <code>UIEdgeInsetsZero</code> を入れるだけだと、iOS7 では効きますが、iOS8 では効かなくなりました。</p>

<pre><code class="swift">tableView.separatorInset = UIEdgeInsetsZero
</code></pre>

<p><img src="/images/2014-12-25-tableview.png" width="320" title="&ldquo;図1&rdquo;" ></p>

<h2>iOS8 にも対応するには</h2>

<p>iOS8 からは <code>UIView</code> に追加された <code>layoutMargins</code> というプロパティにも <code>UIEdgeInsetsZero</code> をセットする必要があります。ただこのプロパティ、iOS8 以降でしか利用できないプロパティなので、分岐が必要になります。。</p>

<pre><code class="swift">tableView.layoutMargins = UIEdgeInsetsZero
cell.layoutMargins = UIEdgeInsetsZero
</code></pre>

<h3>全体に適用する簡単な例</h3>

<p>全体に適用するには UIAppearance を使うと便利です。iOS7 と iOS8 に対応したコードは次のように書けます。</p>

<pre><code class="swift">let version = NSString(string: UIDevice.currentDevice().systemVersion).doubleValue

UITableView.appearance().separatorInset = UIEdgeInsetsZero
UITableViewCell.appearance().separatorInset = UIEdgeInsetsZero
if version &gt;= 8 {
    UITableView.appearance().layoutMargins = UIEdgeInsetsZero
    UITableViewCell.appearance().layoutMargins = UIEdgeInsetsZero
}
</code></pre>

<p><img src="/images/2014-12-25-tableview2.png" width="320" title="&ldquo;図2&rdquo;" ></p>
]]></content>
  </entry>
  
</feed>
