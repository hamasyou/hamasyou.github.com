<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Programming | それはBooks]]></title>
  <link href="http://hamasyou.com/blog/categories/programming/atom.xml" rel="self"/>
  <link href="http://hamasyou.com/"/>
  <updated>2014-06-26T19:16:26+09:00</updated>
  <id>http://hamasyou.com/</id>
  <author>
    <name><![CDATA[hamasyou]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Apple Swift プログラミング言語おぼえがき]]></title>
    <link href="http://hamasyou.com/blog/2014/06/26/apple-swift/"/>
    <updated>2014-06-26T08:00:55+09:00</updated>
    <id>http://hamasyou.com/blog/2014/06/26/apple-swift</id>
    <content type="html"><![CDATA[<p>Apple が新しいプログラミング言語 <strong>Swift</strong> を2014年の WWDC で発表しました。言語仕様自体は色々なモダンプログラミング言語のいいとこ取りのような感じです。独特な仕様もいくつかあるのでおぼえがきしておきます。</p>

<p>なお、Swift で作成したアプリは iOS8 と OS X Yosemite がリリースされた時点で審査に入れるようです。</p>

<p><a href="https://developer.apple.com/swift/">Introducing Swift</a></p>

<!-- more -->




<div id="toc"></div>


<h2>The Basics</h2>

<p><code>NSLog</code> の代わりに <code>println</code> が使える。Xcode のコンソールにも表示される。文字列の変数展開は <code>\()</code> を使う。</p>

<pre><code class="swift">let name = "hamasyou"
println("Hello \(name)")  // Hello hamasyou
</code></pre>

<h3>基本型</h3>

<p><code>Int</code>、<code>Double</code>、<code>Float</code>、<code>Bool</code>、<code>String</code>、<code>Array</code>、<code>Dictionary</code> などが用意されている。<code>Int16</code> や <code>UInt8</code> などもある。型の変換は <code>型名()</code> を使う。</p>

<p>Swift では <code>nil</code> を特別な値として定義している。<code>Bool</code> 値は <code>true</code> と <code>false</code>。条件式では <code>Bool</code> 値のみが使える。</p>

<pre><code class="swift">UInt8.max   // 255
UInt8.min   // 0

let three = 3
let floatValue = 0.14159
let pi = Double(three) + floatValue // 3.14159
let integerPi = Int(pi) // 3

if pi {
    // この文法はコンパイルエラーになる。正しくは↓
}

if pi == 3.14159 {
}
</code></pre>

<p>タプルも使える。不要な値を受け取るときは <code>_</code> を使う。</p>

<pre><code class="swift">let httpError = (404, "Not Found")
httpError.0   // 404
httpError.1   // "Not Found"

let otherError = (errorCode: 500, errorMessage: "Internal Server Error")
otherError.errorCode    // 500
otherError.errorMessage // "Internal Server Error"

let (code, msg) = httpError
code  // 404
msg   // "Not Found"

let (_, msg2) = otherError
msg2  // "Internal Server Error"
</code></pre>

<h3>リテラルと変数</h3>

<p>Swift ではリテラルの定義は <code>let</code> を使い、変数の定義は <code>var</code> を使う。<code>let</code> で定義したリテラルは変更できない。</p>

<pre><code class="swift">let myName = "hamasyou"
let π = 3.14
var x = 0.0, y = 0.0, z = 0.0
x = 3.0
</code></pre>

<p>文字列を数値に直すのに <code>toInt</code> メソッドが使える。この時返される値は <code>Int</code> 型でなく、<code>Int?</code> 型なので注意。</p>

<pre><code class="swift">let str = "123"
let num = str.toInt()   // num は Int? か Optional Int として型推論される
</code></pre>

<p>if 文の条件式には <code>Bool</code> しか記述できないが、この、<code>型 + ?</code> の形式で表される <code>Optional 型</code> も if 文の式に記述できる。この場合値が nil ではない場合に <code>true</code> と評価される。</p>

<pre><code class="swift">var str = "123"
var num = str.toInt()

if num {
    println("\(str) is number of \(num!)")
}
</code></pre>

<p>このように、Swift では <code>nil</code> を返す可能性があるメソッドの戻り値の型は <code>Optional 型</code> になる。<code>Optional 型</code> から値を取り出すには <code>!</code> をつける。但し、nil が入っている変数から値を取り出そうとするとランタイムエラーになる。</p>

<pre><code class="swift">str = "abc"
num = str.toInt()

println(num!)   // これはランタイムエラーになるので、必ず下の様に呼び出す

if !num {
    println("\(str) is not number")
}
</code></pre>

<p>Optional 型から値を取り出す方法に、<code>!</code> をつける以外に次のようにも書ける。（Optional Binding）</p>

<pre><code class="swift">let str = "123"
let expectNum = str.toInt()
if let actual = expectNum {
    println(actual)
}
</code></pre>

<h3>Implicity Unwrapped Optionals</h3>

<p>Swift は Objective-C の nil ポインタとは違う <code>nil</code> を採用している。nil が格納される可能性がある変数は Optional 型として定義する必要がある。</p>

<p>Optional 型の変数から値を取り出すには <code>!</code> を使う。必ず値が入っている確証が持てる場合は <code>型名 + !</code> の形で記述することもできる。値が入っていない時に <code>!</code> を使うとランタイムエラーがでるので注意。</p>

<pre><code class="swift">var optioanValue: Int?   // Optional 型の変数は nil で初期化される

let str = "123"
let num: Int! = str.toInt()
num   // num は 123 が入る Int! で定義しない場合は型推論によって Int? 型の Wrapped Value が入っているので 123 ではない
</code></pre>

<h3>Range</h3>

<p><code>(a..b)</code>、<code>(a...b)</code> の形で範囲を求めることができる。<code>(a..b)</code> は b を含まない。Ruby とは逆の動きをする。。。</p>

<pre><code class="swift">for i in (0..3) {
    println(i)    // 0, 1, 2
}
</code></pre>

<h2>String And Character</h2>

<p><code>String</code> は <code>NSString</code> が使われているところでも使える。String は <code>Character</code> のコレクション型である。</p>

<pre><code class="swift">let str = "Hello World"
let c: Character = "!"

let s = str + c

str.isEmpty             // false
str.hasPrefix("Hello")  // true
str.hasSuffix("World")  // true
</code></pre>

<h2>Collection Types</h2>

<h3>Array</h3>

<p>Swift の配列は <code>Array</code> 型。<code>Array&lt;SomeType&gt;</code> で表す。略語として <code>型名[]</code> の形式も使える。<code>NSArray</code>、<code>NSMutableArray</code> が使われているところでも使える。</p>

<pre><code class="swift">var list = ["Hello", "World", "Good"]
list.count
list += "Nice"      // ["Hello", "World", "Good", "Nice"]
list.removeLast()   // "Nice"

var stringList: String[]?             // nil
var anyList: Array&lt;AnyObject&gt;?        // nil
var stringList2: Array&lt;String&gt; = []   // empty String array
</code></pre>

<h3>Dictionary</h3>

<p>Swift の Hash は <code>Dictionary</code> 型。<code>Dictionary&lt;KeyType, ValueType&gt;</code> で定義する。<code>NSDictionary</code>、<code>NSMutableDictionary</code> が使われているところでも使える。</p>

<pre><code class="swift">var airports = ["TYO": "Tokyo", "DUB": "Dublin"]
// var airports: Dictionary&lt;String, String&gt; = ["TYO": "Tokyo", "DUB": "Dublin"] とも書ける
airports.count
airports["OSK"] = "OSAKA"
airports["HOGE"]    // nil
airports.keys       // ["TYO", "DUB", "OSK"]
airports.values

for (code, name) in airports {
}

var dict: Dictionary&lt;String, String&gt;?             // nil
var emptyDict = Dictionary&lt;String, String&gt;()      // empty Dictionary 
var emptyDict2: Dictionary&lt;String, String&gt; = [:]  // empty Dictionary
</code></pre>

<h2>Functions</h2>

<p>関数は <code>func メソッド名(引数: 型) -&gt; 戻り値の型</code> の形で書く。戻り値が必要ない場合は省略するか、<code>Void</code> を記述する。</p>

<p>Swift の関数（メソッド）は <em>第一級関数</em> なので、変数や引数に渡すことができる。</p>

<pre><code class="swift">func hello(name: String, greet: String) -&gt; String {
    return "Hello \(name), \(greet)"
} 
println(hello("hamasyou", "Good Morning"))

func sayHello(name: String) -&gt; Void {
    println("Hello \(name)")
}
sayHello("hamasyou")
</code></pre>

<p>戻り値にはタプルを指定することもできる。</p>

<pre><code class="swift">func count() -&gt; (vowels: Int, consonants: Int, others: Int) {
    var n1 = 3, n2 = 5, n3 = 10
    return (n1, n2, n3)
}

let ret = count()
ret.vowels
ret.consonants
ret.others
</code></pre>

<h3>External Parameter Names</h3>

<p>関数呼び出し時にキーワード引数として呼び出す名前を指定できる。</p>

<pre><code class="swift">func someFunction(externalParameterName localParameterName: Int) {
    var total = 10 + localParameterName
}
someFunction(externalParameterName: 5)

func join(s1: String, s2: String, withJoiner joiner: String) -&gt; String {
    return s1 + joiner + s2
}
join("Hello", "World", withJoiner: "-")
</code></pre>

<p><code>externalParameterName</code> と <code>localParameterName</code> を同じにしたいときは、<code>#</code> を使う。</p>

<pre><code class="swift">func(containsCharacter(#string: String, #characterToFind: Character) -&gt; Bool {
    for character in string {
        if character == characterToFind {
            return true
        }
    }
    return false
}
</code></pre>

<p>引数にデフォルト値を指定することもできる。デフォルト値を指定して、externalParameterName を指定しないときは、localParameterName が externalParameterName になる。</p>

<pre><code class="swift">func join(s1: String, s2: String, joiner: String = "-") -&gt; String {
    return s1 + joiner + s2
}
join("Hello", "World", joiner: " ")    
</code></pre>

<p><code>_</code> を externalParameterName に指定すれば、デフォルト値を設定しても呼び出し時に externalParameterName を指定する必要はなくなる。</p>

<pre><code class="swift">func join(s1: String, s2: String, _ joiner: String = "-") -&gt; String {
    return s1 + joiner + s2
}
join("Hello", "World", " ")
</code></pre>

<h3>In-Out Parameters</h3>

<p>関数の引数は定数（<code>let</code>）として渡される。引数を変数（<code>var</code>）として渡したい場合は、引数名の前に <code>var</code> をつける。</p>

<p>var をつけて引数を定義しても、変更の影響を受けるのは関数の中だけ。関数の外の変数にも影響を及ぼしたい場合には <code>inout</code> をつけて引数を定義して、引数を渡すときに <code>&amp;</code> を使う。</p>

<pre><code class="swift">func swap(inout s1: String, inout s2: String) {
    let tmp = s1
    s1 = s2
    s2 = tmp
}

var s1 = "Hello"
var s2 = "World"
swap(&amp;s1, &amp;s2)
s1    // "World"
s2    // "Hello"
</code></pre>

<h2>Closures</h2>

<p>Swift の Closure は次の点が最適化されている。</p>

<ul>
<li>引数と戻り値の型が推論される</li>
<li>Closre Body が単一式の場合はそれが暗黙の戻り値になる</li>
<li>引数を略式で書ける</li>
<li>Closure を最後の引数として取るメソッドの場合、Closure を <code>()</code> の外側に書くことができる</li>
</ul>


<pre><code class="swift Closure Syntax">{ (parameters) -&gt; returnType in
    statements
}
</code></pre>

<pre><code class="swift Closure syntaxes">let names = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]
sort(names, { (s1: String, s2: String) -&gt; Bool in
    return s1 &lt; s2
})

sort(names, { (s1: String, s2: String) -&gt; Bool in return s1 &lt; s2 })
sort(names, { s1, s2 in return s1 &lt; s2 })
sort(names, { s1, s2 in s2 &lt; s2 })
sort(names, { $0 &lt; $1 })
sort(names) { $0 &lt; $1 }  
</code></pre>

<pre><code class="swift map sample">let digitNames = [
    0: "Zero", 1: "One", 2: "Two",   3: "Three", 4: "Four",
    5: "Five", 6: "Six", 7: "Seven", 8: "Eight", 9: "Nine"
]
let numbers = [16, 58, 510]
let strings = numbers.map { (var num) -&gt; String in
    var output = ""
    while num &gt; 0 {
        output = digitNames[num % 10]! + output
        num /= 10
    }
    return output
}
strings
</code></pre>

<pre><code class="swift Closure sample">func makeIncrementor(forIncrement amount: Int) -&gt; (() -&gt; Int) {
    var runningTotal = 0
    func incrementor() -&gt; Int {
        runningTotal += amount
        return runningTotal
    }
    return incrementor
}

let incrementByTen = makeIncrementor(forIncrement: 10)
incrementByTen()    // 10
incrementByTen()    // 20
incrementByTen()    // 30
</code></pre>

<h2>Enumerations</h2>

<p>Swift では <code>Enumeration</code> も first-class type である。Swift ではデフォルト値を設定しない限り、自動で 0, 1, 2 の様な値がふられることはない。</p>

<pre><code class="swift">enum CompassPoint {
    case North
    case South
    case East
    case West
}
CompassPoint.North

enum Numbers: Int {
    case Zero = 0, One, Two, Three, Four, Five, Six, Seven, Eight, Nine
}
Numbers.Four.toRaw()                // 4
Numbers.fromRaw(7) == Numbers.Seven // true 
</code></pre>

<h3>Associated Values</h3>

<p>Swift の enumerations は関連する値を保持することができる。</p>

<pre><code class="swift">enum Barcode {
    case UPCA(Int, Int, Int)
    case QRCode(String)
}

let productBarcode = Barcode.UPCA(8, 85900_51226, 3)
switch productBarcode {
case let .UPCA(numberSystem, identifier, check):
    println("UPC-A with value of \(numberSystem), \(identifier), \(check).")
case let .QRCode(productCode):
    println("QR code with value of \(productCode).")
} 
</code></pre>

<h2>Classes and Structures</h2>

<p>Swift では、クラスと構造体はほぼ同じ物と考えることができる。構造体は参照ではなく copy value で管理される。</p>

<p><blockquote><p>Unlike value types, reference types are not copied when they are assigned to a variable or constant, or when they are passed to a function. Rather than a copy, a reference to the same existing instance is used instead.</p><footer><strong>Classes Are Reference Types</strong></footer></blockquote></p>

<h4>クラスと構造体の共通点</h4>

<ul>
<li><strong>プロパティ</strong> を定義することができる</li>
<li><strong>メソッド</strong> を定義することができる</li>
<li><strong>subscripts</strong> （配列の<code>[0]</code> のようにアクセスできる仕組み）を提供することができる</li>
<li><strong>イニシャライザ</strong> （コンストラクタ）を定義することができる</li>
<li>デフォルトの振る舞いを拡張することができる</li>
<li><strong>protocol</strong> を使うことができる</li>
</ul>


<h4>クラスだけがもつ機能</h4>

<ul>
<li><strong>継承</strong></li>
<li>タイプキャストが可能</li>
<li><strong>デイニシャライザ</strong> （デストラクタ）を定義することができる</li>
<li>ひとつ以上の参照カウントが許される（構造体は copy-value、クラスは reference）</li>
</ul>


<pre><code class="swift syntax">struct Resolution {
    var width = 0
    var height = 0
}

class VideoMode {
    var resolution = Resolution()
    var interlaced = false
    var frameRate = 0.0
    var name: String?
}
let someResolution = Resolution()
let someVideoMode = VideoMode()
someVideoMode.resolution.width = 1280
</code></pre>

<p>Objective-C とは違って、参照をたどって直接値を設定することも可能。</p>

<p>構造体は、暗黙のイニシャライザを使って、プロパティを初期化することが可能。クラスはイニシャライザを明示的に定義しなければいけない。</p>

<pre><code class="swift">let rvga = Resolution(width: 640, height: 480)
</code></pre>

<h3>クラスと構造体のどちらを選ぶか</h3>

<ul>
<li>構造体を使う一番の理由は関係する値をまとめるため</li>
<li>プロパティのデータを何かしら処理する場合には、クラスの方がいいかも</li>
</ul>


<h3>Array と Dictionary</h3>

<p>Swift の Array と Dictionary は構造体の様に振舞う。</p>

<p>Dictionary は変数に割り当てられる際にコピーされる。Key/Value の Value がさらに Dictionary の場合はそれもコピーされる。</p>

<pre><code class="swift">var ages = ["Peter": 23, "Wei": 35, "Anish": 65, "Katya": 19]
var copiedAges = ages
ages["Peter"] = 24    // 24
copiedAges["Peter"]   // 23
</code></pre>

<p>Array はもうちょっと複雑な動きをする。Array の値がコピーされるのは、コピーが必要になった時に起こる。</p>

<p>変数への割り当て、メソッドの引数で渡しただけではコピーは起こらない。コピーが起こるのは、配列の長さ（<code>length</code>）が変わる処理が行ったとき。</p>

<pre><code class="swift">var nums = [10, 20, 30, 40]
var otherNums = nums

nums[0] = 50
otherNums[0]    // 50

nums += 100     // occure copy, nums is [50, 20, 30, 40, 100]
nums[0] = 10    // nums is [10, 20, 30, 40, 100]
otherNums[0]    // 50, otherNums is [50, 20, 30, 40]
</code></pre>

<p>Array で参照を切りたいときは <code>unshare()</code> メソッドを使う。変数への割り当て時に強制的にコピーしたいときは <code>copy()</code> メソッドを使う。</p>

<h2>Properties</h2>

<h3>Lazy Stored Properties</h3>

<p>最初にアクセスされるまで初期化されないようにするには、<code>@lazy</code> を使用する。変数（var）で定義するプロパティには @lazy をつけるようにするといい。</p>

<p><blockquote><p>You must always declare a lazy property as a variable (with the var keyword), because its initial value may not be retrieved until after instance initialization completes. Constant properties must always have a value before initialization completes, and therefore cannot be declared as lazy.</p><footer><strong>Lazy Stored Properties</strong></footer></blockquote></p>

<pre><code class="swift">class DataManager {
    @lazy var importer = DataImporter()   // DataImporter is assumed to take a non-trivial amount of time to initialize.
}
</code></pre>

<h3>Computed Properties</h3>

<p><code>center</code> プロパティが Computed Property になる。<code>set</code> で受け取る引数は明示してもいいし、明示しない場合は <code>newValue</code> で受け取れる。</p>

<pre><code class="swift">struct Rect {
    var origin = Point()
    var size = Size()
    var center: Point {
    get {
        let centerX = origin.x + (size.width / 2)
        let centerY = origin.y + (size.height / 2)
        return Point(x: centerX, y: centerY)
    }
    set {
        origin.x = newValue.x - (size.width / 2)
        origin.y = newValue.y - (size.height / 2)
    }
    }
}
</code></pre>

<h3>Property Observers</h3>

<p><code>willSet</code>, <code>didSet</code> を使うと、プロパティが設定されるまえ、設定された後にコールバックを受け取ることができる。これらのコールバックは初期化時にはよばれない。</p>

<pre><code class="swift">class StepCounter {
    var totalSteps: Int = 0 {
    willSet(newTotalSteps) {
        println("About to set totalSteps to \(newTotalSteps)")
    }
    didSet {
        if totalSteps &gt; oldValue  {
            println("Added \(totalSteps - oldValue) steps")
        }
    }
    }
}
let stepCounter = StepCounter()
stepCounter.totalSteps = 200
// About to set totalSteps to 200
// Added 200 steps
</code></pre>

<h2>Methods</h2>

<p>メソッドにも関数と同じく <code>externalParameterName</code> と <code>localParameterName</code> を指定できる。メソッドの場合は関数と違って、externalParameterName と localParameterName の定義の振る舞いが違う。</p>

<p>メソッドは最初の引数の externalParameterName は、localParameterName と同じになり、呼び出し時は最初の引数の externalParameterName は省略できる。</p>

<pre><code class="swift">class MyClass {
    func hello(name: String, greet: String) -&gt; String {
        return "Hello \(name) \(greet)"
    }
}

let obj = MyClass()
obj.hello("hamasyou", greet: "Good Morning")
</code></pre>

<p>第二引数以降の呼び出しで externalParameterName を指定したくない場合は <code>_</code> を使う。</p>

<pre><code class="swift">class MyClass {
    func hello(name: String, _ greet: String) -&gt; String {
        return "Hello \(name) \(greet)"
    }
}

let obj = MyClass()
obj.hello("hamasyou", "Good Night")
</code></pre>

<h3>Modifying Value Types from Within Instance Methods</h3>

<p>構造体と Enumerations はデフォルトでメソッドの中からプロパティの変更を行うことができない。変更できるようにするには <code>mutating</code> でメソッドを修飾する。</p>

<pre><code class="swift">struct Point {
    var x = 0.0, y = 0.0
    mutating func moveByX(deltaX: Double, y deltaY: Double) {
        x += deltaX
        y += deltaY
    }
}
</code></pre>

<h2>Subscripts</h2>

<p>Subscript はコレクションにアクセスするための略式を定義するもの。クラスや構造体、Enumeration に定義できる。定義すると <code>[0]</code> などでアクセスできるようになる。</p>

<p><code>subscript</code> の引数は複数指定することもできる。</p>

<pre><code class="swift">subscript(index: Int) -&gt; Int {
    get {
        // return an appropriate subscript value here
    }
    set(newValue) {
        // perform a suitable setting action here
    }
}
</code></pre>

<h2>Inheritance</h2>

<p>メソッドやプロパティのオーバーライドには <code>override</code> キーワードを使用する。override されたくないメソッドやプロパティには <code>@final</code> を指定する。</p>

<h2>Initialization</h2>

<p>イニシャライザは <code>init</code> で定義する。イニシャライザに引数を指定する場合、externalPropertyName を指定しなければ暗黙で localPropertyName が externalPropertyName に指定される。</p>

<p>メソッドと違い、<em>イニシャライザの呼び出し時には全ての externalPropertyName の指定が必要</em>。</p>

<pre><code class="swift">struct Color {
    let red = 0.0, green = 0.0, blue = 0.0
    init(red: Double, green: Double, blue: Double) {
        self.red   = red
        self.green = green
        self.blue  = blue
    }
}
let magenta = Color(red: 1.0, green: 0.0, blue: 1.0)
</code></pre>

<h3>Designated Initializers and Convenience Initializers</h3>

<p><code>Designated Initializer</code> はインスタンスの初期化の目的で定義される。<code>Convenience Initializer</code> は Designated Intitializer を呼び出す際のデフォルト値などを設定する目的で使う。</p>

<pre><code class="swift">class MyClass {
    var name: String
    init(name: String) {
        self.name = name
    }

    convenience init() {
        self.init(name: "hamasyou")
    }
}
let me = MyClass()
</code></pre>

<h2>Type Casting</h2>

<p>型チェックには <code>is</code> を使う。</p>

<pre><code class="swift">for item in library {
    if item is Movie {
        // execute movie logic
    }
}    
</code></pre>

<p>ダウンキャストに <code>as</code> が使える。Optional Type の場合は <code>as?</code> を使う。Dictionary とかから値を取り出すときに使える。</p>

<pre><code class="swift">for item in library {
    if let movie = item as? Movie {
        println("Movie: '\(movie.name)', dir. \(movie.director)")
    } else if let song = item as? Song {
        println("Song: '\(song.name)', by \(song.artist)")
    }
}
</code></pre>

<p>配列の型に <code>AnyObject</code> を使うと、利用時にキャストが必要だが何の型か指定しなくても入れれるようになる。</p>

<pre><code class="swift">let someObjects: AnyObject[] = [
    Movie(name: "2001: A Space Odyssey", director: "Stanley Kubrick"),
    Movie(name: "Moon", director: "Duncan Jones"),
    Movie(name: "Alien", director: "Ridley Scott")
]
for object in someObjects {
    let movie = object as Movie
    println("Movie: '\(movie.name)', dir. \(movie.director)")
}
</code></pre>

<p>配列の型に <code>Any</code> を使うと、なんでもいれれるようになる。</p>

<pre><code class="swift">var things = Any[]()

things.append(0)
things.append(0.0)
things.append(42)
things.append(3.14159)
things.append("hello")
things.append((3.0, 5.0))
things.append(Movie(name: "Ghostbusters", director: "Ivan Reitman"))

for thing in things {
    switch thing {
    case 0 as Int:
        println("zero as an Int")
    case 0 as Double:
        println("zero as a Double")
    case let someInt as Int:
        println("an integer value of \(someInt)")
    case let someDouble as Double where someDouble &gt; 0:
        println("a positive double value of \(someDouble)")
    case is Double:
        println("some other double value that I don't want to print")
    case let someString as String:
        println("a string value of \"\(someString)\"")
    case let (x, y) as (Double, Double):
        println("an (x, y) point at \(x), \(y)")
    case let movie as Movie:
        println("a movie called '\(movie.name)', dir. \(movie.director)")
    default:
        println("something else")
    }
}
</code></pre>

<h2>Extensions</h2>

<p>既存のクラス、構造体、Enumeration に機能を追加できる。</p>

<pre><code class="swift">extension SomeType: SomeProtocol, AnotherProtocol {
    // implementation of protocol requirements goes here
}

extension Double {
    var km: Double { return self * 1_000.0 }
    var m: Double { return self }
    var cm: Double { return self / 100.0 }
    var mm: Double { return self / 1_000.0 }
    var ft: Double { return self / 3.28084 }
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Titanium] Alloyのmeasurementの実装がイケてなかったので再実装した]]></title>
    <link href="http://hamasyou.com/blog/2014/04/02/titanium-alloy-measurement/"/>
    <updated>2014-04-02T18:17:44+09:00</updated>
    <id>http://hamasyou.com/blog/2014/04/02/titanium-alloy-measurement</id>
    <content type="html"><![CDATA[<p><a href="http://www.appcelerator.com/titanium/">Titanium</a> Alloy の <code>measurement</code> がイケてない感じだったので再実装しました。</p>

<p><code>measurement</code> には <code>pxToDP</code> とか <code>dpToPX</code> とかの単位を変換するメソッドが用意されていますが、中身を見るとびっくりします。。</p>

<!-- more -->


<pre><code class="javascript alloy/measurement.js (alloy 1.3.1)">var dpi = Ti.Platform.displayCaps.dpi, density = Ti.Platform.displayCaps.density;

exports.dpToPX = function(val) {
    return val * ("high" === density ? 2 : 1);
};

exports.pxToDP = function(val) {
    return val / ("high" === density ? 2 : 1);
};

exports.pointPXToDP = function(pt) {
    return {
        x: exports.pxToDP(pt.x),
        y: exports.pxToDP(pt.y)
    };
};
</code></pre>

<p>これ、イケてなさすぎでしょ。。</p>

<p><code>Ti.UI.convertUnits</code> を使って次のように実装しなおしました。</p>

<pre><code class="javascript lib/unit.js">var currentUnit = Ti.App.Properties.getString('ti.ui.defaultunit', 'system');
currentUnit = (currentUnit === 'system') ? (OS_IOS) ? Ti.UI.UNIT_DIP : Ti.UI.UNIT_PX : currentUnit;

function convert(val, fromUnit, toUnit) {
    return Ti.UI.convertUnits('' + parseInt(val) + fromUnit, toUnit);
}

module.exports = exports = {
    dpToPX: function(val) {
        return convert(val, Ti.UI.UNIT_DIP, Ti.UI.UNIT_PX);
    },
    dpToSystem: function(val) {
        return convert(val, Ti.UI.UNIT_DIP, currentUnit);
    },
    pxToDP: function(val) {
        return convert(val, Ti.UI.UNIT_PX, Ti.UI.UNIT_DIP);
    },
    pxToSystem: function(val) {
        return convert(val, Ti.UI.UNIT_PX, currentUnit);
    },
    systemToPX: function(val) {
        return convert(val, currentUnit, Ti.UI.UNIT_PX);
    },
    systemToDP: function(val) {
        return convert(val, currentUnit, Ti.UI.UNIT_DIP);
    },
    convertUnitToPX: function(valStr) {
        return Ti.UI.convertUnits(valStr, Ti.UI.UNIT_PX);
    },
    convertUnitToDP: function(valStr) {
        return Ti.UI.convertUnits(valStr, Ti.UI.UNIT_DIP);
    },
    convertUnitToSystem: function(valStr) {
        return Ti.UI.convertUnits(valStr, currentUnit);
    },
    pointPXToDP: function(pt) {
        return {
            x: this.pxToDP(pt.x),
            y: this.pxToDP(pt.y)
        };
    }
};
</code></pre>

<p>使い方と結果はこちら。</p>

<pre><code class="javascript sample.js">var unit = require('unit');
console.log('----- iOS -----');
Ti.API.info('Ti.Platform.displayCaps.density: ' + Ti.Platform.displayCaps.density);
Ti.API.info('Ti.Platform.displayCaps.dpi: ' + Ti.Platform.displayCaps.dpi);
Ti.API.info('Ti.Platform.displayCaps.platformHeight: ' + Ti.Platform.displayCaps.platformHeight);
Ti.API.info('Ti.Platform.displayCaps.platformWidth: ' + Ti.Platform.displayCaps.platformWidth);
if (Ti.Platform.osname === 'android'){
  Ti.API.info('Ti.Platform.displayCaps.xdpi: ' + Ti.Platform.displayCaps.xdpi);
  Ti.API.info('Ti.Platform.displayCaps.ydpi: ' + Ti.Platform.displayCaps.ydpi);
  Ti.API.info('Ti.Platform.displayCaps.logicalDensityFactor: ' + Ti.Platform.displayCaps.logicalDensityFactor);
}
console.log('dpToPX: ' + unit.dpToPX(130));
console.log('dpToSystem: ' + unit.dpToSystem(130));
console.log('pxToDP: ' + unit.pxToDP(130));
console.log('pxToSystem: ' + unit.pxToSystem(130));
console.log('systemToPX: ' + unit.systemToPX(130));
console.log('systemToDP: ' + unit.systemToDP(130));
console.log('convertUnitToPX: ' + unit.convertUnitToPX('130dp'));
console.log('convertUnitToDP: ' + unit.convertUnitToDP('130dp'));
console.log('convertUnitToSystem: ' + unit.convertUnitToSystem('130dp'));
console.log('-----');
</code></pre>

<p><div class="terminal-window">
          <nav class="terminal-control-window">
            <a href="#" class="terminal-close" data-rel="close">close</a>
            <a href="#" class="terminal-minimize">minimize</a>
            <a href="#" class="terminal-deactivate">deactivate</a>
          </nav>
          <h1 class="terminal-title">Terminal</h1>
          <div class="terminal-container"><div class="terminal"><table><tr><td class='gutter'><pre class='line-numbers'><span class='line-number'>&nbsp;</span>
<span class='line-number'>&nbsp;</span>
<span class='line-number'>&nbsp;</span>
<span class='line-number'>&nbsp;</span>
<span class='line-number'>&nbsp;</span>
<span class='line-number'>&nbsp;</span>
<span class='line-number'>&nbsp;</span>
<span class='line-number'>&nbsp;</span>
<span class='line-number'>&nbsp;</span>
<span class='line-number'>&nbsp;</span>
<span class='line-number'>&nbsp;</span>
<span class='line-number'>&nbsp;</span>
<span class='line-number'>&nbsp;</span>
<span class='line-number'>&nbsp;</span>
<span class='line-number'>&nbsp;</span>
<span class='line-number'>&nbsp;</span>
<span class='line-number'>&nbsp;</span>
<span class='line-number'>&nbsp;</span>
<span class='line-number'>&nbsp;</span>
<span class='line-number'>&nbsp;</span>
<span class='line-number'>&nbsp;</span>
<span class='line-number'>&nbsp;</span>
<span class='line-number'>&nbsp;</span>
<span class='line-number'>&nbsp;</span>
<span class='line-number'>&nbsp;</span>
<span class='line-number'>&nbsp;</span>
<span class='line-number'>&nbsp;</span>
<span class='line-number'>&nbsp;</span>
<span class='line-number'>&nbsp;</span>
<span class='line-number'>&nbsp;</span>
<span class='line-number'>&nbsp;</span>
<span class='line-number'>&nbsp;</span>
<span class='line-number'>&nbsp;</span>
<span class='line-number'>&nbsp;</span></pre></td><td class='code'><pre><code><span class='line output'>[INFO] :   &mdash;&ndash; iPhone OS &mdash;&ndash;
</span><span class='line output'>[INFO] :   Ti.Platform.displayCaps.density: high
</span><span class='line output'>[INFO] :   Ti.Platform.displayCaps.dpi: 320
</span><span class='line output'>[INFO] :   Ti.Platform.displayCaps.platformHeight: 568
</span><span class='line output'>[INFO] :   Ti.Platform.displayCaps.platformWidth: 320
</span><span class='line output'>[INFO] :   dpToPX: 260
</span><span class='line output'>[INFO] :   dpToSystem: 130
</span><span class='line output'>[INFO] :   pxToDP: 65
</span><span class='line output'>[INFO] :   pxToSystem: 65
</span><span class='line output'>[INFO] :   systemToPX: 260
</span><span class='line output'>[INFO] :   systemToDP: 130
</span><span class='line output'>[INFO] :   convertUnitToPX: 260
</span><span class='line output'>[INFO] :   convertUnitToDP: 130
</span><span class='line output'>[INFO] :   convertUnitToSystem: 130
</span><span class='line output'>[INFO] :   &mdash;&ndash;</p>
</span><span class='line output'>
</span><span class='line output'><p>[INFO] :   &mdash;&ndash; android &mdash;&ndash;
</span><span class='line output'>[INFO] :   Ti.Platform.displayCaps.density: xhigh
</span><span class='line output'>[INFO] :   Ti.Platform.displayCaps.dpi: 320
</span><span class='line output'>[INFO] :   Ti.Platform.displayCaps.platformHeight: 1280
</span><span class='line output'>[INFO] :   Ti.Platform.displayCaps.platformWidth: 720
</span><span class='line output'>[INFO] :   Ti.Platform.displayCaps.xdpi: 345.0566101074219
</span><span class='line output'>[INFO] :   Ti.Platform.displayCaps.ydpi: 342.2315673828125
</span><span class='line output'>[INFO] :   Ti.Platform.displayCaps.logicalDensityFactor: 2
</span><span class='line output'>[INFO] :   dpToPX: 260
</span><span class='line output'>[INFO] :   dpToSystem: 260
</span><span class='line output'>[INFO] :   pxToDP: 65
</span><span class='line output'>[INFO] :   pxToSystem: 130
</span><span class='line output'>[INFO] :   systemToPX: 130
</span><span class='line output'>[INFO] :   systemToDP: 65
</span><span class='line output'>[INFO] :   convertUnitToPX: 260
</span><span class='line output'>[INFO] :   convertUnitToDP: 130
</span><span class='line output'>[INFO] :   convertUnitToSystem: 260
</span><span class='line output'>[INFO] :   &mdash;&ndash;</span></code></pre></td></tr></table></div></div>
        </div></p>

<p>ご利用は計画的に。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[サーバサイドJavaScript Node.js入門]]></title>
    <link href="http://hamasyou.com/blog/2014/03/04/4048703676/"/>
    <updated>2014-03-04T23:24:06+09:00</updated>
    <id>http://hamasyou.com/blog/2014/03/04/4048703676</id>
    <content type="html"><![CDATA[<p>本書は、「<strong>Node</strong> って何？」という人から「Node の中身はどうなっているの？」を知りたい人のために幅広く網羅的に書かれています。</p>

<ol>
<li>Node の基本から順番に理解していきたい</li>
<li>Node を使ってすぐに Web アプリケーションを作ってみたい</li>
<li>Node の内部構造を理解したい</li>
</ol>


<p>これらのモデルケースに合う人にオススメの書籍です。</p>

<!-- more -->


<h1>おぼえがき</h1>

<h2>Node とはなにか？</h2>

<p><em>Node はプログラミング言語ではありません</em>。言語としては <strong>JavaScript</strong> を使います。
<em>Node は JavaScript ライブラリではありませんし、アプリケーションフレームワークでもありません</em>。</p>

<p>Node はスケーラビリティに優れた、Web アプリケーションを実行するためのサーバサイドのプラットフォームです。
特徴は、I/O 処理が非同期で行われプラットフォーム自体がサーバ機能を提供する方式であることです。</p>

<p>JavaScript で実現されたイベントループと非同期処理の仕組み、<strong>WebSocket</strong> との相性の良さ、V8 エンジン搭載などの技術的に優れた部分を持ち合わせています。
<em>Node は、従来の同期処理から決別し、ライブラリを含めてスレッドをブロックすることのない世界を作り上げました</em>。</p>

<h3>JavaScript である理由</h3>

<p>JavaScript ではスレッドライブラリが定義されておらず、多くの実装はシングルスレッドで動作します。また、イベントの仕組みをうまくつかって非同期処理を行います。
Node の世界にマッチさせるライブラリは非同期で動作しなければなりませんが、サーバサイドで JavaScript は今までほとんど使われてこなかったため、
サーバサイドのライブラリはゼロから作り上げる必要がありました。つまり、<em>過去の資産を気にすることなく非同期かつスレッドをブロックしない I/O を利用させることが可能でした</em>。</p>

<p>近年爆発的にユーザ数が増えると、<strong>C10K</strong> という問題が起こることがクローズアップされ始めました。
従来のアーキテクチャは、クライアントのアクセスに対して一つのスレッドを割り当てるマルチスレッドモデルで同時アクセスをさばいていました。
しかし、これではユーザ数が増えた際にスレッドを大量に生成しなければならず、この部分がボトルネックになるようになりました。</p>

<p>そこで、マルチスレッドモデルに対して、<strong>シングルスレッド+イベントループ</strong> により複数のクライアントをさばくというモデルがではじめました。
JavaScript はシングルスレッドモデルですし、イベントループの仕組みを使って非同期処理を行うようになっています。この C10K 問題に対する解として JavaScript はうってつけだったのです。</p>

<h3>Node とリアルタイムアプリケーション</h3>

<p>HTML5 が世に広まり始めると、その仕様の一部として策定されていた <strong>WebSocket</strong> プロトコルが注目されるようになってきました。（現在では HTML5 とは独立した仕様になっています。）</p>

<p>WebSocket は HTTP 通信とは異なり、接続を維持したまま通信することが前提のプロトコルです。接続確立時には HTTP をつかいますが、その後の通信では独自のプロトコルを使います。
そのため、WebSocket でリアルタイム通信を行おうとするとサーバ側も対応しなければならず、大掛かりになりがちでした。</p>

<p>Node はプログラム内にサーバ機能を実装可能であるという特徴から、WebSocket 用のモジュールが用意されました。
これらのモジュールを使うことで簡単に WebSocket を利用したアプリケーションが構築できるようになりました。</p>

<p>こうして、リアルタイム通信を行うなら Node という方程式が出来上がったのです。</p>

<h3>Node のプログラム</h3>

<p>Node はイベントループが回ることですべての処理をさばきます。Node のプログラムは <strong>必要なイベントハンドラを登録し、適切なタイミングでイベントを発生させる</strong> ことで成立しています。
これは、ブラウザ上の JavaScript とほとんど同じプログラムコードになります。</p>

<h2>モジュール</h2>

<p>Node のモジュールは JavaScript で記述されたファイルか、アドオンと呼ばれる C/C++ で記述されコンパイルされたファイルで構成されます。</p>

<p>Node では <strong>1つのファイルは必ず1つのモジュールに対応します</strong>。
あるファイルをモジュールとして利用可能にするには <code>module</code> オブジェクトか <code>exports</code> オブジェクトを使って必要な関数、オブジェクトを公開します。</p>

<pre><code class="javascript">module.exports = {
  funcA: function() {
  }
};

function funcB() {
}
module.exports.funcB = funcB;

// exports を外部公開オブジェクトとして定義する場合は慣例として次のように書く
module.exports = exports = {
  foo: 'bar',
  funcA: function() {
  }
};
</code></pre>

<h2>感想</h2>

<p>Node とはなにか？Node の仕組みを知りたい、Node を始めたいという人向けのタイトル通りの「入門」書だと思いました。
実際に使われているモジュールやフレームワークの説明なども入っているので、コレ一冊でとりあえず Node を始められるようになっています。
ここから始めて見て、壁にあたったら次の参考書を読んでみるという感じがいいんじゃないかと思います。</p>

<p>内容としては、プログラミング知識がある人（とくに JavaScript）なら、優しすぎず難しすぎずという感じです。</p>

<h2>目次</h2>

<ol>
<li>Node とは何か

<ol>
<li>非同期プログラミング</li>
<li>なぜ従来から非同期プログラミングが行われてこなかったのか</li>
<li>Node の誕生と既存の言語</li>
<li>JavaScript である理由</li>
<li>シングルスレッドの強み</li>
<li>Node とリアルタイムアプリケーション</li>
</ol>
</li>
<li>インストール

<ol>
<li>OS ごとのインストール方法</li>
<li>環境構築ツールを使う</li>
<li>npm を使ったパッケージのインストール</li>
</ol>
</li>
<li>開発環境

<ol>
<li>エディタ</li>
<li>IDE</li>
</ol>
</li>
<li>Node入門

<ol>
<li>Node コマンド</li>
<li>イベントループ</li>
<li>HTTP サーバ</li>
<li>イベントループの落とし穴</li>
<li>まとめ</li>
</ol>
</li>
<li>モジュール

<ol>
<li>モジュールの作り方</li>
<li>モジュールの使い方</li>
<li>モジュール活用</li>
</ol>
</li>
<li>イベント

<ol>
<li>Node とイベント駆動プログラミング</li>
<li>イベントの作成と利用</li>
<li>リスナ配列</li>
<li>特殊なイベント</li>
<li>シグナルとイベント</li>
<li>まとめ</li>
</ol>
</li>
<li>イベントループとprocess.nextTick()

<ol>
<li>Node のイベントループの仕組み</li>
<li>非同期イベントの生成</li>
<li>非同期コールバックの呼び出し</li>
</ol>
</li>
<li>ストリーム、バッファ、ファイルシステム

<ol>
<li>ストリーム</li>
<li>Buffer</li>
<li>ファイルシステム</li>
</ol>
</li>
<li>ソケット（TCP/UDP）

<ol>
<li>net モジュール</li>
<li>TCP サーバの概要</li>
<li>TCP クライアントの概要</li>
<li>TCP エコーサーバ・クライアントの実装</li>
<li>TCP と同期プロトコル</li>
<li>drain イベントを利用したデータ送信制御</li>
<li>TLS 通信の利用</li>
<li>OS のTCP 機能と直接関わるAPI</li>
<li>dgram モジュール</li>
</ol>
</li>
<li>HTTP/HTTPS

<ol>
<li>http モジュール</li>
<li>http.Server のエコーサーバの実装</li>
<li>HTTP RESTful サーバの実装</li>
<li>HTTP クライアントの概要</li>
<li>https モジュール</li>
<li>url モジュール</li>
<li>querystring モジュール</li>
</ol>
</li>
<li>Domain

<ol>
<li>domain モジュールの概要</li>
<li>domain モジュールのクラス</li>
<li>ドメインへのオブジェクトと関数の結びつけ</li>
<li>Implicit Binding</li>
<li>Explicit Binding</li>
<li>ドメインを利用したエラーページの表示</li>
</ol>
</li>
<li>ユニットテスト

<ol>
<li>はじめに</li>
<li>assert</li>
<li>should</li>
<li>chai</li>
<li>mocha</li>
<li>vows</li>
</ol>
</li>
<li>デバッグ

<ol>
<li>デバッガの基本機能</li>
<li>組み込みデバッガを利用したCUI でのデバッグ</li>
<li>Node Inspector を利用したGUI でのデバッグ</li>
<li>組み込みデバッガとNode Inspector の使い分け</li>
<li>IDE でのデバッグ</li>
<li>その他のサードパーティのデバッグモジュール</li>
</ol>
</li>
<li>実践編導入

<ol>
<li>実践編で扱う技術について</li>
<li>共通して扱うモジュール</li>
</ol>
</li>
<li>Express入門

<ol>
<li>はじめに</li>
<li>Express の導入</li>
<li>Connect のアーキテクチャ</li>
<li>Express のアーキテクチャ</li>
</ol>
</li>
<li>Express を用いたフォーラムアプリケーションの作成

<ol>
<li>はじめに</li>
<li>ルーティング</li>
<li>データの永続化</li>
<li>その他のリクエストメソッド</li>
<li>ビューの改善</li>
<li>エラー処理</li>
<li>ミドルウェア</li>
<li>ユーザー登録とログインの実装</li>
<li>セッション</li>
<li>ルートミドルウェア</li>
<li>remember me の実装</li>
<li>Tips</li>
<li>終わりに</li>
</ol>
</li>
<li>Socket.IO を使ったファイル共有アプリケーションの作成

<ol>
<li>はじめに</li>
<li>準備</li>
<li>ユーザー名の指定</li>
<li>チャンネルの実装</li>
<li>ファイルの送信</li>
<li>ファイルの受信</li>
<li>ファイルの永続化</li>
<li>ファイルの配信</li>
<li>終わりに</li>
</ol>
</li>
<li>外部API との連携

<ol>
<li>ハッシュタグストリーミング</li>
<li>今一緒にいる人を一括フォロー</li>
<li>終わりに</li>
</ol>
</li>
<li>Node はどう作られているか

<ol>
<li>JavaScript とNode</li>
<li>C10K とNode</li>
<li>Web アプリケーションアーキテクチャとしてのNode</li>
</ol>
</li>
<li>非同期プログラミングの改善

<ol>
<li>はじめに</li>
<li>コールバック関数の問題</li>
<li>コールバック関数の改善</li>
<li>まとめ</li>
</ol>
</li>
<li>アドオンの作成

<ol>
<li>概要</li>
<li>シンプルなHelloWorld のサンプル（オブジェクトの作成）</li>
<li>メソッドを持つアドオンのサンプル</li>
</ol>
</li>
<li>npm パッケージ

<ol>
<li>チュートリアル</li>
<li>パッケージの公開</li>
<li>パッケージの詳細</li>
<li>まとめ</li>
</ol>
</li>
<li>スケーラビリティ

<ol>
<li>複数プロセスの起動</li>
<li>複数サーバでのスケールアウト</li>
<li>終わりに</li>
</ol>
</li>
<li>運用

<ol>
<li>Apache やNginx との連携</li>
<li>環境</li>
</ol>
</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Pythonメモ]]></title>
    <link href="http://hamasyou.com/blog/2014/02/25/python/"/>
    <updated>2014-02-25T15:43:02+09:00</updated>
    <id>http://hamasyou.com/blog/2014/02/25/python</id>
    <content type="html"><![CDATA[<p>プログラミング言語「<strong>Python</strong>」のメモです。v.2.5 のメモのなので最新だと違うかも。。</p>

<iframe src="http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&bc1=FAFAFA&IS2=1&bg1=FAFAFA&fc1=666666&lc1=3399F3&t=sorehabooks-22&o=9&p=8&l=as1&m=amazon&f=ifr&ref=tf_til&asins=4873113938" style="width:120px;height:240px;" scrolling="no" marginwidth="0" marginheight="0" frameborder="0"></iframe>




<!-- more -->


<h3>シーケンス</h3>

<p>シーケンスとは、オブジェクトを一定の順序に並べたものです。シーケンスでは要素となるオブジェクトの順序は常に変わりません。シーケンスには、<em>文字列</em>、<em>リスト</em>、<em>タプル</em> などがあります。</p>

<p>シーケンスに対して行える操作があります。要素の位置を指定して取り出す <strong>インデクシング</strong>、要素を範囲で取得する <strong>スライシング</strong> があります。</p>

<pre><code class="python">str = 'Spam'
str[0]   # S
str[-1]  # m
str[1:3] # pa
str[1:]  # pam
str[:3]  # Spa
str[:-1] # Spa
str[:]   # Spam

str = 'abcdefghij'
str[1:9:2]  # bdfh
str[5:1:-1] # fedc
str[::-1]   # jihgfedcba

len('abc')      # 3
len([1,2,3,4])  # 4
</code></pre>

<h3>リスト内包表記</h3>

<p>リスト内包表記はシーケンスに属する要素のそれぞれに同じ演算を行うことができる表記法です。リスト内包表記は最終的にリストを作成します。</p>

<pre><code class="python">matrix = [[1, 2, 3],
          [4, 5, 6],
          [7, 8, 9]]
col2 = [row[1] for row in matrix]
col2
# [2, 5, 8]
</code></pre>

<h3>タプル</h3>

<p><strong>タプル</strong> はリストと似ていますが、要素を変更することができません。タプルはカッコで作成します。<em>要素が一つの場合は、要素の後にカンマをつけなければいけません</em>。
タプルは <em>オブジェクトの集合</em>、リストは <em>データ構造</em> と使い分けをするらしいです。</p>

<pre><code class="python">tuple = (1, 2, 3, 4)
tuple[1] = 5
# TypeError: 'tuple' object does not support item assignment
tuple = (1,)
</code></pre>

<h3>ヘルプを調べる</h3>

<p>組み込み関数の <code>dir</code> を使うと、オブジェクトの全属性のリストが手に入ります。また、<code>help</code> 関数を使うとメソッドのヘルプ情報を出力可能です。</p>

<pre><code class="python">dir('string')
# ['__add__', '__class__', '__contains__', '__delattr__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__getnewargs__', '__getslice__', '__gt__', '__hash__', '__init__', '__le__', '__len__', '__lt__', '__mod__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__rmod__', '__rmul__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '_formatter_field_name_split', '_formatter_parser', 'capitalize', 'center', 'count', 'decode', 'encode', 'endswith', 'expandtabs', 'find', 'format', 'index', 'isalnum', 'isalpha', 'isdigit', 'islower', 'isspace', 'istitle', 'isupper', 'join', 'ljust', 'lower', 'lstrip', 'partition', 'replace', 'rfind', 'rindex', 'rjust', 'rpartition', 'rsplit', 'rstrip', 'split', 'splitlines', 'startswith', 'strip', 'swapcase', 'title', 'translate', 'upper', 'zfill']
help('string'.index)
# Help on built-in function index:
#
# index(...)
#     S.index(sub [,start [,end]]) -&gt; int
#
#     Like S.find() but raise ValueError when the substring is not found.
</code></pre>

<h3>文字列</h3>

<p><em>Python ではシングルクォートとダブルクォートは同じ意味を持ちます</em>。なので、他の言語のように、ダブルクォートの場合だけエスケープシーケンスが効くということはありません。</p>

<pre><code class="python">print 'a\nb\tc'
# a
# b c
</code></pre>

<h3>リスト操作</h3>

<p>Python のリストは <code>[]</code> を使って作ります。他の言語の配列操作と同じ処理は基本的にできます。Python 特有の操作だなと思ったものだけメモ。</p>

<pre><code class="python">a = [1, 2, 3, 4, 5]

# 特定の要素が含まれているかどうかの確認
3 in a  # =&gt; True
6 in a  # =&gt; False

# リスト内包表記
[x**2 for x in a] # =&gt; [1, 4, 9, 16, 25]
</code></pre>

<h3>ステートメント、構文に関する注意点</h3>

<h4>コロンを忘れない</h4>

<p>複合ステートメント（if、while、for などの最初の行）の末尾にはかならず <code>:</code> をつけます。</p>

<h4>トップレベルのコードはインデントしない</h4>

<p>トップレベルコードはかならず左端から書き始めます。</p>

<h4><code>while</code> や <code>range</code> よりも、単純な <code>for</code> を使う</h4>

<p>シーケンスを扱う場合は、できるだけ単純な <code>for</code> （<code>for x in seq:</code>）を使うようにします。</p>

<h4>オブジェクトの上書きを行う関数は値を返さない</h4>

<p><code>list.append</code> や <code>list.sort</code> などのオブジェクトを上書きするような関数は値を戻しません。<code>None</code> を返すようにします。</p>

<h3>変数のスコープ</h3>

<p>Python の変数のスコープは、「ローカルスコープ」「グローバルスコープ」「ビルトインスコープ」があります。
関数内で定義された変数は「ローカルスコープ」に所属します。</p>

<p>関数の引数で渡された変数は参照渡しになります。変数の代入では元のオブジェクトは変更されませんが、オブジェクトの上書きは影響を及ぼします。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[サードパーティJavaScript]]></title>
    <link href="http://hamasyou.com/blog/2014/02/23/third-party-javascript/"/>
    <updated>2014-02-23T17:47:39+09:00</updated>
    <id>http://hamasyou.com/blog/2014/02/23/third-party-javascript</id>
    <content type="html"><![CDATA[<p>サードパーティ JavaScript とは <em>異なる Web アドレスから配信される、独立したクライアントコード</em> のことを意味します。
例えばソーシャルウィジェットやアナリティクス用のトラッカーがそうです。
本書はこのサードパーティ JavaScript をどのように開発するとよいかについて書かれています。</p>

<p>サードパーティ JavaScript には様々な難しいポイントがあります。</p>

<ul>
<li>動的なスクリプト読み込み</li>
<li>サードパーティ Cookie の保存と読み込み</li>
<li>HTTP / HTTPS を使ったサーバとの通信</li>
</ul>


<p>多くの人に使われる JavaScript を開発するには、<strong>数多くの落とし穴や難関を乗り越えなければなりません</strong>。
本書はこういった落とし穴や難関に対する解決策を手順を追って説明してくれます。</p>

<p>本書の著者の一人は <a href="http://disqus.com/">Disqus</a> という Web サイトに即席のコメントシステムを導入することができる JavaScript アプリケーションを開発しています。
実際に世界中で使われているアプリケーションの経験を元に書かれているので説得力がありますし、「こんな事にも注意しないといけなかったのか！」といった目からウロコな内容も盛りだくさんでおすすめです。</p>

<p>本書を読み終わると「<span class="lead"><strong>IE 無くなったらいいのに！</strong></span>」って絶対に思います。そして「<span class="lead"><strong>iframe すげーな。使えるやつだ</strong></span>」って思います（笑</p>

<!-- more -->


<p>以下、おぼえがきとメモです。</p>

<p><nav id="toc" role="navigation"></nav></p>

<h2>サードパーティ JavaScript 入門</h2>

<p>サードパーティ JavaScript の例には次のようなものがあります。</p>

<ul>
<li>埋め込みウィジェット</li>
<li>分析と計測</li>
<li>Web サービス API のラッパー</li>
</ul>


<h3>サードパーティ JavaScript 開発が難しい理由</h3>

<h4>未知のコンテキスト</h4>

<p>JavaScript が読み込まれたときに、読み込まれた先（パブリッシャ）のページの環境がどのようになっているかがわかりません。
JavaScript の読み込まれる位置が <code>&lt;head&gt;</code> タグだったり、<code>&lt;body&gt;</code> タグの一番最後かもしれません。<code>&lt;head&gt;</code> タグがない可能性もあります。
<strong>ブラウザに依存するような状況に依存したコードは書くべきではありません</strong>。</p>

<p>ウィジェットを開発しているのであれば、正しく表示されるかも問題になります。
表示されるページの CSS に干渉してしまうようなスタイルの定義も問題になります。</p>

<p>共通して言えることは、サードパーティ JavaScript は外部の環境に依存するべきではないし、<strong>外部の環境を壊すようなことはあってはならない</strong> ということです。</p>

<h4>共有されている JavaScript 環境</h4>

<p>Web 環境では、JavaScript が実行される環境はグローバルな環境が一つしかありません。グローバル環境を汚さないようにしなければいけませんし、他の JavaScript に壊されることがないように防衛する必要もあります。</p>

<h4>ブラウザによるクロスドメイン制限</h4>

<p>ブラウザの同一生成元ポリシーによって、<code>XmlHttpRequest</code> は表示しているページと異なるドメインへアクセスするのを妨げられてしまいます。また、サードパーティ Cookie の保存や読み込みも制限していることが普通です。</p>

<h2>開発の足場</h2>

<h3>複数のドメインをシミュレートする開発環境</h3>

<p>クロスドメインの問題はかなり厄介な問題ですので、開発時点から複数ドメインをシミュレートするのは役にたちます。
OS の <code>hosts</code> ファイルを編集して、localhost の エイリアスを二つ用意するだけでこの環境が手に入ります。</p>

<pre><code class="plain-raw hosts">127.0.0.1 publisher.dev
127.0.0.1 widget.dev
</code></pre>

<p><em>「.dev」のような存在しないトップレベルドメインを使う方が、実際に存在する Web サイトのアドレスを差してしまう問題がないので便利</em> です。</p>

<h3>スクリプトを読み込むスニペット</h3>

<p>パブリッシャのページに最初のスクリプトを読み込むスニペットを用意します。スニペットを提供する方法は2つあります。</p>

<ul>
<li>「ブロッキング」を行うタイプの <code>script</code> タグによる読み込み</li>
<li>非同期でスクリプトを読み込むタイプ</li>
</ul>


<h4>ブロッキング読み込み</h4>

<p>```html</p>

<script src="http://camerastock.com/widget.js?product=1234"></script>


<pre><code>
#### ノンブロッキング読み込み

上のようなタグは、そのスクリプトが読み込まれるまでブラウザの処理をとめてしまいます。そのため、このようなスクリプトは `&lt;body&gt;` タグの最後におくことや、`defer` 属性、`async` 属性を使うことで回避できます。
`defer` 属性、`async` 属性をスクリプトタグに指定することで、そのスクリプトが文書のコンテンツを生成しない（`document.write` を使わない）のでページブロッキングをしなくても完全にダウンロードが可能であるとブラウザに伝えることができます。
</code></pre>

<script defer src="http://camerastock.com/widget.js?product=1234"></script>


<script async src="http://camerastock.com/widget.js?product=1234"></script>


<pre><code>
defer 属性
: `defer` 属性が指定されたスクリプトは、**ページが完全に解析された後** に実行が開始されます。
async 属性
: `async` 属性が指定されたスクリプトは、**ダウンロードが完了したすぐ直後** から実行が開始されます。

JavaScript を使って DOM 上に `script` 要素を動的に生成することでも、`async` 属性と同じ挙動でスクリプトを読み込ませることができます。
</code></pre>

<script>
(function() {
  var node     = document.getElementsByTagName('script')[0],
      script   = document.createElement('script');

  script.src   = 'http://camerastock.com/widget.js?product=1234';
  script.async = true;
  node.parentNode.insertBefore(script, node);
})();
</script>


<pre><code>
### 最初のスクリプトファイル

最初の JavaScript ファイルの中身はこんな感じになります。
</code></pre>

<p>var Stork = (function(window, undefined) {
  var Stork = {};</p>

<p>  return Stork;
})(window);
```</p>

<p>一番外側の <code>Stork</code> はアプリケーションをカプセル化するための名前空間オブジェクトです。<code>window</code> と <code>undefined</code> を引数に取っています。これは、<em>よく使う変数をローカル変数として定義することで、JavaScript のミニファイアが働くようになり変数名を短くすることができる</em> からです。
また、<code>undefined</code> はオリジナルの <code>undefined</code> が他の環境によって書き換えられていても問題ないようにするためのテクニックになります。この二つは、<em>JavaScript ライブラリの作者が非常によく使うテクニック</em> になります。</p>

<h3>loadScript 関数</h3>

<p>外部の JavaScript ライブラリを使いたい場合は、パブリッシャにそのスクリプトを読み込んでもらうようにするのはナンセンスです。
パブリッシャに依存ライブラリを追加してもらうのでは、依存ライブラリに変更が入った際にパブリッシャに変更を依頼しなければならなくなります。</p>

<p><em>サードパーティ JavaScript の開発者は依存ライブラリは外部に依存しない形で利用するようにするのが求められます</em>。次のコードは非同期の JavaScript ローダ関数です。必要なスクリプトの読み込みが完了したら、引数の <code>callback</code> 関数を呼び出します。</p>

<pre><code class="javascript">function loadScript(url, callback) {
  var node   = document.getElementsByTagName('script')[0],
      script = document.createElement('script');

  script.src   = url;
  script.async = true;
  node.parentNode.insertBefore(script, node);

  script.onload = script.onreadystatechange = function() {
    var readyState = script.readyState;

    if (!readyState || /complete|loaded/.test(script.readyState)) {
      callback();
      script.onload = script.onreadystatechange = null;
    }
  };
}
</code></pre>

<p>このように、必要なライブラリは、アプリケーションが実行する前に読み込んでおくようにします。</p>

<h4>ライブラリの衝突に注意</h4>

<p>jQuery のようなよく使われるライブラリをこの方法で読み込む際には、すでに存在するオブジェクトと衝突しないように注意しなければなりません。
衝突を防ぐには <strong>名前空間</strong> を使います。jQuery の場合には衝突を避ける <code>noConflict</code> が用意されているので、これを使います。</p>

<pre><code class="javascript">var Stork = Stork || {};
Stork.$ = Stork.jQuery = jQuery.noConflict(true);
</code></pre>

<p>外部ライブラリを使う場合には、既に読み込まれていても衝突しないように注意する必要があります。</p>

<h2>HTML と CSS のレンダリング</h2>

<h3>スタイルを調整する方法</h3>

<p>HTML にスタイルを追加で当てる方法には3つの基本的な方法が考えられます。</p>

<ol>
<li>HTML にインラインでスタイルを当てる</li>
<li>関連する CSS ファイルを別途動的に読み込む</li>
<li>JavaScript にスタイルシートのルールを埋め込む</li>
</ol>


<h4>1. インラインスタイル</h4>

<p>インラインスタイルは他の要素のスタイルと干渉する心配がありません。デメリットは一般の Web サイトでインラインスタイルを使うべきでない理由と同じになります。</p>

<h4>2. CSS ファイルをロードする</h4>

<p>CSS ファイルを動的にロードする方法は、JavaScript を動的にロードする方法とほとんど同じになります。</p>

<pre><code class="javascript">function loadStylesheet(url) {
  var node = document.getElementsByTagName('script')[0],
      link = document.createElement('link');
  link.rel  = 'stylesheet';
  link.type = 'text/css';
  link.href = url;

  node.parentNode.insertBefore(link, node);
}
</code></pre>

<p><code>link</code> タグは <code>rel</code> 属性と <code>type</code> 属性はどちらも必須の属性になります。
CSS が読み込まれたタイミングを知りたい場合には、少し変わった方法が必要になります。ブラウザによっては、<code>link</code> タグは <code>script</code> タグのように読み込みが終わったタイミングで <code>load</code> イベントを発生させない場合があるからです。
CSS が読み込まれたかどうかをチェックするには、要素にスタイルが当たったかどうかを定期的にチェックする必要があります。</p>

<p><blockquote><p>JavaScript やその他のデータを読み込むためのライブラリである Yepnope.js では、document.styleSheets を使って新しく挿入されたスタイルシートをスキャンする方法をとっている。</p></blockquote></p>

<h5>JavaScript で要素の色を調べるときは注意！</h5>

<p><strong>JavaScript で要素の色を調べるときは注意が必要です</strong>。<em>廃止予定のマイクロソフトのアクセサはオリジナルの16進数の値を返します</em>。<em>W3C のアクセサは16進数の値を RGB 表現に変換して返します</em>。</p>

<h4>3. CSS を JavaScript 中に埋め込む</h4>

<p>JavaScript の文字列に CSS を含めてしまう方法です。</p>

<h3>防衛的な HTML と CSS</h3>

<p>サードパーティ CSS においては、名前空間 (prefix) をつけるようにするとよいです。</p>

<pre><code class="css">.stork-container { width: 200px; height: 200px; }
</code></pre>

<h4>CSS 優先順位</h4>

<p>CSS が優先的に当たるルールは次のとおりです。</p>

<ol>
<li>インラインのスタイル(style=&ldquo;&hellip;&rdquo;)</li>
<li>ID</li>
<li>クラス、属性および擬似クラス(:forcus, :hover)</li>
<li>要素(div, span など)、擬似要素(:before, :after)</li>
</ol>


<p>ただし、<code>!important</code> というキーワードでタグ付けされたプロパティは優先順位が最も高くなります。</p>

<pre><code class="css !important の例">.stork-price {
  font-size:       11px  !important;
  color:           #888  !important;
  text-decoration: none  !important;
  display:         block !important;
}
</code></pre>

<p>ブラウザはスコアシステムを使ってどのルールが優先されるかを計算しています。</p>

<table>
<thead>
<tr>
<th> セレクタ / ルールタイプ  </th>
<th> スコア (a, b, c, d) </th>
</tr>
</thead>
<tbody>
<tr>
<td> インラインの style 属性  </td>
<td> 1, 0, 0, 0 </td>
</tr>
<tr>
<td> ID                       </td>
<td> 0, 1, 0, 0 </td>
</tr>
<tr>
<td> クラス、擬似クラス、属性 </td>
<td> 0, 0, 1, 0 </td>
</tr>
<tr>
<td> 要素、擬似要素           </td>
<td> 0, 0, 0, 1 </td>
</tr>
</tbody>
</table>


<p>スコアは <code>a &gt; b</code>、<code>b &gt; c</code>、<code>c &gt; d</code> のように価値が高くなります。(1, 0, 0, 0) は (0, 100, 0, 0) よりも優先されるということです。</p>

<ul>
<li><code>.stork-container</code> (0,0,1,0 - クラスセレクタ1つ)</li>
<li><code>.stork-container span</code> (0,0,1,1 - クラスセレクタ1つ、要素セレクタ1つ)</li>
<li><code>.stork-container .strok-msg</code> (0, 0, 2, 0 - クラスセレクタ2つ)</li>
</ul>


<h4>CSS を過剰に指定すれば優先度は高くなる</h4>

<p>パブリッシャのスタイルよりも優先的にスタイルを当てるための簡単な方法は、過剰にルールを指定することです。</p>

<p>```html</p>

<div id="stork-main">
  <div id="stork-container">
    <h3 class="stork-product">Mikon E90 Digital SLR</h3>
    <img src="http://camerastork.com/img/products/1337-small.png" />
    <p class="stork-price">$599</p>
    <p class="stork-rating">4.3/5.0 &bull; 176 Reviews</p>
  </div>
</div>


<pre><code></code></pre>

<h1>stork-main #stork-container { &hellip; }</h1>

<h1>stork-main #stork-container .stork-product { &hellip; }</h1>

<h1>stork-main #stork-container .stork-price { &hellip; }</h1>

<pre><code>

### コンテンツを iframe に埋め込む

*パブリッシャのスタイルルールによる影響を受けずにスタイルを設定する方法は、`iframe` を使うこと* です。

#### src なし iframe

`src` 属性を指定しない `iframe` を作る場合、独立したウィンドウと DOM 環境を有しているという点で強力な効果があります。そして、**親ページで実行されているスクリプトは直接それらのオブジェクトにアクセスが可能** です。
`iframe` はブラウザによって非同期的に処理されるため、`document.write` のようなブロッキングが発生する処理を `iframe` の中で行ってもブラウザが親ページを処理するのを妨げることはありません。
ただし1つ注意点は、*親ページの `onload` イベントはブロッキングしてしまう* 点です。これは、`iframe` のレンダリングが完了したあとで、`document.close()` を呼び出すことで `onload` を強制的に発生させることで回避できます。

#### 外部 iframe

`iframe` のコンテンツが外部から提供されている場合には *ブラウザは親ページでホストされているスクリプトがそのコンテンツにアクセスすることを許可しません*。


## サーバとの通信

サードパーティアプリケーションでは、**クロスドメイン** の問題を扱わなければなりません。クロスドメイン対応には基本的なテクニックがあります。

- JSONP
- サブドメインプロキシ
- クロスオリジンリソース共有 (CORS)

### AJAX とブラウザの同一生成元ポリシー (SOP)

ブラウザは異なる生成元から配信されたドキュメントがそれぞれお互いに分離されることを保証するという、**同一生成元ポリシー (SOP) ** を備えています。
これによって、ドキュメント上のスクリプトが他のドキュメントにアクセスできるのは *同じドメイン*、*同じポート*、*同じプロトコル* である場合に限ることになります。

すべてのブラウザが、`XMLHttpRequest`、`iframe`、それ以外のドキュメント間のメッセージのやり取りの方法についてこの同一生成元ポリシーを適用しています。

重要な点が1つあります。**HTML の script 要素は SOP の適用を受けません**。つまり、外部の JavaScript ファイルの読み込みは可能になっています。
ただし、*読み込まれた JavaScript はパブリッシャのコンテキストで実行されるということは注意が必要* です。
例えば、camerastork.com の widget.js を publisher.dev の index.html で読み込まれたとしても、widget.js は camerastork.com への `XmlHttpRequest` を開始できません。


### JSONP

SOP は「HTML の script 要素はチェックの対象外」という重要な例外をもっています。この例外を使って、例えば次のような JSON データを返す URL を script 要素を使って読み込んでみます。
</code></pre>

<p>{
  &ldquo;title&rdquo;: &ldquo;Third-party JavaScript&rdquo;,
  &ldquo;authors&rdquo;: [&ldquo;Anton&rdquo;, &ldquo;Ben&rdquo;],
  &ldquo;publisher&rdquo;: &ldquo;Manning&rdquo;
}
```</p>

<p>```html</p>

<script src="http://thirdpartyjs.com/info.json"></script>


<pre><code>
この読み込みはうまくいきます。ただし、問題は、info.json は JavaScript として実行されるということです。
info.json は JavaScript としては正しい構文ではありませんし、もし正しく JavaScript オブジェクトとして評価されたとしても、どこからも使われずに終わってしまいます。

そこで、info.json を次のように変更します。
</code></pre>

<p>var jsonResponse = {
  &ldquo;title&rdquo;: &ldquo;Third-party JavaScript&rdquo;,
  &ldquo;authors&rdquo;: [&ldquo;Anton&rdquo;, &ldquo;Ben&rdquo;],
  &ldquo;publisher&rdquo;: &ldquo;Manning&rdquo;
};
```</p>

<p>こうすると、JavaScript として正しい評価がされ、スクリプトの実行が終わると、グローバルの <code>jsonResponse</code> 変数にオブジェクトが設定され使えるようになります。
変数ではなく、関数を呼び出すこともできます。そして、<strong>JSONP</strong> というのは、この <em>script を読み込む際に URL のクエリパラメータを使って呼び出し元がコールバック関数を指定できる仕組み</em> のことになります。</p>

<pre><code class="javascript">
function jsonpCallback(json) {
  console.log(json);
}

var script = document.createElement('script');
script.async = true;
script.src   = 'http://thirdpartyjs.com/info.js?callback=jsonpCallback';
document.body.appendChild(script);
</code></pre>

<h4>JSONP の制限</h4>

<p>JSONP は <strong>GET リクエストでのみ利用可能</strong> です。RESTful API を提供しているような場合、JSONP に合わせて GET のエンドポイントを用意していあげる必要が出てくるかもしれません。</p>

<p><em>JSONP リクエストは必ず非同期で処理されます</em>。ほとんどないとは思いますが、もしブロッキングが必要になった場合は、JSONP では不可能です。</p>

<h3>サブドメインプロキシ</h3>

<p>SOP は生成元のホスト部分を厳密に区別しています。<code>sub.example.com</code> と <code>example.com</code> は上位レベルのドメインは同じ (example.com) ですが、ブラウザは無関係なドメインとみなします。</p>

<p>デフォルトの動作はこうなりますが、ブラウザは <strong>Web サイトが生成元のホスト名をその上位ドメインに設定することを許可しています</strong>。
そのため、sub.example.com と alt.example.com のような共通の上位ドメインをもつサイト同士であれば両方の生成元を example.com に設定することでお互いに通信することができるようになります。</p>

<p>もし、企業向けの限られた環境だけで使うような JavaScript を作るのであれば、サブドメインの CNAME を割り当ててもらい、同一生成元を上位ドメインに設定することで通信可能にできるかもしれません。</p>

<h4>document.domain を利用してドキュメントの生成元を変更する</h4>

<p>ドキュメントの生成元を変えるには次のようなスクリプトを実行します。</p>

<pre><code class="javascript">document.domain = 'example.com';
</code></pre>

<p>生成元変更にはいくつか注意点があります。</p>

<ul>
<li>生成元を変更するスクリプトは <code>example.com</code> と <code>sub.example.com</code> の <strong>両方</strong> で行う必要がある</li>
<li><code>document.domain</code> を変更できるのは <strong>ページあたり1回だけ</strong></li>
<li><code>document.domain</code> を変更することで、<strong>生成元のポートは80にリセット</strong> される</li>
</ul>


<h4>AJAX から呼び出すためのサブドメイントンネルファイル</h4>

<p><code>document.domain</code> を変更することでドキュメントの生成元を変更することができるようになりましたが、まだこれだけでは AJAX を使ってサブドメインのドキュメントを読み込むことはできません。
<em>AJAX においては、まずリクエストを送ってみない限り取得するドキュメントが同じドメインに参加しようとしているかを知ることができない</em> からです。
CORS の仕様では特別なヘッダを使ってプリフライトリクエストを行うことでこの問題を解決していますが、ここではトンネルファイルを使った方法を見ていきます。</p>

<h5>非表示の iframe を使う</h5>

<p>AJAX リクエストを呼び出すページが呼び出し先のドメインと同じであればリクエストを送ることができますので、予め呼び出し先のドキュメントを同一生成元を変更して読み込めていれば、そのドキュメントを使って AJAX リクエストを送ることができます。</p>

<p>それが、<em>非表示の iframe を使う方法</em> です。非表示の iframe で生成元を変更するスクリプトが書かれたページを読み込み、そのページから AJAX リクエストを送るようにするのです。
そうすれば、サブドメインプロキシを通じて、トンネルファイルの iframe 上の非表示ドキュメントから AJAX リクエストを呼び出すことができ、iframe 上のドキュメントと親ページは同じ同一の生成元にいるのでデータの受け渡しも可能になるという仕組みができます。</p>

<p><img src="/images/2014-02-23-third-party-javascript-01.png" alt="サブドメイントンネルファイル" /></p>

<h5>JSONP と動的フォームを使う</h5>

<p>AJAX リクエストを送るためには非表示の iframe をもちいた中間ファイルが必要になります。中間ファイルを用いない方法として、動的にフォームを作成して、フォームをリクエストするという方法があります。</p>

<p><code>form</code> タグには <code>target</code> 属性が用意されているので、動的にフォームを作る際に結果を受け取るための <code>iframe</code> を作成して、その iframe をターゲットにフォームをポストするといいです。</p>

<h4>Google のブラウザセキュリティハンドブック</h4>

<p>同一生成元ポリシーやそれに伴うセキュリティ上のリスクをもっとよく知りたい場合は、Google の「ブラウザセキュリティハンドブック」のパート2を読むとよいです。</p>

<p><a href="https://code.google.com/p/browsersec/wiki/Part2">ブラウザセキュリティハンドブック Part2</a></p>

<h3>クロスオリジンリソース共有 (CORS)</h3>

<p><strong>クロスオリジンリソース共有 (CORS)</strong> は W3C のワーキングドラフトになっている、きちんと管理された形でドメインをまたがってサーバと通信を行う方法を定めたものです。</p>

<p>CORS では一連の特別な HTTP ヘッダを使ってブラウザとサーバがやり取りを行えるかどうかを決定するようになっています。</p>

<h4>Origin リクエスト</h4>

<p>クロスオリジンの HTTP リクエストを開始する際には、CORS に対応したブラウザは <code>Origin</code> と呼ばれる特殊なヘッダを含むリクエストを使って生成元を示すことになっています。</p>

<pre><code class="plain-raw">Origin: http://www.example.com/
</code></pre>

<p>サーバ側はこのヘッダをチェックして、そのリクエストが許可されるかどうかを決定します。応答するには、サーバは <code>Access-Control-Allow-Origin</code> というレスポンスヘッダにクライアントが送ったのと同じ生成元を入れて返さなければなりません。</p>

<pre><code class="plain-raw">Access-Control-Allow-Origin: http://www.example.com/
</code></pre>

<p>あらゆるところからリクエストを許可するにはワイルドカードを使うこともできます。</p>

<pre><code class="plain-raw">Access-Control-Allow-Origin: *
</code></pre>

<p>リクエストを許可しない場合は、サーバ側は CORS ヘッダを返さないようにします。また、リクエストに <code>Origin</code> ヘッダが存在していない場合は、サーバも CORS ヘッダを送り返すべきではないとされています。</p>

<h4>CORS で Cookie や認証ヘッダを送信する</h4>

<p>デフォルトでは、ブラウザは CORS を行う際には Cookie や HTTP 認証ヘッダを送らないようになっています。
こうした識別情報を送信するべきであると明示する場合には、<code>XmlHttpRequest</code> オブジェクトに <code>withCredentials</code> プロパティを設定します。</p>

<pre><code class="javascript">var xhr = new XmlHttpRequest();
xhr.withCredentials = true;
</code></pre>

<p>サーバ側は、識別情報を必要としている場合には <code>Access-Control-Allow-Origin</code> ヘッダに加えて、<code>Access-Control-Allow-Credentials</code> というヘッダもレスポンスに含める必要があります。
このヘッダがないと、ブラウザはレスポンスを拒否していしまいます。</p>

<pre><code class="plain-raw">Access-Control-Allow-Credentials: true
</code></pre>

<h2>クロスドメインでの iframe 間通信</h2>

<p>パブリッシャのページ上で実行されるアプリケーションコードと iframe 内のサードパーティのドメインで配信されているページとの間でドキュメントをやり取りする方法です。</p>

<h3>HTML5 window.postMessage API</h3>

<p><code>window.postMessage</code> はイベントを利用した安全なクロスドメイン通信 API です。
メッセージを送りたいウィンドウオブジェクトを取得して、<code>postMessage</code> を送るだけです。
送られる側はウィンドウの <code>message</code> イベントで受け取ります。</p>

<p>```html http://publisher.dev/index.html
&lt;!DOCTYPE html>
<html>
<body></p>

<h1>Publisher</h1>




<iframe id="thirdparty" src="http://thirdparty.dev/index.html">
</iframe>




<script>
var frame = document.getElementById('thirdparty');
frame.addEventListener('load', function(e) {
    var win = frame.contentWindow;
    win.postMessage('Hello World!', 'http://thirdparty.dev/');
});
</script>


<p></body>
</html>
```</p>

<p>```html http://thirdparty.dev/index.html
&lt;!DOCTYPE html>
<html>
<body></p>

<h1>thirdparty</h1>


<script>
function receiver(e) {
    console.log(e.data);
    console.log(e.origin);
    console.log(e.source);
}
window.addEventListener('message', receiver, false);
</script>


<p></body>
</html>
```</p>

<h3>easyXDM を利用したクロスドメインメッセージング</h3>

<p><a href="http://easyxdm.net/wp/">easyXDM</a></p>

<p>クロスドメイン間でメッセージをやり取りするためのライブラリに <strong>easyXDM</strong> があります。
このライブラリは複数の異なるクロスドメインメッセージングのテクニックを組み合わせて、そのなかかkらそれぞれのブラウザに適したものを選択してくれます。</p>

<h2>メモ</h2>

<h3>ポップアップブロック機能を回避する方法</h3>

<p><blockquote><p>これを避けるには、新しいウィンドウを常に<strong>ユーザーのアクションの直接の結果</strong>として開くようにすることだ。ユーザーのアクションからウィンドウを開くまでの間に遅延が存在すると、多くのブラウザはそれを悪意ある動作とみなして処理を阻止してしまう。</p></blockquote></p>

<h2>感想</h2>

<p>読んでみて、<strong>本書はサードパーティ JavaScript を書かなくても、サーバ側の API を実装するだけの人も読むべき</strong> だと思いました。
クロスオリジン問題やセキュリティに関する話題も豊富に書かれていて、全てが有用な情報です。</p>

<p>ブラウザとサーバがどんなことをやっているのかをきちんと理解したい人は、是非よんでみてください。絶対に為になります。</p>
]]></content>
  </entry>
  
</feed>
