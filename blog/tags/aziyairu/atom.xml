<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: アジャイル | それはBooks]]></title>
  <link href="http://hamasyou.com/blog/tags/aziyairu/atom.xml" rel="self"/>
  <link href="http://hamasyou.com/"/>
  <updated>2014-07-22T10:58:45+09:00</updated>
  <id>http://hamasyou.com/</id>
  <author>
    <name><![CDATA[hamasyou]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[オブジェクト開発の神髄〜UML 2.0を使ったアジャイルモデル駆動開発のすべて]]></title>
    <link href="http://hamasyou.com/blog/2005/09/03/4822282376/"/>
    <updated>2005-09-03T09:14:00+09:00</updated>
    <id>http://hamasyou.com/blog/2005/09/03/4822282376</id>
    <content type="html"><![CDATA[<p>本書は、ソフトウェア開発における<strong>上流工程から設計</strong>までをカバーした本です。アジャイルにソフトウェア開発を行う方法について書かれています。要求をユースケースにまとめ、概念モデルを書き、ビジネスプロセスをモデル化して、設計を行う。一連のソフトウェア開発の流れに沿って、アジャイルに進めるにはどうしたらよいのか、どうUMLを活用したらよいのかについて説明されている本です。</p>

<p>筆者の経験則が随所にちりばめられており、経験の少ない人でも理解しやすくなっています。UMLを使ったモデリングの方法について書かれている本ですが、図の書き方については書かれていません。本書は<strong>使い方の本</strong>です。</p>

<p>非常に読みやすい内容で、納得できる部分も多いです。重要事項についてだけ書かれている、そんな感じのする書籍になっています。このボリュームで4,200円は安いと思います。</p>

<!-- more -->




<h2>特長</h2>




<h3>UMLの書き方によらない本質</h3>


<p>タイトルには『UML2.0を使ったアジャイルモデル駆動開発のすべて』とあり、よくあるUMLの書き方についての書籍かと思われるかもしれません。</p>

<p>確かに、UMLの記法は使われています。しかし、本書で使われているUMLは厳密なUMLとは少し違います。それは、本書がアジャイル開発を元に書かれているからです。使わないドキュメントに力を注ぐよりも、他にやるべきことがあるはずだというスタンスです。そのため、本書で扱われているすべてのことが、必要最低限の重要な事柄なのです。</p>

<p>『オブジェクト開発の神髄』とは、お客様の利益を生み出すための究極の開発方法論なのかも知れません。</p>

<h2>参考</h2>


<ul>
<li>さらに設計よりにUMLを使う方法について書かれています。</li>
</ul>


<div class="rakuten"><table  border="0" cellpadding="5"><tr><td colspan="2" ><a href="http://www.amazon.co.jp/exec/obidos/ASIN/4894713861/sorehabooks-22/" rel="external nofollow">G-Tools</a></font></td></tr></table></div>


<ul>
<li>実装よりの本です。結合度、凝集度といったOOPのキーワードについて深く知りたい人におすすめです。</li>
</ul>


<div class="rakuten"><table  border="0" cellpadding="5"><tr><td colspan="2" ><a href="http://www.amazon.co.jp/exec/obidos/ASIN/4797323361/sorehabooks-22/" rel="external nofollow">G-Tools</a></font></td></tr></table></div>


<ul>
<li>UMLを使ってモデルを書くときには「エッセンス」が大切です。</li>
</ul>


<div class="rakuten"><table  border="0" cellpadding="5"><tr><td colspan="2" ><a href="http://www.amazon.co.jp/exec/obidos/ASIN/4798107956/sorehabooks-22/" rel="external nofollow">G-Tools</a></font></td></tr></table></div>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[アジャイルモデリング―XPと統一プロセスを補完するプラクティス]]></title>
    <link href="http://hamasyou.com/blog/2005/02/04/4798102636/"/>
    <updated>2005-02-04T09:03:00+09:00</updated>
    <id>http://hamasyou.com/blog/2005/02/04/4798102636</id>
    <content type="html"><![CDATA[<p>アジャイルモデリングとは何か −</p>

<p><blockquote><p>アジャイルモデリング(AM)とは、効果的なモデラーになるための秘訣を説明した、プラクティスに基づくプロセスです。モデリングなんてしないという極端な状況では、ソフトウェアが十分に考えられずに作成されたことに気づいたときには、膨大な再作業が発生することがあります。もう一方の極端は、過剰にモデルや文章が作成されると言う場合で、カタツムリのようにソフトウェア開発の進行が遅れることがしばしばです。<b>AM は、そのような両極端の間で、開発対象のシステムを効果的に検討したり、文章家するために十分なレベルで、かつプロジェクトの開発を遅らせるような重荷にならない程度で、程よくモデリングを行うためのやり方を探すお手伝いをします</b>。</p></p><p><p></p><footer><strong>本書はじめにより</strong></footer></blockquote></p>

<p>今までのプロジェクトを振り返って、モデリングがなされなかったプロジェクトはいくつありましたか？ドキュメント地獄で、実行可能なコードを書く時間がまったく無かったプロジェクトはいくつありましたか？本書は「<strong>アジャイルモデリング</strong>」という、モデリングの方法を解説します。</p>

<p>本書では、モデルの表記法(ノーテーション)には触れていません。<abbr title="Unified Modeling Language">UML</abbr>を使ってもいいし、OMTを使ってもかまいません。また、開発プロセスに関しても、アジャイル開発プロセス(XP、 Scrum、FDDなど）に適用すれば効果的ですが、開発プロセスの限定はしていません。</p>

<p>本書は、確かにためにはなるし、勉強になります。ただ、そんなことよりも<b class="red">読んでいてワクワクする</b>気持ちのほうが強かったです。読み終わった後、何かしたい衝動に駆られること間違いなしです。</p>

<p>アジャイルモデリングの原則、プラクティス、実践、実際に開発プロセスに適用した場合のケーススタディ。本書は、アジャイルモデリングを余すところ無く解説しています。開発者だけでなく、プロジェクトマネージャーにも是非読んで欲しい一冊です。<b>非常に良い本</b>です。かなりおすすめです。</p>

<!-- more -->




<h2>特徴</h2>


<p>アジャイルモデリング (AM) と聞いて、最初に頭に思い浮かぶのが「モデリング技法」なのか？と言うことでした。UMLを用いたモデリング技術に関することが述べられていると思って購入しましたが、実はそういうものではありませんでした。</p>

<p>本書は、モデリング技術(技法)に関してはまったく触れていません。どういうことが書いてあるかというと、大体つぎのような感じです。</p>

<ul><li>アジャイルの原則の説明(考え方)</li>
<li>アジャイルプラクティスの説明(考え方) + 実践方法</li>
<li>実際の現場でアジャイルモデリングを行うためにはどうすればよいか</li>
<li>開発プロセス(XP、統一プロセス(UP)) に適用した場合の位置づけ</li></ul>


<p>実際のモデルやコードが出てくるわけではないので、雲をつかむような話に感じてしまいがちですが、そうではありませんでした。アジャイルモデリングと言うのは、非常に「<b>現場指向</b>」になっているからです。人のつながりを重要視し、複雑なものより簡潔さを好み、変更があることを前提に楽しみます。</p>

<p><b>概念や考え方を解説した本でありながら、現場ですぐにでも使える</b>というところがとても印象的です。いつまでもCASEツールを使って不要なモデルを書くよりも、ホワイトボードに集まってみんなで検証しながらモデリングしたほうがずっと効果的です。本書はこういった点に気づかせてくれます。</p>

<p>2度、3度と読めてしまうほど、分かりやすくかかれています。非常におすすめの本です。 開発者のバイブルとなるでしょう。Be Agile！</p>

<h2>参考</h2>


<ul>
<li><p>アジャイルモデリング(AM)のホームページです
<img src="http://hamasyou.com/images/img-link.gif"   align="middle" /> <a href="http://www.ogis-swe.jp/process/am-res/am/" rel="external nofollow">アジャイルモデリング(AM) 公式サイト</a></p></li>
<li><p>アジャイルソフトウェア開発の奥義！これも特におすすめ</p></li>
</ul>


<div class="rakuten"><table width=400 border="0" cellpadding="5"><tr><td colspan="2"><a href="http://www.amazon.co.jp/exec/obidos/ASIN/4797323361/sorehabooks-22/" rel="external nofollow">G-Tools</a></font><br /></td></tr></table></div>


<ul>
<li>アジャイル開発プロセスを学びたい人におすすめ</li>
</ul>


<div class="rakuten"><table width=400 border="0" cellpadding="5"><tr><td colspan="2"><a href="http://www.amazon.co.jp/exec/obidos/ASIN/4822281914/sorehabooks-22/" rel="external nofollow">G-Tools</a></font><br /></td></tr></table></div>


<ul>
<li>プロジェクトマネージャーに特におすすめしたい一冊</li>
</ul>


<div class="rakuten"><table width=400 border="0" cellpadding="5"><tr><td colspan="2"><a href="http://www.amazon.co.jp/exec/obidos/ASIN/4798102199/sorehabooks-22/" rel="external nofollow">G-Tools</a></font><br /></td></tr></table></div>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[オブジェクト指向設計の原則]]></title>
    <link href="http://hamasyou.com/blog/2004/07/22/4797323361/"/>
    <updated>2004-07-22T13:43:00+09:00</updated>
    <id>http://hamasyou.com/blog/2004/07/22/4797323361</id>
    <content type="html"><![CDATA[<p>「アジャイルソフトウェア開発の奥義」を読んで第二弾。オブジェクト指向設計の原則に関するメモです。自分で読んで思い出せるくらいの内容しかメモってないと思われるので、もっと詳しい解説が欲しければ本書を買ってください。</p>

<p>本書には、クラス設計の原則として5つの原則が載っています。</p>

<ul><li><strong>単一責任の原則</strong> (The Single Responsibility Principle: SRP)</li>
<li><strong>オープン・クローズドの原則</strong> (The Open-ClosedPrinciple: OCP)</li>
<li><strong>Liskovの置換原則</strong> (The Liskov Substitution Principle: LSP)</li>
<li><strong>依存関係逆転の原則</strong> (The Dependency Inversion Principle: DIP)</li>
<li><strong>インターフェース分離の原則</strong> (The Interface Segregation Principle: ISP)</li></ul>


<p>パッケージ設計の原則として次6つの原則が載っています。</p>

<ul><li><strong>再利用・リリース等価の原則</strong> (Resuse-Release Equivalency Principle: REP)</li>
<li><strong>全再利用の原則</strong> (Common Resue Principle: CRP)</li>
<li><strong>閉鎖性共通の原則</strong> (Common Closure Principle: CCP)</li>
<li><strong>非循環依存関係の原則</strong> (Acyclic Dependencies Principle: ADP)</li>
<li><strong>安定依存の原則</strong> (Stable Dependencies Principle: SDP)</li>
<li><strong>安定度・抽象度等価の原則</strong>(Stable Abstractions Principle: SAP)</li></ul>


<p>『<a href="http://www.amazon.co.jp/exec/obidos/ASIN/4894715937/sorehabooks-22" rel="external nofollow">プログラマのためのJava設計ベストプラクティス</a>』という本にも、オブジェクト指向設計の原則に関しての解説があります。</p>

<!-- more -->




<h2>設計における原則</h2>


<p>オブジェクト指向設計におけるデザインパターンよりも上の概念に、原則というものがあります。原則は主に5つか6つあります。本書では5つの原則に関して、わかりやすい説明と理解しやすい例を挙げて説明してくれました。</p>

<p>本書は、プログラム設計者だけでなくプログラマの人にも、是非読んでもらいたいです。だてに「Jolt Award受賞」はしていません。「アジャイル開発はいいぞー」なんて偏った解説本ではなく、設計・テスト・原則・パターン・プラクティスといった、ソフトウェア開発における重要な側面を、丁寧かつわかりやすく説明してくれています。ほとんどの解説に目からウロコがおちます。最高の本ですので、一度立ち読みでもしてみてください。</p>

<h4>クラス設計の原則</h4>




<ol><li><a href="#srp" rel="external nofollow">単一責任の原則(The Single Responsibility Principle: SRP)</a></li>
<li><a href="#ocp" rel="external nofollow">オープン・クローズドの原則(The Open-Closed Principle: OCP)</a></li>
<li><a href="#lsp" rel="external nofollow">Liskovの置換原則(The Liskov Substituion Principle: LSP)</a></li>
<li><a href="#dip" rel="external nofollow">依存関係逆転の原則(The Dependency Inversion Principle: DIP)</a></li>
<li><a href="#isp" rel="external nofollow">インターフェース分離の原則(The Interface Segregation Principle: ISP)</a></li></ol>




<h4>パッケージ設計の原則</h4>




<ol><li><a href="#rep" rel="external nofollow">再利用・リリース等価の原則(Reuse-Release Equivalency Principle: REP)</a></li>
<li><a href="#crp" rel="external nofollow">全再利用の原則(Common Reuse Principle: CRP)</a></li>
<li><a href="#ccp" rel="external nofollow">閉鎖性共通の原則(Common Closure Principle: CCP)</a></li>
<li><a href="#adp" rel="external nofollow">非循環依存関係の原則(Acyclic Dependencies Principle: ADP)</a></li>
<li><a href="#sdp" rel="external nofollow">安定依存の原則(Stable Dependencies Principle: SDP)</a></li>
<li><a href="#sap" rel="external nofollow">安定度・抽象度等価の原則(Stable Absstractions Principle: SAP)</a></li></ol>




<h2 id="srp">クラス設計の原則</h2>




<h3>単一責任の原則(The Single Responsibility Principle: SRP)</h3>


<p><blockquote><p>クラスを変更する理由は一つ以上存在してはならない</p></p><p><p></p><footer><strong>本書</strong></footer></blockquote></p>

<p>クラスには一つの役割だけを持たせるべきです。単一責務のクラスは、クラス自体の変更理由がたった一つに絞られます。その責務が変更された場合だけクラスの変更がおきます。</p>

<dl>
<dt class="tips">Tips</dt>
<dd>複数の役割を持ったクラスは、変更理由も複数になっていまい、変更部分がわかりづらくなります。</dd>
</dl>


<p>単一責任の原則(SRP)では「<strong>役割(責任) = 変更理由</strong>」として定義されています。役割の観点からクラスの設計を行うと、複数の役割を負っているかの判断がつくにくい場合があります。そんなときは、アプリケーションが今後、どんな変更をされるかを考えてみるといいです。</p>

<p>本書の例に、Modem というクラスがでてきました。Modem クラスは、「接続の管理」と「データ通信」の2つの役割を持っています。アプリケーションで、「接続の管理」と「データ通信」が別々に変更されうるのならば、Modem クラスは、2つの役割を持っていることになります。しかし、常に同時に変更される場合は、1つの役割を持っていると言っても問題ありません。</p>

<p>このように、クラスの役割を見極めるのに、変更理由の観点からクラスを眺めるのも一つの手です。</p>

<dl>
<dt class="tips">Tips</dt>
<dd>変更の理由が変更の理由たるのは、実際に変更の理由が生じた場合だけである</dd>
</dl>


<p>単一責任の原則を適用するには、どのような点に気をつければいいのでしょうか？その答えの一つに、「<strong>GRASP (General Responsibility Assignment Software Patterns)</strong>」というものがあります。詳しくは『<a href="http://www.amazon.co.jp/exec/obidos/ASIN/4894713861/sorehabooks-22" rel="external nofollow">実践UML</a>』を参考にするといいと思います。ここでは簡単にまとめておきます。</p>

<h3>GRASP</h3>


<p>GRASP には基本パターンが5つと、追加パターンが4つ(以上)あります。GRASP というのは、クラスの責務割り当てにおける一般原則のパターンのことです。ここでいう「責務」とは、次の2つのことを言います。</p>

<ol><li><strong>情報把握 (knowing)</strong></li><li><strong>実行 (doing)</strong></li></ol>


<p>情報把握責任の例には、カプセル化しているデータを把握していることや関係しているオブジェクトを把握しているといったものがあります。また、実行責任の例には、自分自身で何かを行うことや関連するオブジェクトのアクションを起動させることなどがあります。</p>

<p>GRASP の基本パターンには次のものがあります。</p>

<ul><li>Expert (エキスパート)</li>
<li>Creator (生成者)</li>
<li>High Cohesion (高凝集性)</li>
<li>Low Coupling (疎結合性)</li>
<li>Controller (コントローラ)</li></ul>




<dl>
<dt>Expert (エキスパート)</dt>
<dd>責務の遂行に必要な情報を持っているクラスに、責務を割り当てるものです。</dd>
<dt>Creator (責任者)</dt>
<dd>他のクラスのインスタンスを生成する責務を割り当てるパターンです。クラスの関係が「集約」や「コンポジション」になっている場合や、密接にかかわりを持つクラス、インスタンスの初期化データを持つ場合に、責務を割り当てます。</dd>
<dt>High Cohesion (高凝集性)</dt>
<dd>機能の類似性が高まるようにクラスに責務を割り当てるパターンです。ただし、あまりに多い仕事量を持つクラスでは、凝集性は高いとはいえなくなります。</dd>
<dt>Low Coupling (疎結合性)</dt>
<dd>クラス間の関連を出来るだけ少なくなるように責務を割り当てるパターンです。ただし、再利用性を重視しない場合は、特別重要にならない場合があります。</dd>
<dt>Controller (コントローラ)</dt>
<dd>システムイベントを処理する責務をコントローラと呼ばれる「システム全体」を表したようなクラスに割り当てるパターンです。ユースケース単位で作成されるのが普通です(Facadeパターン GoF)。</dd>
</dl>




<h3 id="ocp">オープン・クローズドの原則(The Open-Closed Principle: OCP)</h3>


<p><blockquote><p>ソフトウェアの構成要素(クラス・モジュール・関数など)は拡張に対して開いて(オープン: Open)いて修正に対して閉じて(クローズド: Closed)いなければならない。</p></p><p><p></p><footer><strong>本書</strong></footer></blockquote></p>

<p>OCPを上手く適用してあるシステムは、変更に対してコードの追加という手段で対処できるようになります。既存のコードに手を加えなる必要がなくなるため、動いているコードを壊す恐れがなくなります。</p>

<dl>
<dt>拡張に対して開かれている(オープン: Open)</dt>
<dd>モジュールの振る舞いを拡張できるということ。仕様変更が起こった場合に、モジュールの振る舞いを追加することで対応できる。</dd>
<dt>修正に対して閉じている(クローズド: Closed)</dt>
<dd>モジュールの振る舞いを変更しても、既存のソースコードやバイナリコードは影響を受けない。</dd>
</dl>




<dl>
<dt class="tips">Tips</dt>
<dd>オープン・クローズドの原則の鍵は、「抽象」にあります。モジュールをある固定した「抽象」に依存させておけば、修正に対してコードを閉じることができるようになります。「抽象」を使えば、派生クラスを新たに追加するだけで、振る舞いを拡張できます。</dd>
</dl>


<p>本書を読んでいて、ウロコが落ちたのが下の図です。</p>

<p><img src="http://hamasyou.com/images/agilesoftware/open-closed1.gif" alt="Open-Closed   の原則" align="middle" /></p>

<p>この図は、Client はClient Interface という抽象を利用して処理が組まれていて、Client Interface の実装が Server によって提供されるというものです。Client が依存する抽象の名前が、Client Interface であるのがポイントです。</p>

<p>「<strong>抽象クラスはそれを実際に実装するクラスとの関連よりも、それを利用するクラスとの関係のほうがずっと密接</strong>」という事実があるため、インターフェースには、Client Interface という名前がついています。この辺の詳しい説明は、本書を読んでください。</p>

<dl>
<dt class="tips">Tips</dt>
<dd>オープン・クローズドの原則に順ずるためにもっとも典型的に使われるのが、「<a href="http://www.hellohiro.com/pattern/strategy.htm" rel="external nofollow">Template Method パターン</a>」です。</dd>
</dl>




<h4>いつ「抽象」を導入すればいいのか</h4>


<p>これには、2通りの答えがあります。一つは、設計する人がどういった種類の変更に対して自分の設計を閉じたいのかを選択し、その変更に対して閉じるという、先を見越した対策。
　
もう一つは、実際に変更が起きた場合に「抽象」を組み込むという対応。すべての変更に対してこの原則を適用するにはコストがかかりすぎるため、実際に変更されるまで、この原則を導入しないという方法もあります。</p>

<p>とはいっても、運用後の変更で、「抽象」を導入するとバグを生み出してしまう可能性も無くはありません。ここで大活躍するのが「<strong>テストファースト</strong>」です。確実にテストを行えるようにするために設計しておけば、テストの変更で取り入れた「抽象」の多くが、実際の運用時の変更に耐えられるものになっている場合が多いのです。</p>

<dl>
<dt class="tips">Tips</dt>
<dd>早まった抽象をしないことも、抽象を使うのと同様に重要なこと</dd>
</dl>




<h3 id="lsp">Liskovの置換原則(The Liskov Substituion Principle: LSP)</h3>


<p><blockquote><p>派生型はその基本型と置換可能でなければならない</p></p><p><p></p><footer><strong>本書</strong></footer></blockquote></p>

<p>派生型に求められるのは、「基本型の能力＋アルファ」であるということ。基本型にできることが、派生型でできなくなっているような継承の仕方では、LSP に反しているといえます。</p>

<p>これは、先ほどの OCP にあった、抽象を使って実装と切り離すということができなくなる事を示しています。抽象の変わりに実装を使った場合の振る舞いが予期できないものになってしまうからです。</p>

<p>例えば、抽象クラスで宣言された get というメソッドを、実装時に使わせたくないなどの理由で例外が発生するようにしてしまった場合、実装クラスを抽象クラスの変わりに使えなくなってしまう。if 文の分岐や instanceof などを使って、オブジェクトの型を判定しなければならなくなってしまいます。</p>

<h4>契約による設計</h4>


<p>これは、契約によってクラスを使うクライアントが必要としている振る舞いを、クラスの作成者に強制させることができるというものです。これには、<strong>事前条件</strong> と <strong>事後条件</strong> というものをつかいます。</p>

<p>ここで、ポイントなのは、「どうしてクラスのクライアント側が、機能の実装者に契約を課すことができるのか？」という点です。実際のコーディングでは、機能の実装者が使用者に契約を課すことはできても、使用者が実装者に契約を課すことは明示的にするのはむずかしいです。</p>

<p>でも実は一つだけクライアントが実装者に契約を課す方法があるのです。OCP のところで出てきた図をもう一度見ると答えがでてくるのではないでしょうか？ そう！Client に、必要なインターフェースを定義してもらうのです。クラスの使用者である Client は、自分の定義したインターフェースにのみ依存します。 Server はそのインターフェースを実装するときに、契約に沿って実装すればよいのです。</p>

<p>この、「契約による設計」を適用することで、Liskov の置換原則を守ることができるようになります。この辺の解説が非常に面白いので、一度本書を読んでみてください。
　</p>

<h4>参考</h4>




<ul><li><a href="http://www.ne.jp/asahi/yamashita/programming/se/pbd.html" rel="external nofollow">契約によるプログラミング</a></li></ul>




<h3 id="dip">依存関係逆転の原則(The Dependency Inversion Principle: DIP)</h3>


<p><blockquote><p></p></p><p><ol><li>上位のモジュールは下位のモジュールに依存してはならない。どちらのモジュールも「抽象」に依存すべきである</li><br/><li>「抽象」は実装の詳細に依存してはならない。実装の詳細が「抽象」に依存すべきである</li></ol></p><p><br/><p></p><footer><strong>本書</strong></footer></blockquote></p>

<p><img src="http://hamasyou.com/images/engineer_soul/layer.gif" alt="依存関係の図" /></p>

<p>上記の図は、上位モジュールである Policy 層が下位モジュールの Service 層や Utility 層に依存してしまっています。この依存関係を反転させたのが下記の図です。
　
<img src="http://hamasyou.com/images/engineer_soul/new_layer.gif" alt="依存関係を解消した図" /></p>

<p>上位のモジュールは、下位のモジュールに依存しなくなっています。注目なのは、下位のモジュールが、上位モジュールと同レベルの「抽象」に依存した点です。</p>

<h4>抽象に依存せよ</h4>


<p>この原則の本質は、「プログラムは具体的なクラスに依存してはいけない。プログラム内の関係はすべて、抽象クラスかインターフェースで終結すべきである。」という点にあります。この辺り、さらに上位のパッケージやモジュールといった集合に関しても同様の議論があります。本書の後半に、パッケージの結合度のところで、安定度に関しての説明時にさらに鮮明に言いたいことがわかるようになると思います。</p>

<dl>
<dt class="tips">Tips</dt>
<dd>プログラムの関係は、抽象クラスかインターフェースにのみ依存するようにする。疎結合であることが、よいプログラムのひとつの指針です。</dd>
</dl>




<h4>インターフェースが変更されるのは、クライアントが変更を必要としたときのみ</h4>


<p>抽象インターフェースはクライアントクラスが宣言するものであり、それはクライアント自らが必要なサービスを受けるためだという視野に立つと、インターフェースが変更されるのは、クライアントが変更を必要とするときだけです。</p>

<p>インターフェースは、誰の所有物でもありません。インターフェースはたくさんのクライアントによって利用され、多数のサーバーに実装されることになるので、どのグループにも所属しない独立した存在でなければならりません。</p>

<h3 id="isp">インターフェース分離の原則(The Interface Segregation Principle: ISP)</h3>


<p><blockquote><p>すべてのインターフェースを一つのクラスに押し込めてしまうのではなく、関連性を持ったインターフェースはグループ化し、抽象基本クラスとして分けて利用すべき</p></p><p><p></p><footer><strong>本書</strong></footer></blockquote></p>

<p>クラスを利用するクライアントが違うのならば、インターフェースを別にしておくべきです。クライアントは、利用するインターフェースに依存することになるからです。これは、依存関係逆転の原則でもあったように、インターフェースの変更は、クライアントが変更を要する場合にとどめておくべきです。</p>

<dl>
<dt class="tips">Tips</dt>
<dd>クラスのクライアントが違うのなら、インターフェースは別にしておくこと。</dd>
</dl>


<p>クライアントが利用するインターフェースごとに分離させておけば、変更時にクライアントに影響する度合いが少なくなります。たくさんのインターフェースを実装しているクラスに変更が入った場合、クライアントに、自分の利用しないインターフェースの変更による影響を与えてはいけないのです。</p>

<dl>
<dt class="tips">Tips</dt>
<dd>インターフェースのクライアントに、クライアントが依存しないメソッドへの依存を強制してはならない。</dd>
</dl>




<h2>パッケージ設計の原則</h2>


<p>Java言語で開発を行っていると、パッケージという言葉を聞くと思います。UML にも「パッケージ」というものが存在します。Java言語のパッケージとほとんど同じ意味で使われる、「機能のグループ単位」です。パッケージはサブシステムとも呼ばれます。</p>

<p>パッケージ分けの指針として、マーチン・ファウラーの著 『<a href="http://www.amazon.co.jp/exec/obidos/ASIN/4881358642/sorehabooks-22" rel="external nofollow">UML モデリングのエッセンス 第２版</a>』 ではこんなことを言っています。
　
<blockquote><p>クラスの場合それをグループにまとめるための何らかの方針がなければ、グループ化は意味のない単なるまとまりになってしまいます。私が最も効果的だと感じ、UMLにおいても最も強調しているのは、<strong>依存関係に基づくグループ化</strong>です。</p></p><p><p></p><footer><strong>本書</strong></footer></blockquote></p>

<dl>
<dt class="notice">Notice</dt>
<dd>クラスと、パッケージの一番の大きな違いは、「パッケージは依存関係に推移性をもたない」ということです。</dd>
</dl>


<p><img src="http://hamasyou.com/images/agilesoftware/dependency.gif" alt="クラス依存とパッケージ依存" /></p>

<h3 id="rep">再利用・リリース等価の原則(Reuse-Release Equivalency Principle: REP)</h3>


<p><blockquote><p>再利用の単位とリリースの単位は等価になる</p></p><p><p></p><footer><strong>本書</strong></footer></blockquote></p>

<p>この原則は、「再利用の単位(パッケージ)はリリースの単位より小さくなることはない」ということです。裏を返せば、「リリースの単位は、パッケージごとに行う」ということです。パッケージという言葉を、Java であれば「Jar ファイル」に置き換えると分かりやすいと思います。バグの修正やバージョンアップに伴うリリースは、クラス単位ではなく、Jar ファイルの単位で行うということです。</p>

<p>この原則は、パッケージのあり方を考えさせてくれます。
　
<blockquote><p>パッケージに含まれるクラスは、すべてが再利用されるか、すべてが再利用できないかのどちらかにすべきだ。</p></p><p><p></p><footer><strong>本書</strong></footer></blockquote></p>

<p>とあるように、再利用を目的としたパッケージには、再利用できないパッケージは含めるべきではありません。例えば、「Jakarta Commons」のライブラリパッケージ(再利用可能)にドメイン固有のクラス(再利用不可能)を含めるべきでないということです。</p>

<h3 id="crp">全再利用の原則(Common Reuse Principle: CRP)</h3>


<p><blockquote><p>パッケージに含まれるクラスは、すべて一緒に再利用される。つまり、パッケージに含まれるいずれかのクラスを再利用するということは、その他のクラスのすべてを再利用するすることを意味する。</p></p><p><p></p><footer><strong>本書</strong></footer></blockquote></p>

<p>「同じパッケージに含めるクラスは、一緒に使われる傾向にある」ということを意味しています。例えば、List インターフェースと ArrayList クラスは一緒に使われる場合が非常に多いと思います。こういうものは、一緒のパッケージに入れておいたほうがよいのです。また、逆に、FileReader クラスとPreparedStatement クラスは、たぶん一緒には使わないでしょう。</p>

<dl>
<dt class="tips">Tips</dt>
<dd>互いに強い関連性を持たないクラスを同じパッケージにまとめるべきではない</dd>
</dl>




<h3 id="ccp">閉鎖性共通の原則(Common Closure Principle: CCP)</h3>


<p><blockquote><p>パッケージに含まれるクラスは、みな同じ種類の変更に対して閉じているべきである。パッケージに影響する変更はパッケージ内のすべてのクラスに影響を及ぼすが、他のパッケージには影響しない</p></p><p><p></p><footer><strong>本書</strong></footer></blockquote></p>

<p><a href="#srp" rel="external nofollow">全再利用の原則</a>は、互いに強い関連性を持つクラスは同一パッケージにするべしと言っています。強い関連性を持ったクラスというのは、同じ変更理由で修正しなければならない場合が多いので、全再利用の原則と一緒に考えるといいと思います。</p>

<h3 id="adp">非循環依存関係の原則(Acyclic Dependencies Principle: ADP)</h3>


<p><blockquote><p>パッケージ依存グラフに循環を持ち込んではならない。</p></p><p><p></p><footer><strong>本書</strong></footer></blockquote></p>

<p>クラスの依存とパッケージの依存の違いは「パッケージの依存には、推移的な依存関係はない」という点だと『<a href="http://www.amazon.co.jp/exec/obidos/ASIN/4881358642/sorehabooks-22" rel="external nofollow">インターフェース分離の原則</a>を適用したシステムであれば、パッケージ間は抽象にのみ依存するように出来ると思います。</p>

<dl>
<dt class="tips">Tips</dt>
<dd>パッケージ依存サイクルに、循環を持たせてはいけない。</dd>
</dl>




<h4>循環を断つ方法</h4>


<p>パッケージ依存循環を断ち切るためには、<a href="#dip" rel="external nofollow">依存関係逆転の法則</a> を使います。依存しているクラスへのインターフェースを自分のパッケージに作る(移動させる)ことで、依存関係を逆転できます。</p>

<h3 id="sdp">安定依存の原則(Stable Dependencies Principle: SDP)</h3>


<p><blockquote><p>安定する方向に依存せよ。</p></p><p><p></p><footer><strong>本書</strong></footer></blockquote></p>

<p>変更することを意識して作られた(不安定な)パッケージが、変更しにくい(安定している)パッケージに依存されてはいけないというのが、この原則です。</p>

<p>「安定している」とは、変更しづらいという意味です。変更しづらいというのは「他のクラスやパッケージから依存されている場合です。つまり、依存されればされるほど変更が難しくなるのです。逆に「不安定」とは、依存ばかりしているクラスやパッケージのことで、依存先が変更されると自分も変更しなければなりません。</p>

<p>安定した方向に依存せよとはつまり、抽象に依存せよということです。システムの上位レベルの設計(アーキテクチャやフレームワーク)は、安定したパッケージに配置されるべきものです。ただ、アーキテクチャやフレームワークに柔軟性を持たせたい場合もあります。例えばプラグインを付け加えたりしたい場合です。そういったときには<a href="#ocp" rel="external nofollow">オープン・クローズドの原則</a> が答えを握っています。
　
<q>実装に依存するな。抽象に依存せよ。</q></p>

<h3 id="sap">安定度・抽象度等価の原則(Stable Absstractions Principle: SAP)</h3>


<p><blockquote><p>パッケージの抽象度と安定度は同程度でなければならない。</p></p><p><p></p><footer><strong>本書</strong></footer></blockquote></p>

<p>安定度の高いパッケージは、抽象度が高くなければならないと言っています。逆に、不安定なパッケージは具体的でなければならないということです。これは、抽象度が高いクラス(インターフェース)は、変更が少ないということに起伏しています。安定したパッケージに出来るだけ変更を発生させないためには抽象的である必要があります。</p>

<h2>参考</h2>


<ul>
<li>この記事の元ネタです。オブジェクト指向設計を行うなら、本書を一度は読んでおくべし。</li>
</ul>


<div class="rakuten"><table border="0" cellpadding="5" width="400"><tr><td valign="top"><a href="http://www.amazon.co.jp/exec/obidos/ASIN/4797323361/sorehabooks-22/" rel="external nofollow"></a><br /></td></tr></table>
</div>


<ul>
<li>この本にもオブジェクト指向設計の原則に関しての解説があります。</li>
</ul>


<div class="rakuten"><table border="0" cellpadding="5" width="400"><tr><td valign="top"><a href="http://www.amazon.co.jp/exec/obidos/ASIN/4894715937/sorehabooks-22/" rel="external nofollow"></a><br /></td></tr></table>
</div>


<ul>
<li>GRASP の原則が載っています。UMLを使ったオブジェクト指向設計が良くわかります。</li>
</ul>


<div class="rakuten"><table width="400" border="0" cellpadding="5"><tr><td colspan="2"><a href="http://www.amazon.co.jp/exec/obidos/ASIN/4894713861/sorehabooks-22/" rel="external nofollow">G-Tools</a></font><br /></td></tr></table></div>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[テストはソフトウェア設計である]]></title>
    <link href="http://hamasyou.com/blog/2004/07/14/4797323361/"/>
    <updated>2004-07-14T17:18:00+09:00</updated>
    <id>http://hamasyou.com/blog/2004/07/14/4797323361</id>
    <content type="html"><![CDATA[<p>
<a href="http://www.amazon.co.jp/exec/obidos/ASIN/4797323361/sorehabooks-22" rel="external nofollow"></a>
</p>


<p>「アジャイルソフトウェア開発の奥義」を読み始めました。最近では、ソフトウェアエンジニアに馴染みが深くなってきた「アジャイル」という言葉ですが目からウロコです。僕は本を読むとすぐに影響されてしまう性質で、哲学書とか開発手法に関する本とかを読むとすぐにやってみたくなってしまう人です。それでも最近は、色々な視点から考えることもできるようになってきたと思いますが・・・。</p>

<p>まだこの本は全部読みきっていないので、書評はまた後で書きます。今は本書を読んで心に残ったことをメモっておきます。( ..)φメモメモ</p>

<p>とりあえず、テストファーストに関してのメモです。テストファーストという言葉をきくとワクワクしてくるのは僕だけじゃないはず・・・。テスト、最高です！</p>

<!-- more -->




<h2>テストはソフトウェア設計である</h2>


<p>XPなんかの開発プロセスで有名な「テストファースト」という言葉。ソースコードを書く前にテストコードを書くというものですが、テストコードは何のために書くのか？本書でテスティングに関して述べられていて、非常に共感がもてました。<strong>テストはソフトウェア設計である。</strong></p>

<p>テストファーストの利点に、テストを最初に書くことですべてのソースコードを検証した証明になるというものがあります。確かに共感できるのですが、これだけの利点ではあまりテストファーストを好きになれませんでした。しかし、本書でもっと重要な利点に気づきました。以下抜粋</p>

<p><blockquote><p><b>テストを最初に書くことによって、これまでとは違った視点で物事を見ざるを得なくなる</b>ということだ。テストを書こうとすれば、呼び出す側の立場でプログラムを見るようになる。したがって、<b>早い段階からプログラムの機能だけでなくインターフェースに注意を払うようになる。</b>テストを最初に書くことは、ソフトウェアを<b>呼び出しやすい形式</b>に設計することにつながるのだ。</p></p><p><p></p><footer><strong>本書</strong></footer></blockquote></p>

<p>テストファーストを実践することで、プログラムの呼び出しインターフェースを設計する必要が出てくる。また、テスト可能であるためには、周辺のコードから独立でなければならないため<b>独立性を高める</b>必要がある。これらを行うことで、個々のプログラムが独立し、わかりやすいソースコードになることにつながると思うと、テストという行為がとてもワクワクしたものになってきます。</p>

<p>もうひとつ、テストを行う利点にテストコードが生きたドキュメントになるというものがありました。メソッドの呼び出し方法やインスタンスの作り方を実際のソースコードが教えてくれる。しかもそれは常に最新であるということは、ドキュメント地獄の開発よりも何倍も楽しいものだと思います。</p>

<p>テストファーストという考えを持つと、リファクタリングをスムーズに受け入れることができるのかなと思いました。テストケースを書き、テストをパスするようにコーディングをした後ですぐにそのコードをリファクタリングしてきれいにする。常にソースコードをきれいに保つことがアジャイルの極意だと思いました。</p>

<p>まだまだ、最初の方しか読んでないですが、開発者にとって役立つことばかり載っている気がします。本書はとてもすばらしいと思います。</p>

<h2>参考</h2>


<ul>
<li>はっきり言って最高の本です。一緒に開発を行う人にも是非勧めたいです。</li>
</ul>


<div class="rakuten"><table border="0" cellpadding="5" width="400"><tr><td valign="top"><a href="http://www.amazon.co.jp/exec/obidos/ASIN/4797323361/sorehabooks-22/" rel="external nofollow"></a><br /></td></tr></table>
</div>



]]></content>
  </entry>
  
</feed>
