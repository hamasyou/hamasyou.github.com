<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: iOS | それはBooks]]></title>
  <link href="http://hamasyou.com/blog/tags/ios/atom.xml" rel="self"/>
  <link href="http://hamasyou.com/"/>
  <updated>2014-07-08T12:15:42+09:00</updated>
  <id>http://hamasyou.com/</id>
  <author>
    <name><![CDATA[hamasyou]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Apple Swift プログラミング言語おぼえがき]]></title>
    <link href="http://hamasyou.com/blog/2014/06/26/apple-swift/"/>
    <updated>2014-06-26T08:00:55+09:00</updated>
    <id>http://hamasyou.com/blog/2014/06/26/apple-swift</id>
    <content type="html"><![CDATA[<p>Apple が新しいプログラミング言語 <strong>Swift</strong> を2014年の WWDC で発表しました。言語仕様自体は色々なモダンプログラミング言語のいいとこ取りのような感じです。独特な仕様もいくつかあるのでおぼえがきしておきます。</p>

<p>なお、Swift で作成したアプリは iOS8 と OS X Yosemite がリリースされた時点で審査に入れるようです。</p>

<p><a href="https://developer.apple.com/swift/">Introducing Swift</a></p>

<p>※ Xcode6 Beta3 を元に記載しています。</p>

<!-- more -->




<div id="toc"></div>


<h2>The Basics</h2>

<p><code>NSLog</code> の代わりに <code>println</code> が使える。Xcode のコンソールにも表示される。文字列の変数展開は <code>\()</code> を使う。</p>

<pre><code class="swift">let name = "hamasyou"
println("Hello \(name)")  // Hello hamasyou
</code></pre>

<h3>基本型</h3>

<p><code>Int</code>、<code>Double</code>、<code>Float</code>、<code>Bool</code>、<code>String</code>、<code>Array</code>、<code>Dictionary</code> などが用意されている。<code>Int16</code> や <code>UInt8</code> などもある。型の変換は <code>型名()</code> を使う。</p>

<p>Swift では <code>nil</code> を特別な値として定義している。<code>Bool</code> 値は <code>true</code> と <code>false</code>。条件式では <code>Bool</code> 値のみが使える。</p>

<pre><code class="swift">UInt8.max   // 255
UInt8.min   // 0

let three = 3
let floatValue = 0.14159
let pi = Double(three) + floatValue // 3.14159
let integerPi = Int(pi) // 3

if pi {
    // この文法はコンパイルエラーになる。正しくは↓
}

if pi == 3.14159 {
}
</code></pre>

<p>タプルも使える。不要な値を受け取るときは <code>_</code> を使う。</p>

<pre><code class="swift">let httpError = (404, "Not Found")
httpError.0   // 404
httpError.1   // "Not Found"

let otherError = (errorCode: 500, errorMessage: "Internal Server Error")
otherError.errorCode    // 500
otherError.errorMessage // "Internal Server Error"

let (code, msg) = httpError
code  // 404
msg   // "Not Found"

let (_, msg2) = otherError
msg2  // "Internal Server Error"
</code></pre>

<p>配列は <code>[Int]</code> のように記述する。</p>

<pre><code class="swift">let ary: [Int] = [10, 20, 30]
</code></pre>

<h3>リテラルと変数</h3>

<p>Swift ではリテラルの定義は <code>let</code> を使い、変数の定義は <code>var</code> を使う。<code>let</code> で定義したリテラルは変更できない。</p>

<pre><code class="swift">let myName = "hamasyou"
let π = 3.14
var x = 0.0, y = 0.0, z = 0.0
x = 3.0
</code></pre>

<p>文字列を数値に直すのに <code>toInt</code> メソッドが使える。この時返される値は <code>Int</code> 型でなく、<code>Int?</code> 型なので注意。</p>

<pre><code class="swift">let str = "123"
let num = str.toInt()   // num は Int? か Optional Int として型推論される
</code></pre>

<p>if 文の条件式には <code>Bool</code> しか記述できないが、この、<code>型 + ?</code> の形式で表される <code>Optional 型</code> も if 文の式に記述できる。この場合値が nil ではない場合に <code>true</code> と評価される。</p>

<pre><code class="swift">var str = "123"
var num = str.toInt()

if num {
    println("\(str) is number of \(num!)")
}
</code></pre>

<p>このように、Swift では <code>nil</code> を返す可能性があるメソッドの戻り値の型は <code>Optional 型</code> になる。<code>Optional 型</code> から値を取り出すには <code>!</code> をつける。但し、nil が入っている変数から値を取り出そうとするとランタイムエラーになる。</p>

<pre><code class="swift">str = "abc"
num = str.toInt()

println(num!)   // これはランタイムエラーになるので、必ず下の様に呼び出す

if !num {
    println("\(str) is not number")
}
</code></pre>

<p>Optional 型から値を取り出す方法に、<code>!</code> をつける以外に次のようにも書ける。（Optional Binding）</p>

<pre><code class="swift">let str = "123"
let expectNum = str.toInt()
if let actual = expectNum {
    println(actual)
}
</code></pre>

<h3>Implicity Unwrapped Optionals</h3>

<p>Swift は Objective-C の nil ポインタとは違う <code>nil</code> を採用している。nil が格納される可能性がある変数は Optional 型として定義する必要がある。</p>

<p>Optional 型の変数から値を取り出すには <code>!</code> を使う。必ず値が入っている確証が持てる場合は <code>型名 + !</code> の形で記述することもできる。値が入っていない時に <code>!</code> を使うとランタイムエラーがでるので注意。</p>

<pre><code class="swift">var optioanValue: Int?   // Optional 型の変数は nil で初期化される

let str = "123"
let num: Int! = str.toInt()
num   // num は 123 が入る Int! で定義しない場合は型推論によって Int? 型の Wrapped Value が入っているので 123 ではない
</code></pre>

<h3>Range</h3>

<p><code>(a..&lt;b)</code>、<code>(a...b)</code> の形で範囲を求めることができる。<code>(a..&lt;b)</code> は b を含まない。Ruby とは逆の動きをする。</p>

<pre><code class="swift">for i in (0 ..&lt; 3) {
    println(i)    // 0, 1, 2
}
</code></pre>

<p>Xcode6 Beta3 から終端を含まない範囲を <code>..&lt;</code> で表すようになった。</p>

<h2>String And Character</h2>

<p><code>String</code> は <code>NSString</code> が使われているところでも使える。String は <code>Character</code> のコレクション型である。</p>

<pre><code class="swift">let str = "Hello World"
let c: Character = "!"

let s = str + c

str.isEmpty             // false
str.hasPrefix("Hello")  // true
str.hasSuffix("World")  // true
</code></pre>

<h2>Collection Types</h2>

<h3>Array</h3>

<p>Swift の配列は <code>Array</code> 型。<code>Array&lt;SomeType&gt;</code> で表す。略語として <code>型名[]</code> の形式も使える。<code>NSArray</code>、<code>NSMutableArray</code> が使われているところでも使える。</p>

<pre><code class="swift">var list = ["Hello", "World", "Good"]
list.count
list += "Nice"      // ["Hello", "World", "Good", "Nice"]
list.removeLast()   // "Nice"

var stringList: String[]?             // nil
var anyList: Array&lt;AnyObject&gt;?        // nil
var stringList2: Array&lt;String&gt; = []   // empty String array
</code></pre>

<h3>Dictionary</h3>

<p>Swift の Hash は <code>Dictionary</code> 型。<code>Dictionary&lt;KeyType, ValueType&gt;</code> で定義する。<code>NSDictionary</code>、<code>NSMutableDictionary</code> が使われているところでも使える。</p>

<pre><code class="swift">var airports = ["TYO": "Tokyo", "DUB": "Dublin"]
// var airports: Dictionary&lt;String, String&gt; = ["TYO": "Tokyo", "DUB": "Dublin"] とも書ける
airports.count
airports["OSK"] = "OSAKA"
airports["HOGE"]    // nil
airports.keys       // ["TYO", "DUB", "OSK"]
airports.values

for (code, name) in airports {
}

var dict: Dictionary&lt;String, String&gt;?             // nil
var emptyDict = Dictionary&lt;String, String&gt;()      // empty Dictionary 
var emptyDict2: Dictionary&lt;String, String&gt; = [:]  // empty Dictionary
</code></pre>

<h2>Functions</h2>

<p>関数は <code>func メソッド名(引数: 型) -&gt; 戻り値の型</code> の形で書く。戻り値が必要ない場合は省略するか、<code>Void</code> を記述する。</p>

<p>Swift の関数（メソッド）は <em>第一級関数</em> なので、変数や引数に渡すことができる。</p>

<pre><code class="swift">func hello(name: String, greet: String) -&gt; String {
    return "Hello \(name), \(greet)"
} 
println(hello("hamasyou", "Good Morning"))

func sayHello(name: String) -&gt; Void {
    println("Hello \(name)")
}
sayHello("hamasyou")
</code></pre>

<p>戻り値にはタプルを指定することもできる。</p>

<pre><code class="swift">func count() -&gt; (vowels: Int, consonants: Int, others: Int) {
    var n1 = 3, n2 = 5, n3 = 10
    return (n1, n2, n3)
}

let ret = count()
ret.vowels
ret.consonants
ret.others
</code></pre>

<h3>External Parameter Names</h3>

<p>関数呼び出し時にキーワード引数として呼び出す名前を指定できる。</p>

<pre><code class="swift">func someFunction(externalParameterName localParameterName: Int) {
    var total = 10 + localParameterName
}
someFunction(externalParameterName: 5)

func join(s1: String, s2: String, withJoiner joiner: String) -&gt; String {
    return s1 + joiner + s2
}
join("Hello", "World", withJoiner: "-")
</code></pre>

<p><code>externalParameterName</code> と <code>localParameterName</code> を同じにしたいときは、<code>#</code> を使う。</p>

<pre><code class="swift">func(containsCharacter(#string: String, #characterToFind: Character) -&gt; Bool {
    for character in string {
        if character == characterToFind {
            return true
        }
    }
    return false
}
</code></pre>

<p>引数にデフォルト値を指定することもできる。デフォルト値を指定して、externalParameterName を指定しないときは、localParameterName が externalParameterName になる。</p>

<pre><code class="swift">func join(s1: String, s2: String, joiner: String = "-") -&gt; String {
    return s1 + joiner + s2
}
join("Hello", "World", joiner: " ")    
</code></pre>

<p><code>_</code> を externalParameterName に指定すれば、デフォルト値を設定しても呼び出し時に externalParameterName を指定する必要はなくなる。</p>

<pre><code class="swift">func join(s1: String, s2: String, _ joiner: String = "-") -&gt; String {
    return s1 + joiner + s2
}
join("Hello", "World", " ")
</code></pre>

<h3>In-Out Parameters</h3>

<p>関数の引数は定数（<code>let</code>）として渡される。引数を変数（<code>var</code>）として渡したい場合は、引数名の前に <code>var</code> をつける。</p>

<p>var をつけて引数を定義しても、変更の影響を受けるのは関数の中だけ。関数の外の変数にも影響を及ぼしたい場合には <code>inout</code> をつけて引数を定義して、引数を渡すときに <code>&amp;</code> を使う。</p>

<pre><code class="swift">func swap(inout s1: String, inout s2: String) {
    let tmp = s1
    s1 = s2
    s2 = tmp
}

var s1 = "Hello"
var s2 = "World"
swap(&amp;s1, &amp;s2)
s1    // "World"
s2    // "Hello"
</code></pre>

<h2>Closures</h2>

<p>Swift の Closure は次の点が最適化されている。</p>

<ul>
<li>引数と戻り値の型が推論される</li>
<li>Closre Body が単一式の場合はそれが暗黙の戻り値になる</li>
<li>引数を略式で書ける</li>
<li>Closure を最後の引数として取るメソッドの場合、Closure を <code>()</code> の外側に書くことができる</li>
</ul>


<pre><code class="swift Closure Syntax">{ (parameters) -&gt; returnType in
    statements
}
</code></pre>

<pre><code class="swift Closure syntaxes">let names = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]
sort(names, { (s1: String, s2: String) -&gt; Bool in
    return s1 &lt; s2
})

sort(names, { (s1: String, s2: String) -&gt; Bool in return s1 &lt; s2 })
sort(names, { s1, s2 in return s1 &lt; s2 })
sort(names, { s1, s2 in s2 &lt; s2 })
sort(names, { $0 &lt; $1 })
sort(names) { $0 &lt; $1 }  
</code></pre>

<pre><code class="swift map sample">let digitNames = [
    0: "Zero", 1: "One", 2: "Two",   3: "Three", 4: "Four",
    5: "Five", 6: "Six", 7: "Seven", 8: "Eight", 9: "Nine"
]
let numbers = [16, 58, 510]
let strings = numbers.map { (var num) -&gt; String in
    var output = ""
    while num &gt; 0 {
        output = digitNames[num % 10]! + output
        num /= 10
    }
    return output
}
strings
</code></pre>

<pre><code class="swift Closure sample">func makeIncrementor(forIncrement amount: Int) -&gt; (() -&gt; Int) {
    var runningTotal = 0
    func incrementor() -&gt; Int {
        runningTotal += amount
        return runningTotal
    }
    return incrementor
}

let incrementByTen = makeIncrementor(forIncrement: 10)
incrementByTen()    // 10
incrementByTen()    // 20
incrementByTen()    // 30
</code></pre>

<h2>Enumerations</h2>

<p>Swift では <code>Enumeration</code> も first-class type である。Swift ではデフォルト値を設定しない限り、自動で 0, 1, 2 の様な値がふられることはない。</p>

<pre><code class="swift">enum CompassPoint {
    case North
    case South
    case East
    case West
}
CompassPoint.North

enum Numbers: Int {
    case Zero = 0, One, Two, Three, Four, Five, Six, Seven, Eight, Nine
}
Numbers.Four.toRaw()                // 4
Numbers.fromRaw(7) == Numbers.Seven // true 
</code></pre>

<h3>Associated Values</h3>

<p>Swift の enumerations は関連する値を保持することができる。</p>

<pre><code class="swift">enum Barcode {
    case UPCA(Int, Int, Int)
    case QRCode(String)
}

let productBarcode = Barcode.UPCA(8, 85900_51226, 3)
switch productBarcode {
case let .UPCA(numberSystem, identifier, check):
    println("UPC-A with value of \(numberSystem), \(identifier), \(check).")
case let .QRCode(productCode):
    println("QR code with value of \(productCode).")
} 
</code></pre>

<h2>Classes and Structures</h2>

<p>Swift では、クラスと構造体はほぼ同じ物と考えることができる。構造体は参照ではなく copy value で管理される。</p>

<p><blockquote><p>Unlike value types, reference types are not copied when they are assigned to a variable or constant, or when they are passed to a function. Rather than a copy, a reference to the same existing instance is used instead.</p><footer><strong>Classes Are Reference Types</strong></footer></blockquote></p>

<h4>クラスと構造体の共通点</h4>

<ul>
<li><strong>プロパティ</strong> を定義することができる</li>
<li><strong>メソッド</strong> を定義することができる</li>
<li><strong>subscripts</strong> （配列の<code>[0]</code> のようにアクセスできる仕組み）を提供することができる</li>
<li><strong>イニシャライザ</strong> （コンストラクタ）を定義することができる</li>
<li>デフォルトの振る舞いを拡張することができる</li>
<li><strong>protocol</strong> を使うことができる</li>
</ul>


<h4>クラスだけがもつ機能</h4>

<ul>
<li><strong>継承</strong></li>
<li>タイプキャストが可能</li>
<li><strong>デイニシャライザ</strong> （デストラクタ）を定義することができる</li>
<li>ひとつ以上の参照カウントが許される（構造体は copy-value、クラスは reference）</li>
</ul>


<pre><code class="swift syntax">struct Resolution {
    var width = 0
    var height = 0
}

class VideoMode {
    var resolution = Resolution()
    var interlaced = false
    var frameRate = 0.0
    var name: String?
}
let someResolution = Resolution()
let someVideoMode = VideoMode()
someVideoMode.resolution.width = 1280
</code></pre>

<p>Objective-C とは違って、参照をたどって直接値を設定することも可能。</p>

<p>構造体は、暗黙のイニシャライザを使って、プロパティを初期化することが可能。クラスはイニシャライザを明示的に定義しなければいけない。</p>

<pre><code class="swift">let rvga = Resolution(width: 640, height: 480)
</code></pre>

<h3>クラスと構造体のどちらを選ぶか</h3>

<ul>
<li>構造体を使う一番の理由は関係する値をまとめるため</li>
<li>プロパティのデータを何かしら処理する場合には、クラスの方がいいかも</li>
</ul>


<h3>Array と Dictionary</h3>

<p>Swift の Array と Dictionary は構造体の様に振舞う。</p>

<p>Dictionary は変数に割り当てられる際にコピーされる。Key/Value の Value がさらに Dictionary の場合はそれもコピーされる。</p>

<pre><code class="swift">var ages = ["Peter": 23, "Wei": 35, "Anish": 65, "Katya": 19]
var copiedAges = ages
ages["Peter"] = 24    // 24
copiedAges["Peter"]   // 23
</code></pre>

<p>Xcode6 Beta3 からは、Array の動作も Dictionary と同じ動きをする。つまり、値がコピーされる。</p>

<pre><code class="swift">var nums = [10, 20, 30, 40]
var otherNums = nums

nums[0] = 50
otherNums[0]    // 50

nums += 100     // occure copy, nums is [50, 20, 30, 40, 100]
nums[0] = 10    // nums is [10, 20, 30, 40, 100]
otherNums[0]    // 50, otherNums is [50, 20, 30, 40]
</code></pre>

<p>Array で参照を切りたいときは <code>unshare()</code> メソッドを使う。変数への割り当て時に強制的にコピーしたいときは <code>copy()</code> メソッドを使う。</p>

<h2>Properties</h2>

<h3>Lazy Stored Properties</h3>

<p>最初にアクセスされるまで初期化されないようにするには、<code>@lazy</code> を使用する。変数（var）で定義するプロパティには @lazy をつけるようにするといい。</p>

<p><blockquote><p>You must always declare a lazy property as a variable (with the var keyword), because its initial value may not be retrieved until after instance initialization completes. Constant properties must always have a value before initialization completes, and therefore cannot be declared as lazy.</p><footer><strong>Lazy Stored Properties</strong></footer></blockquote></p>

<pre><code class="swift">class DataManager {
    @lazy var importer = DataImporter()   // DataImporter is assumed to take a non-trivial amount of time to initialize.
}
</code></pre>

<h3>Computed Properties</h3>

<p><code>center</code> プロパティが Computed Property になる。<code>set</code> で受け取る引数は明示してもいいし、明示しない場合は <code>newValue</code> で受け取れる。</p>

<pre><code class="swift">struct Rect {
    var origin = Point()
    var size = Size()
    var center: Point {
    get {
        let centerX = origin.x + (size.width / 2)
        let centerY = origin.y + (size.height / 2)
        return Point(x: centerX, y: centerY)
    }
    set {
        origin.x = newValue.x - (size.width / 2)
        origin.y = newValue.y - (size.height / 2)
    }
    }
}
</code></pre>

<h3>Property Observers</h3>

<p><code>willSet</code>, <code>didSet</code> を使うと、プロパティが設定されるまえ、設定された後にコールバックを受け取ることができる。これらのコールバックは初期化時にはよばれない。</p>

<pre><code class="swift">class StepCounter {
    var totalSteps: Int = 0 {
    willSet(newTotalSteps) {
        println("About to set totalSteps to \(newTotalSteps)")
    }
    didSet {
        if totalSteps &gt; oldValue  {
            println("Added \(totalSteps - oldValue) steps")
        }
    }
    }
}
let stepCounter = StepCounter()
stepCounter.totalSteps = 200
// About to set totalSteps to 200
// Added 200 steps
</code></pre>

<h2>Methods</h2>

<p>メソッドにも関数と同じく <code>externalParameterName</code> と <code>localParameterName</code> を指定できる。メソッドの場合は関数と違って、externalParameterName と localParameterName の定義の振る舞いが違う。</p>

<p>メソッドは最初の引数の externalParameterName は、localParameterName と同じになり、呼び出し時は最初の引数の externalParameterName は省略できる。</p>

<pre><code class="swift">class MyClass {
    func hello(name: String, greet: String) -&gt; String {
        return "Hello \(name) \(greet)"
    }
}

let obj = MyClass()
obj.hello("hamasyou", greet: "Good Morning")
</code></pre>

<p>第二引数以降の呼び出しで externalParameterName を指定したくない場合は <code>_</code> を使う。</p>

<pre><code class="swift">class MyClass {
    func hello(name: String, _ greet: String) -&gt; String {
        return "Hello \(name) \(greet)"
    }
}

let obj = MyClass()
obj.hello("hamasyou", "Good Night")
</code></pre>

<h3>Modifying Value Types from Within Instance Methods</h3>

<p>構造体と Enumerations はデフォルトでメソッドの中からプロパティの変更を行うことができない。変更できるようにするには <code>mutating</code> でメソッドを修飾する。</p>

<pre><code class="swift">struct Point {
    var x = 0.0, y = 0.0
    mutating func moveByX(deltaX: Double, y deltaY: Double) {
        x += deltaX
        y += deltaY
    }
}
</code></pre>

<h2>Subscripts</h2>

<p>Subscript はコレクションにアクセスするための略式を定義するもの。クラスや構造体、Enumeration に定義できる。定義すると <code>[0]</code> などでアクセスできるようになる。</p>

<p><code>subscript</code> の引数は複数指定することもできる。</p>

<pre><code class="swift">subscript(index: Int) -&gt; Int {
    get {
        // return an appropriate subscript value here
    }
    set(newValue) {
        // perform a suitable setting action here
    }
}
</code></pre>

<h2>Inheritance</h2>

<p>メソッドやプロパティのオーバーライドには <code>override</code> キーワードを使用する。override されたくないメソッドやプロパティには <code>@final</code> を指定する。</p>

<h2>Initialization</h2>

<p>イニシャライザは <code>init</code> で定義する。イニシャライザに引数を指定する場合、externalPropertyName を指定しなければ暗黙で localPropertyName が externalPropertyName に指定される。</p>

<p>メソッドと違い、<em>イニシャライザの呼び出し時には全ての externalPropertyName の指定が必要</em>。</p>

<pre><code class="swift">struct Color {
    let red = 0.0, green = 0.0, blue = 0.0
    init(red: Double, green: Double, blue: Double) {
        self.red   = red
        self.green = green
        self.blue  = blue
    }
}
let magenta = Color(red: 1.0, green: 0.0, blue: 1.0)
</code></pre>

<h3>Designated Initializers and Convenience Initializers</h3>

<p><code>Designated Initializer</code> はインスタンスの初期化の目的で定義される。<code>Convenience Initializer</code> は Designated Intitializer を呼び出す際のデフォルト値などを設定する目的で使う。</p>

<pre><code class="swift">class MyClass {
    var name: String
    init(name: String) {
        self.name = name
    }

    convenience init() {
        self.init(name: "hamasyou")
    }
}
let me = MyClass()
</code></pre>

<h2>Type Casting</h2>

<p>型チェックには <code>is</code> を使う。</p>

<pre><code class="swift">for item in library {
    if item is Movie {
        // execute movie logic
    }
}    
</code></pre>

<p>ダウンキャストに <code>as</code> が使える。Optional Type の場合は <code>as?</code> を使う。Dictionary とかから値を取り出すときに使える。</p>

<pre><code class="swift">for item in library {
    if let movie = item as? Movie {
        println("Movie: '\(movie.name)', dir. \(movie.director)")
    } else if let song = item as? Song {
        println("Song: '\(song.name)', by \(song.artist)")
    }
}
</code></pre>

<p>配列の型に <code>AnyObject</code> を使うと、利用時にキャストが必要だが何の型か指定しなくても入れれるようになる。</p>

<pre><code class="swift">let someObjects: AnyObject[] = [
    Movie(name: "2001: A Space Odyssey", director: "Stanley Kubrick"),
    Movie(name: "Moon", director: "Duncan Jones"),
    Movie(name: "Alien", director: "Ridley Scott")
]
for object in someObjects {
    let movie = object as Movie
    println("Movie: '\(movie.name)', dir. \(movie.director)")
}
</code></pre>

<p>配列の型に <code>Any</code> を使うと、なんでもいれれるようになる。</p>

<pre><code class="swift">var things = Any[]()

things.append(0)
things.append(0.0)
things.append(42)
things.append(3.14159)
things.append("hello")
things.append((3.0, 5.0))
things.append(Movie(name: "Ghostbusters", director: "Ivan Reitman"))

for thing in things {
    switch thing {
    case 0 as Int:
        println("zero as an Int")
    case 0 as Double:
        println("zero as a Double")
    case let someInt as Int:
        println("an integer value of \(someInt)")
    case let someDouble as Double where someDouble &gt; 0:
        println("a positive double value of \(someDouble)")
    case is Double:
        println("some other double value that I don't want to print")
    case let someString as String:
        println("a string value of \"\(someString)\"")
    case let (x, y) as (Double, Double):
        println("an (x, y) point at \(x), \(y)")
    case let movie as Movie:
        println("a movie called '\(movie.name)', dir. \(movie.director)")
    default:
        println("something else")
    }
}
</code></pre>

<h2>Extensions</h2>

<p>既存のクラス、構造体、Enumeration に機能を追加できる。</p>

<pre><code class="swift">extension SomeType: SomeProtocol, AnotherProtocol {
    // implementation of protocol requirements goes here
}

extension Double {
    var km: Double { return self * 1_000.0 }
    var m: Double { return self }
    var cm: Double { return self / 100.0 }
    var mm: Double { return self / 1_000.0 }
    var ft: Double { return self / 3.28084 }
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[iOS] Game Center を使った対戦プログラミングの手順メモ]]></title>
    <link href="http://hamasyou.com/blog/2011/08/04/iosgame-center/"/>
    <updated>2011-08-04T11:38:00+09:00</updated>
    <id>http://hamasyou.com/blog/2011/08/04/iosgame-center</id>
    <content type="html"><![CDATA[<p>iOS 4.1 から、正式に <em>Game Center</em> が使えるようになりました。Game Center を使うと、ゲームに簡単に対戦やスコア、達成目標などの機能を追加できます。</p>

<p><blockquote><p>Game Centerは、プレー中のゲームについての情報をプレーヤー同士で共有したり、ほかのプレー ヤーと一緒にマルチプレーヤー対戦に参加できるソーシャルゲーミングサービスです。Game Center は、ワイヤレスネットワークと携帯電話ネットワークのどちらからでもサービスを提供できます。 Game Centerの主な機能は、次の通りです。</p></p><p><ul><li><em>認証</em> - プレーヤーはGame Centerでセキュアなアカウントを作成し、iOSベースのデバイスでGame Centerにアクセスできます。</li><br/><li><em>友だち</em> - プレーヤーはGame Centerのほかのプレーヤーを友だちとして登録できます。友だちは、最近遊んだゲームなどプレーヤーの詳細情報を確認できます。</li><br/><li><em>Leaderboard</em> - プレーヤーのスコアをGame Centerに記録したりGame Centerから取得したりできます。<br/><li><em>アチーブメント(Achievement、成績)</em> - そのゲームでのプレーヤーのアチーブメントを管理します。アチーブメントは、Game Centerサービスに記録され、Game Centerアプリケーションとゲームの中で閲覧できます。</li><br/><li><em>オートマッチ</em> - Game Centerを介して複数のプレーヤーとつながるネットワークゲームを作成できます。プレーヤーは友だちを招待したり、まだ会ったことのないプレーヤーと接続して対戦できます。プレーヤーは、ゲームを実行していないときでも対戦への招待を受信できます。その場合、ゲームが自動的に起動し、招待が処理されます。</li><br/><li><em>ボイス</em> - 対戦に接続されたプレーヤー間で音声通信を行うことができます。</li></ul></p><p><br/><p></p><footer><strong>『Game Kit プログラミングガイド』より</strong></footer></blockquote></p>

<p>Game Center を使うためのプログラミングは形式的ながら、視点が二つ（自分と対戦相手）あるため、どの機能が何に当たるのかを理解していないと混乱しがちです。</p>

<p>本記事は、自分で Game Center を使ったアプリを作ったときの、メモをまとめたものです。</p>

<p><section></p>

<h4>開発時の環境</h4>




<dl><dt>iOS SDK バージョン</dt><dd>4.3</dd>
<dt>クライアント iOS バージョン</dt><dd>自分: iOS 4.3.2 &nbsp;&nbsp;対戦相手: iOS 4.3.5</dd></dl>


<p></section></p>

<!-- more -->




<h2>Game Center を使った対戦機能開発のメモ</h2>


<p>Game Center を使ったアプリの開発手順は、<a href="http://developer.apple.com/jp/devcenter/ios/library/documentation/GameKit_Guide.pdf" rel="external nofollow">『Game Kit プログラミングガイド』</a> - Apple Developer（PDF）に詳しく載っています。わかりやすい説明で読めば大体理解できると思います。対戦相手とのマッチングの部分だけ、自分と相手がいるのと、非同期で処理がされていくためどのメソッドがどの役割かが最初は混乱するかもしれません。</p>

<p>Leaderboard とアチーブメントはたぶん、そんなに混乱しないはず。</p>

<h2>用語のまとめ</h2>




<dl>
<dt>プレイヤー</dt>
<dd>
<p>Game Center でプレイヤーとは、<strong>GKPlayer</strong> クラスで表される Game Center で認証されたユーザのことを指します。GKPlayer インスタンスの <em>alias</em> プロパティでプレイヤーのニックネームを取得できます。</p>

<p>端末上で認証したプレイヤーのこと（自分自身）を特に <strong>GKLocalPlayer</strong> クラスで表します。GKLocalPlayer からは友だちの一覧などの情報を取得できます。</p>
</dd>
<dt>マッチメイク</dt>
<dd>
<p>対戦相手を探す機能のことです。対戦相手は友だちへのゲーム招待（相手に PUSH 機能で通知がいく）と自動マッチングで探すことができます。</p>

<p>当然ですが、一つのアプリで、招待機能（<em>Request</em>）と招待受理機能（<em>Invite</em>）を実装する必要があります。</p>
</dd>
<dt>GKMatchRequest</dt>
<dd><p>対戦相手を探す際の対戦要求を表すクラス。対戦相手の人数など、細かな条件を設定できます。</p></dd>
<dt>GKInvite</dt>
<dd><p>対戦要求によって招待されたことをあわらすクラスです。</p></dd>
<dt>GKMatch</dt>
<dd><p>マッチングされたネットワークセッションを表すクラスです。このオブジェクトに対してデータを送ることで、通信相手にデータが届きます。</p></dd>
</dl>




<h2>Game Center を使ったプログラミングの手順</h2>


<p>Game Center を使ったプログラミングの流れは次のようになります。</p>

<ol>
<li>Game Center が利用可能かどうかを確認する。一度確認すればよい。[<a href="#title4" rel="external nofollow">コード</a>]</li>
<li>アプリケーション起動時に、できるだけはやく Game Center への認証を済ませる。これは、その後のゲーム招待を処理するために必要。[<a href="#title5" rel="external nofollow">コード</a>]</li>
<li>認証が済んだら、ゲーム招待を処理するハンドラを登録する。<em>ゲーム招待を受理してアプリが起動された場合はアプリのトップ画面が表示されるので、アプリのトップで Game Center の認証を行い、続けてゲーム招待を処理するハンドラを登録するべき。</em>そうしないと、せっかくの招待が無駄になる。[<a href="#title6" rel="external nofollow">コード</a>]</li>
<li>自分で対戦要求を作成する場合は、<strong>GKMatchRequest</strong> を作成してマッチメイク画面を開く。招待された側は、ゲーム招待処理ハンドラが呼び出されて、ゲーム招待（<strong>GKInvite</strong>）を利用してマッチメイク画面を開く。[<a href="#title7" rel="external nofollow">コード</a>]</li>
<li>自分で対戦相手を探す場合は、対戦要求を作成する。[<a href="#title8" rel="external nofollow">コード</a>]</li>
<li>対戦相手が決まったら、コールバックメソッドを実装して対戦を開始する。[<a href="#title9" rel="external nofollow">コード</a>]</li>
<li>対戦相手を自動で決める場合は <strong>GKMatchmaker</strong> の findMatchForRequest メソッドを利用する。（後で書く）</li>
<li>対戦が開始されたら、<strong>GKMatch</strong> に対してデータを送ることで通信ができる。[<a href="#title10" rel="external nofollow">コード</a>]</li>
<li>通信を受け取るには、<strong>GKMatchDelegate</strong> プロトコルを実装し、GKMatch の delegate に設定する。[<a href="#title11" rel="external nofollow">コード</a>]</li>
</ol>




<h2>プログラミングコードの断片</h2>




<h3>Game Center が利用出来るかどうか</h3>


<p>SDK が Game Center に対応しているか（GKLocalPlayer クラスが参照できるかで確認）と iOS が 4.1 以降であるかを確認する。</p>

<p>Game Center が利用出来るかどうかは、最初の一度だけ行えば良い。すなわち、メンバ変数にキャッシュできる。以降、gameCenterAvailable 変数がそれ。</p>

<pre><code class="objective-c">- (BOOL)isGameCenterAvailable
{
  // Test for Game Center availability
  Class gameKitLocalPlayerClass = NSClassFromString(@"GKLocalPlayer");
  BOOL localPlayerAvailable = (gameKitLocalPlayerClass != nil);

  // Test if device is running iOS 4.1 or higher
  NSString *requireSysVer = @"4.1";
  NSString *currentSysVer = [[UIDevice currentDevice] systemVersion];
  BOOL isOSVer41 = ([currentSysVer compare:requireSysVer options:NSNumericSearch] != NSOrderedAscending);

  return localPlayerAvailable &amp;&amp; isOSVer41;
}
</code></pre>

<h3>Game Center の認証</h3>


<p>authenticateWithCompletionHandler メソッドで Game Center を使って認証できる。認証済みでない場合は、認証ダイアログが表示される。</p>

<p>認証が済んだら、できるだけはやくゲーム招待を処理するためのハンドラを登録する。</p>

<pre><code class="objective-c">- (void)authenticateLocalPlayer
{
  if (gameCenterAvailable) {
    GKLocalPlayer *localPlayer = [GKLocalPlayer localPlayer];
    if (!localPlayer.authenticated) {
      [localPlayer authenticateWithCompletionHandler:^(NSError *error) {
        self.error = error

        if (error == nil) {
          // ゲーム招待を処理するためのハンドラを設定する
          [self initMatchInviteHandler];
        }
      }];
    }
  }
}
</code></pre>

<h3>ゲーム招待を処理するハンドラを登録する</h3>


<p><strong>GKMatchmaker</strong> の inviteHandler にブロックを渡すことで、招待が処理された際にコールバックされるようになる。</p>

<p><blockquote><p></p></p><p><ul><li>acceptedInviteパラメータは、ゲームが別のプレーヤーから直接招待を受け取るとnil以外の値になります。この場合は、ほかのプレーヤーのゲームがすでに対戦要求を作成しています。 そのため、招待された側のデバイスで実行しているアプリケーションで対戦要求を作成する必要はありません。</li><br/><li>playersToInviteパラメータは、対戦をホストするGame Centerアプリケーションから直接ゲームが起動されるとnil以外の値になります。このパラメータは、ゲームが対戦に招待すべきプレーヤーを示したプレーヤー識別子の配列を保持します。ゲームは新しい対戦要求を作成し、 通常通りにパラメータを割り当ててから、対戦要求のplayersToInviteプロパティをplayersToInviteパラメータで渡された値に設定する必要があります。マッチメーク画面が表示されると、すでに対戦に参加しているプレーヤーのリストがあらかじめ読み込まれます。</li><br/></ul></p><p><br/><p></p><footer><strong>『Game Kit プログラミングガイド』より</strong></footer></blockquote></p>

<pre><code class="objective-c">- (void)initMatchInviteHandler
{
    if (gameCenterAvailable) {
    [GKMatchmaker sharedMatchmaker].inviteHandler = ^(GKInvite *acceptedInvite, NSArray *playersToInvite) {
      // 既存のマッチングを破棄する
      self.currentMatch = nil;

      if (acceptedInvite) {
        // ゲーム招待を利用してマッチメイク画面を開く
        [self showMatchmakerWithInvite:acceptedInvite];
      } else if (playersToInvite) {
        // 招待するユーザを指定してマッチメイク要求を作成する
        GKMatchRequest *request = [[[GKMatchRequest alloc] init] autorelease];
        request.minPlayers = 2;
        request.maxPlayers = 2;
        request.playersToInvite = playersToInvite;

        [self showMatchmakerWithRequest:request];
      }
    };
  }
}
</code></pre>

<h3>マッチメイク画面を開く</h3>


<p>マッチメイク画面を開くには、ViewController が必要。マッチメイク要求（Request）かゲーム招待（Invite）かどちらかを使ってマッチメイク画面を開く。</p>

<p>インターフェースはほとんど同じになる。</p>

<pre><code class="objective-c">- (void)showMatchmakerWithRequest:(GKMatchRequest *)request
{
  GKMatchmakerViewController *viewController = [[[GKMatchmakerViewController alloc] initWithMatchRequest:request] autorelease];
  viewController.matchmakerDelegate = self;
  [self presentModalViewController:viewController animated:YES];
}

- (void)showMatchmakerWithInvite:(GKInvite *)invite
{
  GKMatchmakerViewController *viewController = [[[GKMatchmakerViewController alloc] initWithInvite:invite] autorelease];
  viewController.matchmakerDelegate = self;
  [self presentModalViewController:viewController animated:YES];
}
</code></pre>

<h3>自分で対戦要求を作成する場合</h3>


<p>自分で対戦要求を作成する場合は、<strong>GKMatchRequest</strong> を作って、マッチメイク画面を表示する。</p>

<p>対戦要求は任意のタイミングで作成すればよい。例えば、メニューで「ふたりで対戦する」ボタンが押されたとき等。</p>

<pre><code class="objective-c">- (void)requestMatch
{
  GKLocalPlayer *localPlayer = [GKLocalPlayer localPlayer];
  if (localPlayer.authenticated) {
    // 対戦相手を決める
    GKMatchRequest *request = [[[GKMatchRequest alloc] init] autorelease];
    request.minPlayers = 2;
    request.maxPlayers = 2;

    [self showMatchmakerWithRequest:request];
  }
}
</code></pre>

<h3>対戦相手が決まった際に呼び出されるコールバック</h3>


<p>対戦相手が決まるたびに、呼び出されるコールバックメソッド。これは <strong>GKMatchmakerViewController</strong> の matchmakerDelegate を経由して呼び出される。</p>

<p>コールバックを受け取るには、<strong>GKMatchmakerViewControllerDelegate</strong> プロトコルを実装している必要がある。</p>

<p>matchStarted はゲームがスタートしているかどうかを表すメンバ変数。<em>match.expectedPlayerCount</em> は対戦要求にあと何人の必要プレイヤーがいるかを表す値。0になれば、必要なプレイヤーが揃ったことになる。</p>

<pre><code class="objective-c">- (void)matchmakerViewController:(GKMatchmakerViewController *)viewController didFindMatch:(GKMatch *)match
{
  [self dismissModalViewController];
  self.currentMatch = match;

  // 全ユーザが揃ったかどうか
  if (!matchStarted &amp;&amp; match.expectedPlayerCount == 0) {
    matchStarted = YES;
    // ゲーム開始の処理
  }
}
</code></pre>

<h3>対戦相手にデータを送る</h3>


<p>対戦相手がきまり、現在の通信セッションを表す <strong>GKMatch</strong> が取得できたら、GKMatch に対して sendDataToAllPlayers メソッドを呼び出してデータを送信する。</p>

<p>これによって対戦相手にデータが送られる。</p>

<p>GKMatchSendDataUnreliable モードは、いわゆる UDP で送信するイメージ。GKMatchSendDataReliable モードは TCP で送るイメージ。通常は GKMatchSendDataUnreliable でよいはず。</p>

<p>データの内容や型は、アプリ側で好きに決めることができる。ほとんどの場合、カスタムの構造体を作成してデータを送信する。構造体を作れば、sizeof(myData) でバイトサイズを取得できる。</p>

<pre><code class="objective-c">- (void)sendDataToAllPlayers:(void *)data sizeInBytes:(NSUInteger)sizeInBytes
{
  if (gameCenterAvailable) {
    NSError *error = nil;
    NSData *packetData = [NSData dataWithBytes:data length:sizeInBytes];
    [currentMatch sendDataToAllPlayers:packetData withDataMode:GKMatchSendDataUnreliable error:&amp;error];
    self.error = error;
  }
}
</code></pre>

<h3>対戦相手からデータを受け取る</h3>


<p>対戦相手からデータを受け取るには、GKMatch のデリゲートに GKMatchDelegate を実装したインスタンスを割り当てます。</p>

<p>対戦相手からデータを受け取った場合には、次のコールバックメソッドが呼び出されます。</p>

<pre><code class="objective-c">- (void)match:(GKMatch *)match didReceiveData:(NSData *)data fromPlayer:(NSString *)playerID
{
  // データを受け取ってアプリで利用する
}
</code></pre>

<h2>対戦機能をテストする方法</h2>


<p>Game Center の機能をテストするために、Apple はサンドボックス環境を用意してくれています。サンドボックス環境は、シミュレータ上でも実機でもどちらでも使うことができます。</p>

<p>ただし、<strong>シミュレータ上ではマッチメイクの招待の送受信はできません。</strong>マッチメイクのテストをするには、実機を二台用意する必要があります。</p>

<p>実機を二台用意したら次の手順でテストできます。</p>

<ol>
<li>iTunes Connect にアプリを登録して、Game Center 機能を有効にする。<a href="https://itunesconnect.apple.com/docs/iTunesConnect_DeveloperGuide_JP.pdf" rel="external nofollow">『iTuens Connect デベロッパガイド』</a>参照</li>
<li>実機を二台用意する。</li>
<li>それぞれの実機にテストアプリをインストールする。（Xcode 上でデバッグビルドで起動すれば入る）</li>
<li>サンドボックス環境にスイッチするために、テストアプリ内から認証機能を実行する。</li>
<li>アプリを閉じて、Game Center アプリを立ち上げ、サンドボックス環境であることを確認して友だちを招待する</li>
<li>もう一台の実機のほうでもサンドボックス環境にスイッチし、Game Center アプリを開き友だちリクエストを承認する</li>
<li>アプリに戻り、マッチメイク機能をテストする</li>
</ol>




<p class="option">マッチメイクの招待には PUSH 配信を利用するので、実機で Game Center の通知機能をオンするのを忘れずに。</p>




<h3>サンドボックス環境にスイッチする</h3>


<p>もし、すでに Game Center にサインインしている場合は、一度 Game Center アプリを起動して、サインアウトしておきます。</p>

<p>アプリを立ち上げて、認証機能を実行すると、下の図のようなダイアログが表示されます。</p>

<p><img alt="Game Center 認証画面" src="http://hamasyou.com/images/%E5%86%99%E7%9C%9F.PNG" width="320" height="480" class="mt-image-none" style="" /></p>

<p>Game Center のアカウントを持っていない場合は、ここで開発用のアカウントを作成します。すでに持っている場合は、Use Existing Account を選択して、既存のアカウントでサインインします。</p>

<p>サンドボックス環境と通常の環境とのスイッチは、開発中のアプリケーションでサインインしたかどうかで決まります。アカウントは同じものを使えます。</p>

<p>サンドボックス環境にスイッチできたかどうかは、一度アプリを終了させ、Game Center アプリを起動することで確認できます。</p>

<p><img alt="GameCenterサンドボックス" src="http://hamasyou.com/images/%E5%86%99%E7%9C%9F%20%281%29.PNG" width="320" height="480" class="mt-image-none" style="" /></p>

<h3>サンドボックス環境で友だちを招待する</h3>


<p>サンドボックス環境の Game Center アプリから、友だちリクエストを送ります。このリクエストは、サンドボックス環境内のアカウントに対して送信されるため、 相手もサンドボックス環境にスイッチする必要があります。</p>

<p>二台目の実機のほうもサンドボックス環境にスイッチして、Game Center アプリを起動すると、リクエストタブに友だちリクエストが着ているはずです。</p>

<h3>サンドボックス環境でマッチメイク機能をテストする</h3>


<p>二台ともサンドボックス環境にスイッチできたら、ゲーム内から友だちを招待して対戦機能をテストできます。</p>

<p>下の図は、<a href="#title8" rel="external nofollow">requestMatch</a> メソッドを呼び出した時の画面です。</p>

<p><img alt="Game Center マッチメイク画面" src="http://hamasyou.com/images/%E5%86%99%E7%9C%9F%20%282%29.PNG" width="320" height="480" class="mt-image-none" style="" /></p>

<h2>cocos2d 本おすすめ</h2>




<div class="bookInfo"> 
<div class="bookImg"> 
<a href="http://www.amazon.co.jp/gp/product/4844330411?ie=UTF8&tag=sorehabooks-22&linkCode=xm2&camp=247&creativeASIN=4844330411" rel="external nofollow"></a> 
</div> 
<ul><li><a href="http://www.amazon.co.jp/gp/product/4844330411?ie=UTF8&tag=sorehabooks-22&linkCode=xm2&camp=247&creativeASIN=4844330411" rel="external nofollow"></a></li><li>Steffen Itterheim (著), 畑 圭輔 (監修), 坂本 一樹 (監修), 加藤 寛人 (監修), 高丘 知央 (監修), 株式会社 クイープ (翻訳) </li><li>インプレスジャパン</li></ul> 
<div class="clear"></div> 
</div>


<p>cocos2d は Objective-C で書かれたゲームエンジン、フレームワークです。2D ゲームを作成するに当たっての結構簡単にわかりやすい機能を提供してくれます。</p>

<p>cocos2d は最近 Version 1.0 が正式にリリースされました。<em>OpenGL ES</em> のコードを隠していながら、UIViewController も提供してくれるようになったため、Game Center を使ったアプリともスムーズに連携できるようになりました。</p>

<p>また、『<a href="http://www.amazon.co.jp/gp/product/4844330411?ie=UTF8&tag=sorehabooks-22&linkCode=xm2&camp=247&creativeASIN=4844330411" rel="external nofollow">cocos2dで作る iPhone＆iPadゲームプログラミング</a>』の中にも1章まるまるつかって、Game Center を使ったプログラミングの解説がされています。</p>

<p>おすすめの一冊です。</p>
]]></content>
  </entry>
  
</feed>
