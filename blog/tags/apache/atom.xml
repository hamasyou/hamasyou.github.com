<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: Apache | それはBooks]]></title>
  <link href="http://hamasyou.com/blog/tags/apache/atom.xml" rel="self"/>
  <link href="http://hamasyou.com/"/>
  <updated>2014-02-12T19:22:37+09:00</updated>
  <id>http://hamasyou.com/</id>
  <author>
    <name><![CDATA[hamasyou]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Apache Pluto1.1 を触ってみる その2]]></title>
    <link href="http://hamasyou.com/blog/2006/04/19/apache-pluto/"/>
    <updated>2006-04-19T00:08:00+09:00</updated>
    <id>http://hamasyou.com/blog/2006/04/19/apache-pluto</id>
    <content type="html"><![CDATA[<p>
<a href="http://portals.apache.org/pluto/" rel="external nofollow"></a>
</p>


<p>Apache Pluto の覚書きです。Apache Pluto は、Java Portlet 仕様 のリファレンス実装です。この覚書きを書いている段階では、Java Portlet Specification (JSR-168) が Java Portlet 仕様として、まとめられています。</p>

<p>この覚書きで使っている環境は次の通りです。</p>

<ul><li>Eclipse 3.1.2</li><li>Pluto 1.1 (alpha release 以前)</li><li>Tomcat 5.5.9</li><li>J2SE 5.0</li></ul>


<p>参考にしたリソースは次の通りです。<ul><li><a href="http://jcp.org/aboutJava/communityprocess/final/jsr168/index.html" rel="external nofollow">Developing Portlets with Apache Pluto</a></li></ul></p>

<p>Pluto の中を追っていったときの覚書です。ソースコードを手元に読んでいただければ、より理解できるのではないかと思います。</p>

<p>間違い等に気づいた方は、ご連絡いただけると助かります。</p>

<!-- more -->




<h2>Apache Pluto1.1 覚書 目次</h2>




<ul>
<li><a href="#chapter1" rel="external nofollow">環境構築</a>
<ul>
<li><a href="#section1" rel="external nofollow">ソースコードをダウンロードする</a></li>
<li><a href="#section2" rel="external nofollow">インストールする</a></li>
</ul>
</li>
<li><a href="#chapter2" rel="external nofollow">Pluto のアーキテクチャ</a>
<ul>
<li><a href="#section3" rel="external nofollow">ポータルもWebアプリケーションだから、サーブレット が使われている</a></li>
<li><a href="#section4" rel="external nofollow">Pluto で使われる主なクラス群</a></li>
<li><a href="#section5" rel="external nofollow">ポートレットコンテナにポートレットを登録するにはどうすればいいのか？</a></li>
<li><a href="#section6" rel="external nofollow">ポートレットを呼び出すぞ。（でも、URL がわからない・・・）</a></li>
<li><a href="#section7" rel="external nofollow">Pluto の設定には、SpringFramework が使われている</a></li>
</ul>
</li>
<li><a href="#chapter3" rel="external nofollow">まとめ</a></li>
</ul>




<h4>Pluto をもうちょっと詳しく見てみる 目次</h4>




<ul>
<li><a href="#chapter4" rel="external nofollow">PortalStartupListener の動作</a>
</li>
<li><a href="#chapter5" rel="external nofollow">PortletDriverServlet の動作</a>
<ul>
<li><a href="#section8" rel="external nofollow">リクエスト種類によって、呼び出しが変わる</a></li>
</ul>
</li>
<li><a href="#chapter6" rel="external nofollow">ポートレットコンテナの動作</a>
<ul>
<li><a href="#section9" rel="external nofollow">ポートレットコンテナの呼び出しを整理しておくと</a></li>
<li><a href="#section10" rel="external nofollow">ポートレットの呼び出し方法</a></li>
</ul>
</li>
<li><a href="#chapter7" rel="external nofollow">エラーで困ったら</a>
<ul>
<li><a href="#section11" rel="external nofollow">error.config.context.null</a></li>
</ul>
</li>
<li><a href="#chapter8" rel="external nofollow">検討事項</a></li>
</ul>




<h2 id="chapter1">環境構築</h2>


<p>今回使うのは、Apache Pluto1.1 です。2006/4/20 現在では、 Pluto のバージョンは 1.0.1 と 1.1 の二つが用意されています。バイナリで配布されているのは 1.0.1 だけなので、今回はソースコードを手に入れるところからはじめます。</p>

<p>Pluto 1.0.1 と Pluto 1.1 は、アーキテクチャが大きく変わったようです。1.1 のほうがよりシンプルに美しくなりました。それに伴って、設定の仕方なども色々と変わっています。 Pluto 1.0.1 を使う場合は、この覚書は参考にならないかもしれませんので注意してください。</p>

<p>今回使うのは、Pluto1.1 です。</p>

<h4>ライセンス</h4>


<p>The Apache Software License, Version 2.0</p>

<h3 id="section1">ソースコードをダウンロードする</h3>


<p>Apache Pluto 1.1 のソースコードは、<a href="http://subversion.tigris.org/" rel="external nofollow">Subversion</a> で管理されています。下記の URL からチェックアウトできます。</p>

<pre><a href="http://svn.apache.org/repos/asf/portals/pluto/trunk/" rel="external nofollow"> http://svn.apache.org/repos/asf/portals/pluto/trunk/</a></pre>


<p>下のコマンドを実行することでも、ソースコードがダウンロードできます。</p>

<pre class="console">> <kbd>svn checkout http://svn.apache.org/repos/asf/portals/pluto/trunk/ pluto-site</kbd></pre>




<h3 id="sectiono2">インストールする</h3>


<p>ソースコードをダウンロードしたら、Apache Pluto のサイトにある <a href="http://portals.apache.org/pluto/getting-started.html" rel="external nofollow">Getting Started</a> を見ながら、インストールを行います。ソースコードをダウンロードしたパスに移動して</p>

<pre class="console">> <kbd>mvn install</kbd></pre>


<p>を実行すると、ずらずらと、ライブラリができるので、Getting Started に書いてある Step にしたがって配置していきます。</p>

<p>配置が終了したら、Tomcat を起動します。<a href="http://localhost:8080/pluto/portal" rel="external nofollow">http://localhost:8080/pluto/portal</a> にアクセスすると、Pluto のポータル画面が表示されます。</p>

<h2 id="chapter2">Pluto のアーキテクチャ</h2>




<h3 id="sectiono3">ポータルもWebアプリケーションだから、サーブレット が使われている</h3>


<p>まず、最初に Pluto がどういう風に動作するのかを簡単にまとめて見ました。（画像をクリックすると大きな画像が表示されます。）</p>

<p><a href="http://hamasyou.com/images/portal_pluto/pluto_class.gif" rel="external nofollow"></a></p>

<p>Pluto は、Web ブラウザからリクエストを受けると次のように動作します。</p>

<pre>
1. PortalDriverServlet がポータルに対するリクエストを受け取る
        ↓
2. サーブレットコンテキスト、サーブレットリクエスト、サーブレットレスポンスをそれぞれポートレット API でラップする
        ↓
3. ポートレットコンテナを呼び出す
        ↓
4. ポートレットコンテナは、リクエストパラメータを解析して、どのポートレットが呼び出されたのかを判断する
        ↓
5. 呼び出されたポートレットにリクエストをフォワードする
        ↓
6. ポートレットコンテナは、レンダリングリクエストを表示するページ内の全ポートレットに対して送信する
        ↓
7. ポートレットのレスポンスをマージして、画面をブラウザに返す
</pre>


<p>ポータルアプリケーションもひとつの Web アプリケーションなので、当然サーブレットを使っています。</p>

<p>Tomcat を起動した際に webapp ディレクトリにできる pluto フォルダの下には、典型的な Web アプリケーションの構成ができています。</p>

<p><img src="http://hamasyou.com/images/portal_pluto/pluto_dir.gif" alt="pluto   のディレクトリ構成" /></p>

<p>{TOMCAT_HOME}/webapps/pluto/WEB-INF/web.xml を開くと、こんな記述があると思います。</p>

<p><section></p>

<h4>web.xml 抜粋</h4>




<pre class="code"><code><span class="tag">&lt;servlet&gt;</span>  
  <span class="tag">&lt;servlet-name&gt;</span>plutoPortalDriver<span class="tag">&lt;/servlet-name&gt;</span>  
  <span class="tag">&lt;display-name&gt;</span>Pluto Portal Driver<span class="tag">&lt;/display-name&gt;</span>  
  <span class="tag">&lt;description&gt;</span>Pluto Portal Driver Controller<span class="tag">&lt;/description&gt;</span>  
  <span class="tag">&lt;servlet-class&gt;</span>org.apache.pluto.driver.PortalDriverServlet<span class="tag">&lt;/servlet-class&gt;</span>  
<span class="tag">&lt;/servlet&gt;</span>
</code></pre>


<p></section></p>

<p>このクラスが、ポータルアプリケーションの窓口、ポータルアプリケーションのサーブレットです。ポータルにアクセスしたいときは、このサーブレットにアクセスすることになります。web.xml の下のほうにマッピングが書かれていますので、見てみます。</p>

<p><section></p>

<h4>web.xml 抜粋</h4>




<pre class="code"></code><span class="tag">&lt;servlet-mapping&gt;</span>  
  <span class="tag">&lt;servlet-name&gt;</span>plutoPortalDriver<span class="tag">&lt;/servlet-name&gt;</span>  
  <span class="tag">&lt;url-pattern&gt;</span>/portal/*<span class="tag">&lt;/url-pattern&gt;</span>  
<span class="tag">&lt;/servlet-mapping&gt;</span>
</code></pre>


<p></section></p>

<p>つまり、http://localhost:8080/pluto/portal/ にアクセスすることで、このサーブレットが呼ばれ、ポートレットコンテナに格納されているポートレットが呼び出されるわけです。</p>

<p>なお、ポートレットの初期化は、サーブレットリスナで行われており、<code>org.apache.pluto.driver.PortalStartupListener</code> が使われていました。これについては後の節で詳しく見ることにします。</p>

<h3 id="sectiono4">Pluto で使われる主なクラス群</h3>


<p>Pluto のアーキテクチャを調べた中で出てきた主なクラスは次の4つです。</p>

<dl>
<dt>org.apache.pluto.driver.PortletDriverServelt</dt>
<dd><p>このクラスは、Pluto の本体ともいえるサーブレットの実装クラスです。Web ブラウザからのアクセスは、このサーブレットが受け取ります。このクラスは、Pluto 全体の初期化やポートレットコンテナの作成と初期化を行います。</p></dd>
<dt>org.apache.pluto.PortletContainer</dt>
<dd><p>ポートレットコンテナの実装クラスです。PortletDriverServlet から呼び出されます。内部にはポートレットを格納しています。リクエストを解釈し、適切なポートレットに割り振ることを行います。</p></dd>
<dt>org.apache.pluto.core.PortletServlet</dt>
<dd><p>ポートレットアプリケーション側に配備されるクラスです。ポートレットコンテナからの呼び出しを受け、ポートレットに処理を委譲します。</p></dd>
<dt>org.apache.pluto.driver.tags.PortletRenderTag</dt>
<dd><p>ポートレットのレンダリングを呼び出すためのタグクラスです。JSP に記述され、ポートレットのレンダリングリクエストを発行します。<code>&lt;pluto:render /&gt;</code> であらわされます。</p></dd>
</dl>




<dl>
<dt class="notice">クロスコンテキストを有効にする必要がある</dt>
<dd>ポータルは、複数のWeb アプリケーションをまたがるため、クロスコンテキスト(crossContext) が可能でなければなりません。{TOMCAT_HOME}/conf/Catalina/localhost にコピーした pluto.xml には、<code>crossContext=&quot;true&quot;</code> が記述されています。</dd>
</dl>




<h3 id="sectiono5">ポートレットコンテナにポートレットを登録するにはどうすればいいのか？</h3>


<p>{TOMCAT_HOME}/webapps/pluto/WEB-INF/web.xml を見ると、いくつかのサーブレットの設定に <code><strong>org.apache.pluto.core.PortletServlet</strong></code> というクラスが使われています。サーブレットの <code>init-param</code> 設定で、<code><strong>portlet-name</strong></code> というパラメータが設定されています。</p>

<pre class="code"><code><span class="tag">&lt;servlet&gt;</span>  
  <span class="tag">&lt;servlet-name&gt;</span>AdminPortlet<span class="tag">&lt;/servlet-name&gt;</span>  
  <span class="tag">&lt;servlet-class&gt;</span>org.apache.pluto.core.PortletServlet<span class="tag">&lt;/servlet-class&gt;</span>  
  <span class="tag">&lt;init-param&gt;</span>  
    <span class="tag">&lt;param-name&gt;</span>portlet-name<span class="tag">&lt;/param-name&gt;</span>  
    <span class="tag">&lt;param-value&gt;</span>AdminPortlet<span class="tag">&lt;/param-value&gt;</span>  
  <span class="tag">&lt;/init-param&gt;</span>  
  <span class="tag">&lt;load-on-startup&gt;</span>1<span class="tag">&lt;/load-on-startup&gt;</span>  
<span class="tag">&lt;/servlet&gt;</span>
</code></pre>


<p>どうやら、Pluto1.1 では、ポートレットコンテナ がこの <code>PotletServlet</code> を呼び出して、さらに <code>PortletServlet</code> が ポータルコンテンツ を呼び出す仕組みになっているようです。呼び出される ポータルコンテンツは、<code>portlet-name</code> で指定しています。</p>

<p><code>portlet-name</code> で指定されているのは、あくまでポートレット名です。では、ポートレットの本体はどこで定義するのかというと、JSR-168 で決められている通り、portlet.xml に定義します。あたりまえですね。</p>

<p>web.xml をもう少し見ていくと、今度は、<code>servlet-mapping</code> が見つかります。</p>

<pre class="code"><code><span class="tag">&lt;servlet-mapping&gt;</span>  
  <span class="tag">&lt;servlet-name&gt;</span>AdminPortlet<span class="tag">&lt;/servlet-name&gt;</span>  
  <span class="tag">&lt;url-pattern&gt;</span>/PlutoInvoker/AdminPortlet<span class="tag">&lt;/url-pattern&gt;</span>  
<span class="tag">&lt;/servlet-mapping&gt;</span>
</code></pre>


<p><code>/PlutoInvoker/</code> という記述がなんとも不思議です。Pluto 1.1 は、<code>PortletServlet</code> が呼び出される URL にプレフィックスとして、この <code>/PlutoInvoker/</code> という名前を使います。</p>

<p>Portlet 用のサーブレットは、マッピング URL に <code>/PlutoInvoker/</code> を記述するようにします。その後ろの名前は、ポートレット名をつけます。</p>

<p>ちなみに、web.xml と portal.xml の設定は、ポートレットアプリケーション（自分が作るアプリケーション）側に記述します。</p>

<h3 id="sectiono6">ポートレットを呼び出すぞ。（でも、URL がわからない・・・）</h3>


<p>さて、これでポートレットの設定は完了したわけですが、これだけではポートレットは呼び出せません。JSR-168 には、</p>

<p><blockquote><p>Portlets are not directly bound to a URL</p></p><p><p></p><footer><strong>JSR-168</strong></footer></blockquote></p>

<p>とあります。これはつまり、ブラウザのアドレスバーに URL を直接打ち込んでもポートレットを呼び出すことはできませんということを言っています。例えば、ブラウザのアドレスに http://localhost:8080/pluto/PortletInvoker/AdminPortal 入力してもエラーになります。</p>

<p>では、どうすればよいかというと、ポートレットは、ポートレットコンテナから呼び出されることが決められているので、ポートレットコンテナに呼び出しをお願いします。Pluto1.1 の場合、このお願いは {TOMCAT_HOME}/webapps/pluto/WEB-INF/pluto-portal-driver-config.xml に記述することになります。</p>

<p><section></p>

<h4>(pluto-portal-driver-config.xml 抜粋)</h4>




<pre class="code"><code><span class="tag">&lt;pluto-portal-driver </span>  
  ...  
  <span class="tag">&lt;portlet-app&gt;</span>  
    <span class="tag">&lt;context-path&gt;</span>/pluto<span class="tag">&lt;/context-path&gt;</span>  
    <span class="tag">&lt;portlets&gt;</span>  
      <span class="tag">&lt;portlet <span class="attr">name=</span><span class="value">&quot;AboutPortlet&quot;</span> /&gt;</span>  
      <span class="tag">&lt;portlet <span class="attr">name=</span><span class="value">&quot;AdminPortlet&quot;</span> /&gt;</span>  
    <span class="tag">&lt;/portlets&gt;</span>  
  <span class="tag">&lt;/portlet-app&gt;</span>  
  ...  
  <span class="tag">&lt;render-config <span class="attr">default=</span><span class="value">&quot;Pluto Admin&quot;</span>&gt;</span>  
    <span class="tag">&lt;page <span class="attr">name=</span><span class="value">&quot;Pluto Admin&quot;</span> <span class="attr">uri=</span><span class="value">&quot;/WEB-INF/themes/pluto-default-theme.jsp&quot;</span>&gt;</span>  
      <span class="tag">&lt;portlet <span class="attr">context=</span><span class="value">&quot;/pluto&quot;</span> <span class="attr">name=</span><span class="value">&quot;AdminPortlet&quot;</span>/&gt;</span>  
    <span class="tag">&lt;/page&gt;</span>  
  <span class="tag">&lt;/render-config&gt;</span>  
<span class="tag">&lt;/pluto-portal-driver&gt;</span>
</code></pre>


<p></section></p>

<p><section></p>

<h4>portlet-app タグ</h4>


<p>このタグでポートレットの定義を記述します。</p>

<dl>
<dt>context-path タグ</dt><dd><p>ここに、ポートレットのコンテキストパスを記述します。ポートレットは別の Web アプリケーションとして作成できるので、コンテキストも Pluto とは別になります。コンテキスト名に使える文字は 「a-z, A-Z, 0-9, _, /」 です。'.' や '-' は使えないので注意です。</p></dd>
<dt>portlets タグ</dt><dd><p>このタグを使って、このコンテキストに含まれるポートレットの名前を定義します。ここに記述するのは、portlet.xml に定義したポートレットです。</p></dd>
</dl>


<p></section></p>

<p><section></p>

<h4>render-config タグ</h4>


<p>このタグは、<code>PlutoPortletDriver</code> の設定を記述するところです。ここには、レンダリングに関する設定をおこないます。設定しているのは、ポータルページを呼び出すときのパス名（name 属性）と、ポータルページに使用するページ（uri 属性）、どのポートレットを使うか（portlet タグ）です。portlet タグに記述するのは、<code>portlet-app</code> で記述したコンテキストと、ポートレット名です。</p>

<p>name に指定した値 (ページ名) をブラウザのアドレスバーに打ち込むことで、ポータルページを開くことができます。</p>

<pre>http://localhost:8080/pluto/portal/Pluto%20Admin</pre>


<p></section></p>

<p>これで、Pluto を起動したときに、pluto-portal-driver-config.xml が読み込まれ、ポートレット URLを生成したページが表示できるようになります。Pluto は、この設定ファイルを解析して、URL と ポートレットアプリケーションのマッピングを行います。</p>

<p>http://localhost:8080/pluto/portal にアクセスして、ログインした後のページの左上にある Navigation から ページを移動してみましょう。画面が表示されるはずです。</p>

<dl>
<dt class="notice">ポートレットID</dt>
<dd>
<p>すべてのポートレットには、一意の ID が振られます。Pluto の場合、次のようなルールによって ID が決められます。</p>

<pre>[portlet-context-name].[portlet-name]</pre>

<p><code>[portlet-context-name]</code> とは、ポートレットアプリケーションのコンテキスト名のことです。<code>[portlet-name]</code> は、文字通りポートレット名です。これらを '.' でつないだものが <strong>Portlet Definition ID</strong> と呼ばれるポートレットの一意な ID です。</p></dd>
</dl>




<h3 id="sectiono7">Pluto の設定には、SpringFramework が使われている</h3>


<p>{TOMCAT_HOME}/webapps/pluto/WEB-INF/ を見ると、pluto-portal-driver-service-config.xml というファイルがあるのがわかります。このファイル、中を見ると実は SpringFramework の Bean 設定ファイルだったりします。</p>

<p>Pluto の設定が行われている部分を抜粋します。</p>

<p><section></p>

<h4>(pluto-portal-driver-service-config.xml 抜粋)</h4>




<pre class="code"><code><span class="tag">&lt;bean <span class="attr">id=</span><span class="value">&quot;DriverConfiguration&quot;</span>  
  <span class="attr">class=</span><span class="value">&quot;org.apache.pluto.driver.config.impl.DriverConfigurationImpl&quot;</span>&gt;</span>  
  <span class="rem">&lt;!-- ===== Portal Services ===== --&gt;</span>  
  <span class="tag">&lt;constructor-arg&gt;</span><span class="tag">&lt;ref <span class="attr">local=</span><span class="value">&quot;PropertyConfigService&quot;</span>/&gt;</span><span class="tag">&lt;/constructor-arg&gt;</span>  
  <span class="tag">&lt;constructor-arg&gt;</span><span class="tag">&lt;ref <span class="attr">local=</span><span class="value">&quot;PortletRegistryConfig&quot;</span>/&gt;</span><span class="tag">&lt;/constructor-arg&gt;</span>  
  <span class="tag">&lt;constructor-arg&gt;</span><span class="tag">&lt;ref <span class="attr">local=</span><span class="value">&quot;RenderConfigService&quot;</span>/&gt;</span><span class="tag">&lt;/constructor-arg&gt;</span>  
 
  <span class="rem">&lt;!-- === Container Services === --&gt;</span>  
  <span class="tag">&lt;constructor-arg&gt;</span><span class="tag">&lt;ref <span class="attr">local=</span><span class="value">&quot;PortalCallbackService&quot;</span>/&gt;</span><span class="tag">&lt;/constructor-arg&gt;</span>  
 
  <span class="rem">&lt;!--  Optional Container Services --&gt;</span>  
  <span class="rem">&lt;!--  
  &lt;property name=&quot;portletPreferencesService&quot; &gt; 
    &lt;ref local=&quot;PortletPreferencesService&quot; /&gt; 
  &lt;/property&gt;  
  &lt;property name =&quot;userAttributeService&quot; &gt; 
    &lt;ref local=&quot;UserAttributeService&quot; /&gt; 
  &lt;/property&gt;  
  --&gt;</span>  
<span class="tag">&lt;/bean&gt;</span>
</code></pre>


<p></section></p>

<p>4つのサービスクラスをインジェクションしています。Portal Services とコメントされているサービスクラスは、pluto-portal-driver-service-config.xml を読み込んで、それぞれの担当範囲の設定を返す役割を持っています。</p>

<p>Container Services とコメントされているサービスクラスは、ポートレットコンテナから必要に応じて呼び出されるクラスです。例えば、ポータルのタイトルを設定するときに呼び出されたり、ポートレット URL を生成するクラスの取得に使われたりします。</p>

<p>Pluto の実装を拡張したものに、<a href="http://portals.apache.org/jetspeed-2/" rel="external nofollow">uPortal</a> があります。これらのサービスクラスを拡張して作られています。</p>

<h2 id="chapter3">まとめ</h2>




<ul><li>ポータルはただのWeb アプリケーション</li>
<li>ポートレットもただのWeb アプリケーション</li>
<li>ポータルアプリケーションとポートレットアプリケーションは別々に開発できる</li>
<li>ポータルアプリケーションの設定は{PORTLET_APP}/WEB-INF/portlet.xml を作成することで行う</li>
<li>ポートレットコンテナに対するポートレットの追加・変更や削除は {PLUTO_HOME}/WEB-INF/pluto-portal-driver-config.xml に記述する</li>
<li>画面デザインの変更は、{PLUTO_HOME}/WEB-INF/themes/pluto-default-theme.jsp、portlet-skin.jsp を変更することで行う</li>
<li>ポートレットコンテナの初期化に関する設定は、{PLUTO_HOME}/WEB-INF/pluto-portal-driver-service-config.xml に記述する</li>
</ul>


<p>さらに、ポートレットアプリケーションの開発者がやらなければならないのは、次の点です。</p>

<dl>
<dt class="info">Portlet 開発者がやる作業</dt>
<dd><ol><li>javax.portlet.GenericPortlet を継承したポートレットを作成する</li>
<li>/WEB-INF/portlet.xml を作成し、ポートレットの定義を行う</li>
<li>web.xml に org.apache.pluto.core.PortletServlet を設定し、<code>portal-name</code> を記述する</li>
<li>Pluto の pluto-portal-driver-config.xml に、ポートレットの設定を記述する</li></ol></dd>
</dl>




<h2 id="chapter4">PortalStartupListener の動作</h2>


<p>もうちょっと突っ込んで Pluto を見てみます。といっても、<code>PortalDriverServlet</code> と <code>PortletContainer</code> の動きを追っていくだけですが。</p>

<p><code>PortalStartupListener</code> の中で、Pluto で使われるいろいろな初期設定が行われます。このクラスは、Pluto がアプリケーションサーバにロードされると起動します。デフォルトの実装では、次の3つが行われます。</p>

<p><section></p>

<h4>デフォルトの設定メソッド</h4>




<ul><li>initDriverConfiguration(servletContext);</li>
<li>initAdminConfiguration(servletContext);</li>
<li>initContainer(servletContext);</li>
</ul>


<p>順番に見ていきます。まずは、<code>initDriverConfiguration</code> です。</p>

<p>このメソッドは、<code>DriverConfiguration</code> の生成と初期化を行います。</p>

<p>最初に <code>DriverConfigrationFactory</code> クラスが呼び出されます。 Factory の中で、SpringFramework が呼び出され、 pluto-portal-driver-service-config.xml の内容を元に <code>DriverConfigration</code> が作成されます。</p>

<p>あとは、<code>DriverConfiguration</code> に設定されたサービスクラスの <code>init</code> メソッドが呼び出され、pluto-portal-driver-config.xml のパースを行うという仕組みです。</p>

<p>生成された <code>DriverConfiguration</code> は、<code>ServletContext</code> に <code>&quot;driverConfig&quot;</code>  という名前で格納されます。</p>

<p>つぎに、<code>AdminConfiguration</code> の生成と初期化が行われます。</p>

<p>ほとんどの処理が、<code>DriverConfiguration</code> の同じです。違うのは、<code>ServletContext</code> に格納するときのキーが違うくらいです。</p>

<p>&quot;driverAdminConfig&quot;</code> という値で格納されます。</p>

<p><code>AdminConfiguration</code> は、ポートレットの追加や削除がシステム的に行えるものです。ポートレットを管理するツールを作るときに使えそうです。</p>

<p>最後に ポートレットコンテナの生成と初期化です。</p>

<p>ここも大したことをしていません。<code>DriverConfiguration</code> をもとに、コンテナの実装クラスを生成しているだけです。</p>

<p>生成したコンテナは、<code>ServletContext</code> に <code>&quot;portletContainer&quot;</code> というキーで格納されます。</p>

<p>これで Pluto の初期化が完了しました。あとは、<code>PortletDriverServlet</code> と <code>PortletContainer</code> の動作がわかれば、一通り Pluto の動作を追えるかなと思います。</p>

<h2 id="chapter5">PortletDriverServlet の動作</h2>


<p>このクラスは、何をやっているかというと、サーブレット API を ポートレット API にラップしてポートレットコンテナを呼び出すということを行っています。</p>

<p>ポータルは、リクエストパラメータの値によって呼び出すポートレットを判断します。リクエストパラメータとポートレットのマッピングルールは、ポータル製品ごとに決められています。</p>

<p>Pluto 1.1 は、<code>PortalURLParser</code> クラスの <code>parse</code> メソッドで変換ルールを規定しています。ここで、リクエスト URL をポータルで使える形に変換しています。</p>

<h3 id="sectiono8">リクエスト種類によって、呼び出しが変わる</h3>


<p>ポータルに対するリクエストには種類があります。一つはアクションリクエストで、ポートレットの <code>processAction</code> メソッドが呼び出されます。もう一つはレンダリングリクエストで、ポートレットの <code>render</code> メソッドが呼び出されます。</p>

<p>アクションリクエストの場合、ポートレットコンテナの <code>doAction</code> が呼び出されます。これは、ポートレットの呼び出しを行うメソッドになっています。</p>

<p>レンダリングリクエストの場合、画面の描画が行われます。このとき、{PLUTO_HOME}/WEB-INF/themes/pluto-default-theme.jsp の表示されます。</p>

<h2 id="chapter6">ポートレットコンテナの動作</h2>




<h3 id="sectiono9">ポートレットコンテナの呼び出しを整理しておくと</h3>


<p>JSR-168 では、アクションURL がリクエストされたときには、対応するポートレットの <code>processAction</code> メソッドの呼び出しと、ポータルページに含まれるすべてのポートレットの <code>render</code> メソッドが呼び出されるとされています。</p>

<p><blockquote><p>If the client request is triggered by an action URL, the portal/portlet-container must first trigger the action request by invoking the <i>processAction</i> method of the targeted portlet. &lt;中略&gt; Then, the portal/portlet-container must trigger the render request by invoking the <i>render</i> method for all the portlets in the portal page with the possible exception of portlets for which their content is being cached.</p></p><p><p></p><footer><strong>JSR-168</strong></footer></blockquote></p>

<p><code>PortletDriverServlet</code> から呼び出されるのは、ポートレットコンテナの <code>doAction</code> メソッドです。この <code>doAction</code> メソッドの中でリクエストを解析し、どのポートレットを呼び出すかを決めます。ポートレットの呼び出しには、サーブレットレスポンスの <code>sendRedirect</code> を使っています。</p>

<p>Pluto は、Portlet のレンダリングトリガーを &lt;pluto:render/&gt; タグで行っています。</p>

<h3 id="sectiono10">ポートレットの呼び出し方法</h3>


<p>ポートレットコンテナが、どうやってポートレットを呼び出すかですが、上に書いたようにサーブレットレスポンスの <code>sendRedirect</code> を使っています。このリダイレクト URL のパラメータに、ポートレットコンテナが受け取ったリクエストパラメータ等の情報をエンコードして付与しています。</p>

<p>そして、呼び出されたポートレットプリケーション側で、待ち構えていた <code>org.apache.pluto.core.PortletServlet</code> クラスがパラメータをデコードして、サーブレットリクエストを完成させます。</p>

<p>これで、ポートレットの呼び出しは完了です。</p>

<dl>
<dt class="notice">クロスコンテキストを有効にする！</dt>
<dd>ポートレットの呼び出しを行うには、クロスコンテキストを有効にしておかなければなりません。</dd>
</dl>


<p>ポータルは、異なるコンテキスト間のポートレットを呼び出します。そのため、コンテキストをまたいだ呼び出しが可能なように設定を行う必要があります。</p>

<p>Tomcat の場合、これは、クロスコンテキスト（crossContext）というパラメータで行います。{TOMCAT_HOME}/conf/server.xml に記述するコンテキストの設定に <code>crossContext</code> を設定します。</p>

<h2 id="chapter7">エラーで困ったら</h2>




<h3 id="sectiono11">error.config.context.null</h3>




<pre>org.apache.pluto.PortletContainerRuntimeException: error.config.context.null</pre>


<p>こんなエラーで困ったら、<code>crossContext</code> を true に設定したかどうかを疑ってください。また、コンテキスト名が間違っていないか確認してください。</p>

<h2 id="chapter8">検討事項</h2>


<p>TBD</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Apache Pluto1.1 を触ってみる その1]]></title>
    <link href="http://hamasyou.com/blog/2006/04/16/apache-pluto/"/>
    <updated>2006-04-16T17:52:00+09:00</updated>
    <id>http://hamasyou.com/blog/2006/04/16/apache-pluto</id>
    <content type="html"><![CDATA[<p>
<a href="http://portals.apache.org/pluto/" rel="external nofollow"></a>
</p>


<p>Apache Pluto の覚書きです。Apache Pluto は、Java Portlet 仕様 のリファレンス実装です。この覚書きを書いている段階では、Java Portlet Specification (JSR-168) が Java Portlet 仕様として、まとめられています。今回は、Java Portlet Specification を読んだ覚書きを記録していこうと思います。その後で、Apache Pluto を触った覚書を記録していこうと思います。</p>

<p>この覚書きで使っている環境は次の通りです。</p>

<ul><li>Eclipse 3.1.2</li><li>Java Portlet Specification Version 1.0</li><li>Pluto 1.1 (alpha release 前のもの)</li><li>Tomcat 5.5.9</li><li>J2SE 5.0</li></ul>


<p>参考にしたリソースは次の通りです。</p>

<ul><li><a href="http://jcp.org/aboutJava/communityprocess/final/jsr168/index.html" rel="external nofollow">Java Portlet Specification Version1.0 (JSR-168)</a></li>
<li><a href="http://www.developer.com/java/web/article.php/3554396" rel="external nofollow">Developing Portlets with Apache Pluto</a></li>
<li><a href="http://www.onjava.com/pub/a/onjava/2006/02/01/what-is-a-portlet-2.html?page=1" rel="external nofollow">ONJava.com - What Is a Portlet, Part 2</a></li></ul>


<p>間違い等に気づいた方は、ご連絡いただけると助かります。（英語が苦手なもので &ndash;;）</p>

<!-- more -->




<h2>Java Portlet Specification (JSR-168)</h2>




<h3>目次</h3>




<ol>
<li><a href="#言葉の定義（What is ○○?）" rel="external nofollow">言葉の定義（What is ○○?）</a></li>
<li><a href="#Servlet との違いは？" rel="external nofollow">Servlet との違いは？</a></li>
<li><a href="#ポータルページの構成" rel="external nofollow">ポータルページの構成</a></li>
<li><a href="#ポータルのリクエスト処理手順" rel="external nofollow">ポータルのリクエスト処理手順</a></li>
<li><a href="#Portlet API" rel="external nofollow">Portlet API</a></li>
<li><a href="#Dispatching Request to Servlet and JSPs" rel="external nofollow">Dispatching Request to Servlet and JSPs</a></li>
<li><a href="#ユーザ情報" rel="external nofollow">ユーザ情報</a></li>
<li><a href="#セキュリティ" rel="external nofollow">セキュリティ</a></li>
<li><a href="#portlet.xmlの例" rel="external nofollow">portlet.xmlの例</a></li></ol>




<h2 id="言葉の定義（What is ○○?）">言葉の定義（What is ○○?）</h2>




<h3>ポータルとは何か？</h3>


<p>ポータルとは、Personalization（個別化）、Single Sign on（シングルサインオン）、Content aggregation（コンテンツの統合）を行うプレゼンテーション層の Webアプリケーションです。</p>

<h3>Portlet とは何か？</h3>


<p>Portlet とは、ポータルのための Java 技術の一つであり、Portlet コンテナによって管理される、ユーザインターフェースコンポーネントです。</p>

<h3>Portlet コンテナとは何か？</h3>


<p>Portlet コンテナとは、Portlet を管理する実行時環境のことです。Portlet のライフサイクルを管理します。永続化の仕組みや、Portlet の初期化、ポータルページからのリクエストを処理します。</p>

<h3>fragment とは何か？</h3>


<p>Portlet によって生成されるコンテンツは、fragment とよばれます。fragment とは、HTML や XHTML の破片のことです。つまり、完全な HTML ページではなく、例えば一つの div タグからなる要素だったりします。</p>

<p>fragment は、ポータルページに埋め込まれたときに完全なコンテンツになるように、ルールに則って作る必要があります。。このルールは、次のように決められています。</p>

<dl>
<dt class="warn">Warning</dt>
<dd>
<p>Portlet が生成する HTML fragment は、次のタグを含んではいけません： <strong>base</strong>、<strong>body</strong>、<strong>iframe</strong>、<strong>frame</strong>、<strong>frameset</strong>、<strong>head</strong>、<strong>html</strong>、<strong>title</strong></p>

<p>Portlet が生成する XHTML や XHTML-Basic fragment は、次のタグを含んではいけません： <strong>base</strong>、<strong>body</strong>、<strong>iframe</strong>、<strong>head</strong>、<strong>html</strong>、<strong>title</strong></p>

<p>Portlet が生成する fragment がポータルページとしてなじむために、次のタグの使用に注意しなければなりません：<strong>link</strong>、<strong>meta</strong>、<strong>style</strong></p></dd>
</dl>




<h2 id="Servlet との違いは？">Servlet との違いは？</h2>


<p>Portlet は、Servlet と次のような違いがあります。</p>

<ul><li>Portlet の生成するコンテンツは、fragment なので、それ自体では完結したコンテンツにならない</li>
<li>そのため、Portlet と URL とは、直接的な関係を持たない</li>
<li>Web クライアントは、Portlet 単体ではなく、ポータルページとやり取りをする</li>
<li>同時に複数の Portlet がポータルページに存在する</li>
<li>Portlet は、定義されたライフサイクルを持つ</li>
<li>Portlet は、<a href="#Portlet Mode" rel="external nofollow">Window State</a> という定義された状態をもつ</li></ul>


<p>Portlet は Servlet には無い、次の機能をもちます。</p>

<ul><li>設定情報にアクセスする機能を持つ</li>　
<li>Portlet はユーザプロファイルにアクセスできる</li>
<li>Portlet 用のURLを作成する機能を持つ</li>
<li>2つの Session スコープをもつ（<a href="#javax.portlet.PortletSession" rel="external nofollow">詳細後述</a>）</li></ul>


<p>Portlet は、Servlet の次の機能が使えません。</p>

<ul><li>レスポンスの文字エンコードを指定できない</li>
<li>HTML レスポンスヘッダを設定できない</li>
<li>ポータルページへしかページリクエストができない（つまり、Portlet を直接呼び出せない）</li></ul>


<p>同一Portlet アプリケーション内にある Portlet、Servlet、JSP は、ClassLoader、アプリケーションコンテキスト、セッションを共有します。</p>

<h3>Portlet のライフサイクル</h3>


<p>Portlet は次のライフサイクルを持ちます。これらのライフサイクルにあわせて、javax.portlet.Portlet インターフェースに定義された同名のメソッドが呼び出されます</p>

<ol><li>init</li><li>processAction</li><li>render</li><li>destroy</li></ol>


<p>ライフサイクルは、次のように処理されていきます。</p>

<ul><li>Portlet コンテナが起動したとき、もしくは最初に Portlet へのリクエストが発生したときに、Portlet の init メソッドが呼び出されます</li>
<li>後述する <a href="#javax.portlet.PortletURL" rel="external nofollow">ActionURL</a> がリクエストされたときに、processAction メソッドが呼び出されます</li>
<li>processAction の処理が終了した後、もしくは <a href="#javax.portlet.PortletURL" rel="external nofollow">RenderURL</a> がリクエストされたときに、render メソッドが呼び出されます</li>
<li>Portlet インスタンスが不要になったときに、destroy メソッドが呼び出されます</li></ul>


<p>init メソッドは、Portlet インスタンスが初期化される最初の一回だけ呼び出されます。destory メソッドが呼び出されたあとの Portlet インスタンスは、ガーベッジコレクションの対象になります。</p>

<h3 id="Portlet Mode">Portlet Mode</h3>


<p>Portlet の動作モードのことです。下記の3つが決められています。Portletは VIEW モードを必ずサポートしなければなりません。これ以外のモードは、必要に応じてサポートします。カスタムモードもつくることができます。</p>

<dl><dt>VIEW</dt>
<dd>VIEWモードは、コンテンツを静的に画面に表示するモードのことで、一般の閲覧行為にはこのモードが使われます。</dd>
<dt>EDIT</dt>
<dd>EDITモードは、編集系のページに用意されるモードで、CMSなどのPortletは、このモードをサポートします。</dd>
<dt>HELP</dt>
<dd>HELPモードは、Portlet の説明を表示するモードです。</dd></dl>




<h3 id="Window State">Window State</h3>


<p>ポータルページ上のPortletコンテンツは、下記のいずれかの状態を持ちます。</p>

<dl><dt>NORMAL</dt>
<dd>NORMAL 状態はPortletが他のコンテンツと共存している状態です。ポータルページに複数の Portlet が表示されることになります。</dd>
<dt>MAXIMIZED</dt>
<dd>MAXIMIZED 状態は、自分だけがページに表示されている状態です。ポータルページには、自分の Portlet しか表示されません。</dd>
<dt>MINIMIZED</dt>
<dd>MINIMIZED 状態は、自分以外だけがページに表示されている状態です。ポータルページには、自分の Portlet は表示されません。この状態のときは、Portlet はなにもレンダリングするべきではありません。</dd></dl>




<h2 id="ポータルページの構成">ポータルページの構成</h2>


<p><a href="http://hamasyou.com/images/portal_pluto/portal_page.gif" rel="external nofollow"></a></p>

<p><strong>ポータルページ</strong> は、複数の <strong>Portlet Application</strong> で構成されます。Portlet Application は、<strong>コントロール</strong>を持ちます。<a href="#Portlet Mode" rel="external nofollow">Windows State</a> を変更することができます。Portlet Application が生成するコンテンツが <strong>Portlet fragment</strong>です。</p>

<h2 id="ポータルのリクエスト処理手順">ポータルのリクエスト処理手順</h2>


<p>ポータルページは、次のように処理されていきます。ポータルの動作は、次の4つのプロセスに分かれます。</p>

<ol><li>Request Handling</li><li>Action Request</li><li>Render Request</li><li>End of Service</li></ol>




<h3>Request Handling</h3>


<p>Portlet コンテナは、クライアントからのリクエストを受けると、トリガーとなった<a href="#javax.portlet.PortletURL" rel="external nofollow">PortletURL</a> の種類を判別します。 ActionURL の場合は、Portlet の processAction メソッドが呼び出されます。それ以外の場合は、Portlet の render メソッドが呼び出されます。</p>

<p><a href="http://hamasyou.com/images/portal_pluto/portal_seq.gif" rel="external nofollow"></a></p>

<h3>Action Request</h3>


<p>Portlet#processAction メソッドが呼び出されます。Portlet に対するリクエストを処理します。<a href="#javax.portlet.PortletURL" rel="external nofollow">PortletURL</a> の種類が RenderURL ではない場合にこのプロセスが処理されます。リクエストに対して、Portlet の状態を変化させたり、ビジネスロジックを実行したりします。Struts のActionのイメージで利用すると良いと思います。ただし、Portlet は、 アクションとレンダリングを区別しているので、processAction ないでは、処理のみを行うようにします。</p>

<p>processAction の引数には、ActionRequest と ActionResponse オブジェクトが渡されます。これは、ServletRequest と ServletResponse とほとんど同じものと考えればよさそうです。ActionRequest には、クライアントから送信されたリクエストパラメータが含まれています。</p>

<dl>
<dt class="notice">リクエストパラメータのライフサイクル</dt>
<dd>リクエストパラメータは、processAction メソッドを抜けると、破棄されてしまいます。つまり、render メソッド内で取得することができません。ただし、RenderURL によってリクエストが呼び出されて、processAction が呼ばれなかった場合は、render メソッド内で、リクエストパラメータを取得することができます。</dd>
</dl>


<p>processAction 内で生成したパラメータで、Render Request に必要なパラメータは、ActionResponse#setRenderParameter メソッドを使って render メソッドまで保持しておくことができます。setRenderParameter メソッドで設定された値は、RenderRequest#getParameter メソッドで取得することができます。これにより、processAction メソッド内で設定したパラメータを render メソッドで取得することが出来ます。なお、setRenderParameter でセットする key と value は、null を許可しません。null の場合は例外がスローされます。</p>

<h3>Render Request</h3>


<p>このプロセスでは、Portlet は、自身の <a href="#Window State" rel="external nofollow">Window State</a> にあわせたコンテンツを出力します。Portlet の render メソッドが呼び出されます。render メソッドの引数の RenderRequest オブジェクトを使って、Portlet の様々な情報にアクセスすることができます。ServletRequest と同じような使い方ができます。</p>

<p>コンテンツを書き出すには、render メソッドの引数に渡される RenderResponse オブジェクトを使います。直接ストリームにコンテンツを書き出す方法や、Servlet や JSP に処理をディスパッチすることもできます。ServletResponse オブジェクトと同じような使い方ができます。</p>

<h3>End of Service</h3>


<p>Portlet コンテナは、Portlet を長い期間ロードしたままにしておかなければならないと言うことは規定されていません。つまり、一度の処理で Portlet は破棄されるかもしれないし、されないかもしれないと言うことです。Portlet が破棄されるときには destroy メソッドが呼び出されます。</p>

<h2 id="Portlet API">Portlet API</h2>




<h3 id="javax.portlet.Portlet">javax.portlet.Portlet</h3>


<p>Portlet クラスが実装するインターフェースです。</p>

<h3 id="javax.portlet.GenericPortlet">javax.portlet.GenericPortlet</h3>


<p>Portletのデフォルト実装です。通常、このクラスを継承して、Portletクラスを作成します。このクラスには、doView、doEdit、doHelp メソッドが用意されています。これらのメソッドは、VIEW モードのときは、doView メソッドという風に、Portal Mode によってレンダリング時に呼び出されます。</p>

<h3 id="javax.portlet.PortletURL">javax.portlet.PortletURL</h3>


<p>Portletは、PortletURLオブジェクトを使ってPortlet のURLを表します。PortletURL オブジェクトは、<a href="#javax.portlet.RenderResponse" rel="external nofollow">javax.portlet.RenderResponse </a>によって生成されます。PortletURLは、つぎの2つの種類があります。</p>

<ul><li><strong>Action URL</strong><br />　Portlet#processAction のトリガーになるURLです。</li>
<li><strong>Render URL</strong><br />　Portlet#render のトリガーになるURLです。このURLが呼び出されたときには、Portlet の processAction は呼び出されません。</li></ul>




<h3 id="javax.portlet.PortletContext">javax.portlet.PortletContext</h3>


<p>Portlet 版 ServletContext です。Portlet コンテナにアクセスする方法を提供します。ここに格納された情報は、同一ポートレットアプリケーション（同一のwarファイルに含まれているPortlet群）のすべてのユーザ、すべてのPortlet で共有されます。PortletContext はポートレットアプリケーションにつき、一つ用意されます。</p>

<p>PortletContext は、Portlet の初期パラメータにアクセスすることができます。また、ServletContext とパラメータを共有することもできます。web.xml に記述した初期化パラメータ等にも、PortletContext からアクセスできます。log メソッドを呼び出すことで Portlet ログファイルにログを書き出すことができます。</p>

<p>PortletContext の情報は、ServletContext の情報と共有されます。つまり、PortletContext に格納した情報は、ServletContext で取得できるし、ServletContext に格納した情報は、PortletContext で取得できます。</p>

<h3 id="javax.portlet.PortletRequest">javax.portlet.PortletRequest</h3>


<p>Portlet 版 HttpServletRequest です。クライアントのリクエストに含まれるパラメータを取得したり、セッションを開始したりすることができます。Portlet コンテナは、<a href="#javax.portlet.ActionRequest" rel="external nofollow">javax.portlet.RenderRequest</a> を用意しています。これらは、processAction メソッド、render メソッドのそれぞれで使われます。<strong>PortletRequest、PortletResponse は、スレッドセーフではありません。</strong></p>

<h3 id="javax.portlet.ActionRequest">javax.portlet.ActionRequest</h3>


<p>Portlet の processAction メソッドの引数に渡されるリクエストオブジェクトです。PortletRequest を継承していて、アクションリクエスト（<a href="#PortletURL" rel="external nofollow">ActionURL </a> によるリクエスト)を処理するのに使います。ActionURL にセットされたパラメータを取得することができます。</p>

<h3 id="javax.portlet.RenderRequest">javax.portlet.RenderRequest</h3>


<p>Portlet の render メソッドの引数に渡されるリクエストオブジェクトです。 PortletRequest を継承していて、レンダリングリクエスト(<a href="#PortletURL" rel="external nofollow">RenderURL</a> によるリクエスト）を処理するのに使います。RenderURL にセットされたパラメータを取得することができます。</p>

<h3 id="javax.portlet.PortletResponse">javax.portlet.PortletResponse</h3>


<p>Portlet 版 HttpServletResponse です。Portlet コンテナは、<a href="#javax.portlet.ActionResponse" rel="external nofollow">javax.portlet.RenderResponse</a> の2つを用意しています。これらは、processAction メソッド、render メソッドのそれぞれで使われます。</p>

<h3 id="javax.portlet.ActionResponse">javax.portlet.ActionResponse</h3>


<p>processAction メソッドのレスポンスを書き込むオブジェクトです。render メソッドにパラメータを渡すには、 setRenderParameter メソッドを利用します。また、レスポンスをリダイレクトする場合には、sendRedirect メソッドを呼び出します。</p>

<h3 id="javax.portlet.RenderResponse">javax.portlet.RenderResponse</h3>


<p>render メソッドのレスポンスを書き込むオブジェクトです。コンテンツの書き出しや、<a href="#javax.portlet.PortletURL" rel="external nofollow">PortletURL</a> の生成を行います。</p>

<h3 id="javax.portlet.PortletPreferences">javax.portlet.PortletPreferences</h3>


<p>Portlet のプリファレンスにアクセスするためのクラスです。PortletRequest#getPreferences メソッドを呼び出すことで取得できます。プリファレンスは、 /WEB-INF/portlet.xml ファイルに記述します。Portlet 毎に設定します。</p>

<p>プリファレンスの情報は、processAction メソッド中であれば、変更可能です。render メソッドで変更すると、例外がスローされます。</p>

<h3 id="javax.portlet.PortletSession">javax.portlet.PortletSession</h3>


<p>Portlet 版 HttpSession です。PortletSession のスコープには2つあります。</p>

<ol><li>Application Scope</li><li>Portlet Scope</li></ol>


<p>Application Scope は、同一ポートレットアプリケーション内で共有されるスコープです。Portlet Scope は、同一Portlet で共有されるスコープです。Portlet Scope の方が狭いスコープになります。プライベートスコープとも呼ばれるみたいです。スコープを指定するには、引数を3つとる setAttribute メソッドを呼び出します。</p>

<p>Portlet Scope に格納されるオブジェクトのキーは、Portlet コンテナによって、次のように決められるそうです。</p>

<pre>javax.portlet.p.&lt;ID&gt;?&lt;ATTRIBUTE_NAME&gt;</pre>


<p>&lt;ID&gt; は、Portlet で一意に決められる値で、'?&lsquo; は含まれません。&lt;ATTRIBUTE_NAME&gt; は、setAttribute メソッドの引数に渡した名前です。</p>

<p>PortletSession に格納された情報は、HttpSession と共有されます。つまり、PortletSession に格納した値は、HttpSession で取得でき、HttpSession で格納した値は、PortletSession で取得できます。セッションキーに付ける名前は、パッケージ名を参考に付けるとよいようです。ただし、javax.portlet というプレフィックスは予約されているので、開発者は使わないようにしましょう。</p>

<p>HttpSession に保存された情報は、PortletSession の <strong>APPLICATION_SCOPE</strong> になります。逆もしかりです。</p>

<h2 id="Dispatching Request to Servlet and JSPs">Dispatching Request to Servlet and JSPs</h2>




<h3>ディスパッチの方法</h3>


<p>Portlet#render メソッド中で、PortletRequestDispatcher を使ってリクエストをディスパッチすることができます。PortletRequestDispatcher は、PortletContext オブジェクトから取得することができます。ディスパッチするパスは、'/&lsquo; で始まる必要があります。PortletContext のルートパスからの相対パスになります。パスには、クエリストリングを付けることが出来ます。getNamedDispatcher メソッドを使うと、サーブレット名を指定して、ディスパッチャを取得することが出来ます。</p>

<p>PortletRequestDispacher によってディスパッチされたサーブレットや JSP には、<strong>HTTP GET</strong> がリクエストされます。</p>

<dl>
<dt class="warn">forward してはいけない場合</dt>
<dd><p>PortletRequestDispacher によって include された Servlet や JSP からは、 RequestDispatcher#forward メソッドを呼び出してはいけません。代わりに RequestDispatcher#include メソッドを呼び出すか、Servlet 内ではアクション処理だけを行い、Portlet の render メソッドで別の Servlet や JSP を include します。</p></dd>
</dl>




<h3>ディスパッチ時に付与されるパラメータとアトリビュート</h3>


<p>getRequestDispatcher メソッドを使って取得したディスパッチャ（getNamedDispatcher以外の方法のこと) を使ってサーブレットやJSPにリクエストをディスパッチした時、HttpServletRequest のアトリビュートに下記の属性がセットされます。</p>

<dl><dt>javax.servlet.include.request_uri</dt><dd>サーブレットのリクエストURI。例：/PortalDemo/index.do</dd>

<dt>javax.servlet.include.context_path</dt><dd>サーブレットのコンテキストパス。例：/PortalDemo</dd>

<dt>javax.servlet.include.servlet_path</dt><dd>サーブレットパス。例：/index.do</dd>

<dt>javax.servlet.include.path_info</dt><dd>パス情報。</dd>

<dt>javax.servlet.include.query_string</dt><dd>クエリストリングの情報。例：param1=PARAM1&amp;param2=PARAM2</dd></dl>


<p>ディスパッチの方法にかかわらず、Portlet からサーブレットやJSPにリクエストをディスパッチしたときには、HttpServletRequest に下記の属性がセットされます。</p>

<dl><dt>javax.portlet.config</dt><dd>javax.portlet.PortletConfig クラスのオブジェクト</dd>

<dt>javax.portlet.request</dt><dd>javax.portlet.RenderRequest クラスのオブジェクト</dd>

<dt>javax.portlet.response</dt><dd>javax.portlet.RenderResponse クラスのオブジェクト</dd></dl>


<p>その他、Portlet で設定した Parameter や Attribute が、サーブレットやJSPから取得できます。</p>

<h3>ディスパッチされたサーブレットの制限事項</h3>


<p>PortletRequestDispatcher を使ってリクエストをディスパッチされたサーブレットには、かなりの制限がほどこされます。</p>

<h4>HttpServletRequest</h4>


<table>    <tr>        <th>メソッド名</th>        <th>制約</th>    </tr>    <tr>         <td><ul>            <li>getProtocolget</li>            <li>RemoteAddr</li>            <li>getRemoteHost</li>            <li>getRealPath</li>            <li>getRequestURL</li>        </ul></td>        <td>null を返す</td>    </tr>    <tr>        <td><ul>            <li>getPathInfo</li>            <li>getPathTranslated</li>            <li>getQueryString</li>            <li>getRequestURI</li>            <li>getServletPath</li>        </ul></td>        <td>PortletRequestDispatcher の情報を返す</td>    </tr>    <tr>        <td><ul>            <li>getScheme</li>            <li>getServletName</li>            <li>getServerPort</li>            <li>getAttribute</li>            <li>getAttributeNames</li>            <li>setAttribute</li>            <li>removeAttribute</li>            <li>getLocale</li>            <li>getLocales</li>            <li>isSecure</li>            <li>getAuthType</li>            <li>getContextPath</li>            <li>getRemoteUser</li>            <li>getUserPrincipal</li>            <li>getRequestedSessionId</li>            <li>isRequestedSessionIdValid</li>        </ul></td>        <td>PortletRequest の同名のメソッドと同じ処理になる</td>    </tr>    <tr>        <td><ul>            <li>getParameter</li>            <li>getParameterNames</li>            <li>getParameterValues</li>            <li>getParameterMap</li>        </ul></td>        <td>PortletRequest の同名のメソッドと同じ処理になる。Java Portlet Specification version1.0 PLT.16.1.1 Query Strings in Request Dispatcher Paths セクションに書かれている定義の通りに動作する</td>    </tr>    <tr>        <td><ul>            <li>getCharacterEncoding</li>            <li>setCharacterEncoding</li>            <li>getContextType</li>            <li>getInputStreamgetReader</li>        </ul></td>        <td>何もしない か nullを返す</td>    </tr>    <tr>        <td><ul>            <li>getContentLength</li>        </ul></td>        <td>常に 0 を返す </td>    </tr>    <tr>        <td><ul>            <li>getHeader</li>            <li>getHeaders</li>            <li>getHeaderNames</li>            <li>getCookies</li>            <li>getDateHeader</li>            <li>getIntHeader</li>        </ul>            </td>        <td><p>PortletRequest の getProperties メソッドによって提供される情報を返す</p>        </td>    </tr>    <tr>        <td><ul><li>getMethod</li></ul></td>        <td>常に GET を返す </td>    </tr></table>




<h4>HttpServletResponse</h4>




<table>    <tr>        <th>メソッド名</th>        <th>制約</th>    </tr>
<tr><td><ul>            <li>encodeRedirectURL</li>            <li>encodeRedirectUrl</li>        </ul></td>        <td>null を返す </td>    </tr>    <tr>        <td><ul>            <li>getCharacterEncoding</li>            <li>setBufferSize</li>            <li>flushBuffer</li>            <li>resetBuffer</li>            <li>reset</li>            <li>getBufferSize</li>            <li>isCommitted</li>            <li>getOutputStream</li>            <li>getWriter</li>            <li>encodeURL</li>            <li>encodeUrl</li>        </ul>            </td>        <td>RenderResponse の同名のメソッドと同じ処理になる</td>    </tr>    <tr>        <td><ul>            <li>setContentType</li>            <li>setContentLength</li>            <li>setLocale</li>            <li>addCookie</li>            <li>sendError</li>            <li>sendRedirect</li>            <li>setDateHeader</li>            <li>addDateHeader</li>            <li>setHeader</li>            <li>addHeader</li>            <li>setIntHeader</li>            <li>addIntHeader</li>            <li>setStatus</li>        </ul>            </td>        <td>何もしない</td>    </tr>    <tr>        <td><ul><li>containsHeader</li></ul></td>        <td>常に false を返す </td>    </tr>    <tr>        <td><ul><li>getLocale</li></ul></td>        <td>RenderResponse の同名のメソッドと同じ処理になる</td>    </tr></table>




<h2 id="ユーザ情報">ユーザ情報</h2>


<p>TBD</p>

<h2 id="セキュリティ">セキュリティ</h2>


<p>Portlet コンテナは、ユーザの権限をチェックして、Portlet にアクセス可能かどうかを確認します。これには、Servlet 仕様で決められている、Role を使います。開発者がプログラマティックにチェックすることもできます。それには、PortletRequest クラスの次のメソッドを使用します。</p>

<dl><dt>getRemoteUser</dt><dd>認証に使われたユーザ名を返します。</dd>
<dt>isUserInRole</dt>
<dd>指定したロール名が、セキュリティロールで許可されているかどうかを確認します。</dd>
<dt>getUserPrincipal</dt>
<dd>ログインユーザの Principal を返します。</dl>




<h2 id="portlet.xmlの例">portlet.xmlの例</h2>


<ul>
<li><a href="http://www.javaworld.jp/technology_and_programming/-/15962-3.html" rel="external nofollow">java World Online - 「eXo Platform」で体験するポータル・サイト開発</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
