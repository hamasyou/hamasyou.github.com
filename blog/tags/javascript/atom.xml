<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: JavaScript | それはBooks]]></title>
  <link href="http://hamasyou.com/blog/tags/javascript/atom.xml" rel="self"/>
  <link href="http://hamasyou.com/"/>
  <updated>2014-12-25T11:29:54+09:00</updated>
  <id>http://hamasyou.com/</id>
  <author>
    <name><![CDATA[hamasyou]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[サーバサイドJavaScript Node.js入門]]></title>
    <link href="http://hamasyou.com/blog/2014/03/04/4048703676/"/>
    <updated>2014-03-04T23:24:06+09:00</updated>
    <id>http://hamasyou.com/blog/2014/03/04/4048703676</id>
    <content type="html"><![CDATA[<p>本書は、「<strong>Node</strong> って何？」という人から「Node の中身はどうなっているの？」を知りたい人のために幅広く網羅的に書かれています。</p>

<ol>
<li>Node の基本から順番に理解していきたい</li>
<li>Node を使ってすぐに Web アプリケーションを作ってみたい</li>
<li>Node の内部構造を理解したい</li>
</ol>


<p>これらのモデルケースに合う人にオススメの書籍です。</p>

<!-- more -->


<h1>おぼえがき</h1>

<h2>Node とはなにか？</h2>

<p><em>Node はプログラミング言語ではありません</em>。言語としては <strong>JavaScript</strong> を使います。
<em>Node は JavaScript ライブラリではありませんし、アプリケーションフレームワークでもありません</em>。</p>

<p>Node はスケーラビリティに優れた、Web アプリケーションを実行するためのサーバサイドのプラットフォームです。
特徴は、I/O 処理が非同期で行われプラットフォーム自体がサーバ機能を提供する方式であることです。</p>

<p>JavaScript で実現されたイベントループと非同期処理の仕組み、<strong>WebSocket</strong> との相性の良さ、V8 エンジン搭載などの技術的に優れた部分を持ち合わせています。
<em>Node は、従来の同期処理から決別し、ライブラリを含めてスレッドをブロックすることのない世界を作り上げました</em>。</p>

<h3>JavaScript である理由</h3>

<p>JavaScript ではスレッドライブラリが定義されておらず、多くの実装はシングルスレッドで動作します。また、イベントの仕組みをうまくつかって非同期処理を行います。
Node の世界にマッチさせるライブラリは非同期で動作しなければなりませんが、サーバサイドで JavaScript は今までほとんど使われてこなかったため、
サーバサイドのライブラリはゼロから作り上げる必要がありました。つまり、<em>過去の資産を気にすることなく非同期かつスレッドをブロックしない I/O を利用させることが可能でした</em>。</p>

<p>近年爆発的にユーザ数が増えると、<strong>C10K</strong> という問題が起こることがクローズアップされ始めました。
従来のアーキテクチャは、クライアントのアクセスに対して一つのスレッドを割り当てるマルチスレッドモデルで同時アクセスをさばいていました。
しかし、これではユーザ数が増えた際にスレッドを大量に生成しなければならず、この部分がボトルネックになるようになりました。</p>

<p>そこで、マルチスレッドモデルに対して、<strong>シングルスレッド+イベントループ</strong> により複数のクライアントをさばくというモデルがではじめました。
JavaScript はシングルスレッドモデルですし、イベントループの仕組みを使って非同期処理を行うようになっています。この C10K 問題に対する解として JavaScript はうってつけだったのです。</p>

<h3>Node とリアルタイムアプリケーション</h3>

<p>HTML5 が世に広まり始めると、その仕様の一部として策定されていた <strong>WebSocket</strong> プロトコルが注目されるようになってきました。（現在では HTML5 とは独立した仕様になっています。）</p>

<p>WebSocket は HTTP 通信とは異なり、接続を維持したまま通信することが前提のプロトコルです。接続確立時には HTTP をつかいますが、その後の通信では独自のプロトコルを使います。
そのため、WebSocket でリアルタイム通信を行おうとするとサーバ側も対応しなければならず、大掛かりになりがちでした。</p>

<p>Node はプログラム内にサーバ機能を実装可能であるという特徴から、WebSocket 用のモジュールが用意されました。
これらのモジュールを使うことで簡単に WebSocket を利用したアプリケーションが構築できるようになりました。</p>

<p>こうして、リアルタイム通信を行うなら Node という方程式が出来上がったのです。</p>

<h3>Node のプログラム</h3>

<p>Node はイベントループが回ることですべての処理をさばきます。Node のプログラムは <strong>必要なイベントハンドラを登録し、適切なタイミングでイベントを発生させる</strong> ことで成立しています。
これは、ブラウザ上の JavaScript とほとんど同じプログラムコードになります。</p>

<h2>モジュール</h2>

<p>Node のモジュールは JavaScript で記述されたファイルか、アドオンと呼ばれる C/C++ で記述されコンパイルされたファイルで構成されます。</p>

<p>Node では <strong>1つのファイルは必ず1つのモジュールに対応します</strong>。
あるファイルをモジュールとして利用可能にするには <code>module</code> オブジェクトか <code>exports</code> オブジェクトを使って必要な関数、オブジェクトを公開します。</p>

<pre><code class="javascript">module.exports = {
  funcA: function() {
  }
};

function funcB() {
}
module.exports.funcB = funcB;

// exports を外部公開オブジェクトとして定義する場合は慣例として次のように書く
module.exports = exports = {
  foo: 'bar',
  funcA: function() {
  }
};
</code></pre>

<h2>感想</h2>

<p>Node とはなにか？Node の仕組みを知りたい、Node を始めたいという人向けのタイトル通りの「入門」書だと思いました。
実際に使われているモジュールやフレームワークの説明なども入っているので、コレ一冊でとりあえず Node を始められるようになっています。
ここから始めて見て、壁にあたったら次の参考書を読んでみるという感じがいいんじゃないかと思います。</p>

<p>内容としては、プログラミング知識がある人（とくに JavaScript）なら、優しすぎず難しすぎずという感じです。</p>

<h2>目次</h2>

<ol>
<li>Node とは何か

<ol>
<li>非同期プログラミング</li>
<li>なぜ従来から非同期プログラミングが行われてこなかったのか</li>
<li>Node の誕生と既存の言語</li>
<li>JavaScript である理由</li>
<li>シングルスレッドの強み</li>
<li>Node とリアルタイムアプリケーション</li>
</ol>
</li>
<li>インストール

<ol>
<li>OS ごとのインストール方法</li>
<li>環境構築ツールを使う</li>
<li>npm を使ったパッケージのインストール</li>
</ol>
</li>
<li>開発環境

<ol>
<li>エディタ</li>
<li>IDE</li>
</ol>
</li>
<li>Node入門

<ol>
<li>Node コマンド</li>
<li>イベントループ</li>
<li>HTTP サーバ</li>
<li>イベントループの落とし穴</li>
<li>まとめ</li>
</ol>
</li>
<li>モジュール

<ol>
<li>モジュールの作り方</li>
<li>モジュールの使い方</li>
<li>モジュール活用</li>
</ol>
</li>
<li>イベント

<ol>
<li>Node とイベント駆動プログラミング</li>
<li>イベントの作成と利用</li>
<li>リスナ配列</li>
<li>特殊なイベント</li>
<li>シグナルとイベント</li>
<li>まとめ</li>
</ol>
</li>
<li>イベントループとprocess.nextTick()

<ol>
<li>Node のイベントループの仕組み</li>
<li>非同期イベントの生成</li>
<li>非同期コールバックの呼び出し</li>
</ol>
</li>
<li>ストリーム、バッファ、ファイルシステム

<ol>
<li>ストリーム</li>
<li>Buffer</li>
<li>ファイルシステム</li>
</ol>
</li>
<li>ソケット（TCP/UDP）

<ol>
<li>net モジュール</li>
<li>TCP サーバの概要</li>
<li>TCP クライアントの概要</li>
<li>TCP エコーサーバ・クライアントの実装</li>
<li>TCP と同期プロトコル</li>
<li>drain イベントを利用したデータ送信制御</li>
<li>TLS 通信の利用</li>
<li>OS のTCP 機能と直接関わるAPI</li>
<li>dgram モジュール</li>
</ol>
</li>
<li>HTTP/HTTPS

<ol>
<li>http モジュール</li>
<li>http.Server のエコーサーバの実装</li>
<li>HTTP RESTful サーバの実装</li>
<li>HTTP クライアントの概要</li>
<li>https モジュール</li>
<li>url モジュール</li>
<li>querystring モジュール</li>
</ol>
</li>
<li>Domain

<ol>
<li>domain モジュールの概要</li>
<li>domain モジュールのクラス</li>
<li>ドメインへのオブジェクトと関数の結びつけ</li>
<li>Implicit Binding</li>
<li>Explicit Binding</li>
<li>ドメインを利用したエラーページの表示</li>
</ol>
</li>
<li>ユニットテスト

<ol>
<li>はじめに</li>
<li>assert</li>
<li>should</li>
<li>chai</li>
<li>mocha</li>
<li>vows</li>
</ol>
</li>
<li>デバッグ

<ol>
<li>デバッガの基本機能</li>
<li>組み込みデバッガを利用したCUI でのデバッグ</li>
<li>Node Inspector を利用したGUI でのデバッグ</li>
<li>組み込みデバッガとNode Inspector の使い分け</li>
<li>IDE でのデバッグ</li>
<li>その他のサードパーティのデバッグモジュール</li>
</ol>
</li>
<li>実践編導入

<ol>
<li>実践編で扱う技術について</li>
<li>共通して扱うモジュール</li>
</ol>
</li>
<li>Express入門

<ol>
<li>はじめに</li>
<li>Express の導入</li>
<li>Connect のアーキテクチャ</li>
<li>Express のアーキテクチャ</li>
</ol>
</li>
<li>Express を用いたフォーラムアプリケーションの作成

<ol>
<li>はじめに</li>
<li>ルーティング</li>
<li>データの永続化</li>
<li>その他のリクエストメソッド</li>
<li>ビューの改善</li>
<li>エラー処理</li>
<li>ミドルウェア</li>
<li>ユーザー登録とログインの実装</li>
<li>セッション</li>
<li>ルートミドルウェア</li>
<li>remember me の実装</li>
<li>Tips</li>
<li>終わりに</li>
</ol>
</li>
<li>Socket.IO を使ったファイル共有アプリケーションの作成

<ol>
<li>はじめに</li>
<li>準備</li>
<li>ユーザー名の指定</li>
<li>チャンネルの実装</li>
<li>ファイルの送信</li>
<li>ファイルの受信</li>
<li>ファイルの永続化</li>
<li>ファイルの配信</li>
<li>終わりに</li>
</ol>
</li>
<li>外部API との連携

<ol>
<li>ハッシュタグストリーミング</li>
<li>今一緒にいる人を一括フォロー</li>
<li>終わりに</li>
</ol>
</li>
<li>Node はどう作られているか

<ol>
<li>JavaScript とNode</li>
<li>C10K とNode</li>
<li>Web アプリケーションアーキテクチャとしてのNode</li>
</ol>
</li>
<li>非同期プログラミングの改善

<ol>
<li>はじめに</li>
<li>コールバック関数の問題</li>
<li>コールバック関数の改善</li>
<li>まとめ</li>
</ol>
</li>
<li>アドオンの作成

<ol>
<li>概要</li>
<li>シンプルなHelloWorld のサンプル（オブジェクトの作成）</li>
<li>メソッドを持つアドオンのサンプル</li>
</ol>
</li>
<li>npm パッケージ

<ol>
<li>チュートリアル</li>
<li>パッケージの公開</li>
<li>パッケージの詳細</li>
<li>まとめ</li>
</ol>
</li>
<li>スケーラビリティ

<ol>
<li>複数プロセスの起動</li>
<li>複数サーバでのスケールアウト</li>
<li>終わりに</li>
</ol>
</li>
<li>運用

<ol>
<li>Apache やNginx との連携</li>
<li>環境</li>
</ol>
</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[サードパーティJavaScript]]></title>
    <link href="http://hamasyou.com/blog/2014/02/23/third-party-javascript/"/>
    <updated>2014-02-23T17:47:39+09:00</updated>
    <id>http://hamasyou.com/blog/2014/02/23/third-party-javascript</id>
    <content type="html"><![CDATA[<p>サードパーティ JavaScript とは <em>異なる Web アドレスから配信される、独立したクライアントコード</em> のことを意味します。
例えばソーシャルウィジェットやアナリティクス用のトラッカーがそうです。
本書はこのサードパーティ JavaScript をどのように開発するとよいかについて書かれています。</p>

<p>サードパーティ JavaScript には様々な難しいポイントがあります。</p>

<ul>
<li>動的なスクリプト読み込み</li>
<li>サードパーティ Cookie の保存と読み込み</li>
<li>HTTP / HTTPS を使ったサーバとの通信</li>
</ul>


<p>多くの人に使われる JavaScript を開発するには、<strong>数多くの落とし穴や難関を乗り越えなければなりません</strong>。
本書はこういった落とし穴や難関に対する解決策を手順を追って説明してくれます。</p>

<p>本書の著者の一人は <a href="http://disqus.com/">Disqus</a> という Web サイトに即席のコメントシステムを導入することができる JavaScript アプリケーションを開発しています。
実際に世界中で使われているアプリケーションの経験を元に書かれているので説得力がありますし、「こんな事にも注意しないといけなかったのか！」といった目からウロコな内容も盛りだくさんでおすすめです。</p>

<p>本書を読み終わると「<span class="lead"><strong>IE 無くなったらいいのに！</strong></span>」って絶対に思います。そして「<span class="lead"><strong>iframe すげーな。使えるやつだ</strong></span>」って思います（笑</p>

<!-- more -->


<p>以下、おぼえがきとメモです。</p>

<p><nav id="toc" role="navigation"></nav></p>

<h2>サードパーティ JavaScript 入門</h2>

<p>サードパーティ JavaScript の例には次のようなものがあります。</p>

<ul>
<li>埋め込みウィジェット</li>
<li>分析と計測</li>
<li>Web サービス API のラッパー</li>
</ul>


<h3>サードパーティ JavaScript 開発が難しい理由</h3>

<h4>未知のコンテキスト</h4>

<p>JavaScript が読み込まれたときに、読み込まれた先（パブリッシャ）のページの環境がどのようになっているかがわかりません。
JavaScript の読み込まれる位置が <code>&lt;head&gt;</code> タグだったり、<code>&lt;body&gt;</code> タグの一番最後かもしれません。<code>&lt;head&gt;</code> タグがない可能性もあります。
<strong>ブラウザに依存するような状況に依存したコードは書くべきではありません</strong>。</p>

<p>ウィジェットを開発しているのであれば、正しく表示されるかも問題になります。
表示されるページの CSS に干渉してしまうようなスタイルの定義も問題になります。</p>

<p>共通して言えることは、サードパーティ JavaScript は外部の環境に依存するべきではないし、<strong>外部の環境を壊すようなことはあってはならない</strong> ということです。</p>

<h4>共有されている JavaScript 環境</h4>

<p>Web 環境では、JavaScript が実行される環境はグローバルな環境が一つしかありません。グローバル環境を汚さないようにしなければいけませんし、他の JavaScript に壊されることがないように防衛する必要もあります。</p>

<h4>ブラウザによるクロスドメイン制限</h4>

<p>ブラウザの同一生成元ポリシーによって、<code>XmlHttpRequest</code> は表示しているページと異なるドメインへアクセスするのを妨げられてしまいます。また、サードパーティ Cookie の保存や読み込みも制限していることが普通です。</p>

<h2>開発の足場</h2>

<h3>複数のドメインをシミュレートする開発環境</h3>

<p>クロスドメインの問題はかなり厄介な問題ですので、開発時点から複数ドメインをシミュレートするのは役にたちます。
OS の <code>hosts</code> ファイルを編集して、localhost の エイリアスを二つ用意するだけでこの環境が手に入ります。</p>

<pre><code class="plain-raw hosts">127.0.0.1 publisher.dev
127.0.0.1 widget.dev
</code></pre>

<p><em>「.dev」のような存在しないトップレベルドメインを使う方が、実際に存在する Web サイトのアドレスを差してしまう問題がないので便利</em> です。</p>

<h3>スクリプトを読み込むスニペット</h3>

<p>パブリッシャのページに最初のスクリプトを読み込むスニペットを用意します。スニペットを提供する方法は2つあります。</p>

<ul>
<li>「ブロッキング」を行うタイプの <code>script</code> タグによる読み込み</li>
<li>非同期でスクリプトを読み込むタイプ</li>
</ul>


<h4>ブロッキング読み込み</h4>

<p>```html</p>

<script src="http://camerastock.com/widget.js?product=1234"></script>


<pre><code>
#### ノンブロッキング読み込み

上のようなタグは、そのスクリプトが読み込まれるまでブラウザの処理をとめてしまいます。そのため、このようなスクリプトは `&lt;body&gt;` タグの最後におくことや、`defer` 属性、`async` 属性を使うことで回避できます。
`defer` 属性、`async` 属性をスクリプトタグに指定することで、そのスクリプトが文書のコンテンツを生成しない（`document.write` を使わない）のでページブロッキングをしなくても完全にダウンロードが可能であるとブラウザに伝えることができます。
</code></pre>

<script defer src="http://camerastock.com/widget.js?product=1234"></script>


<script async src="http://camerastock.com/widget.js?product=1234"></script>


<pre><code>
defer 属性
: `defer` 属性が指定されたスクリプトは、**ページが完全に解析された後** に実行が開始されます。
async 属性
: `async` 属性が指定されたスクリプトは、**ダウンロードが完了したすぐ直後** から実行が開始されます。

JavaScript を使って DOM 上に `script` 要素を動的に生成することでも、`async` 属性と同じ挙動でスクリプトを読み込ませることができます。
</code></pre>

<script>
(function() {
  var node     = document.getElementsByTagName('script')[0],
      script   = document.createElement('script');

  script.src   = 'http://camerastock.com/widget.js?product=1234';
  script.async = true;
  node.parentNode.insertBefore(script, node);
})();
</script>


<pre><code>
### 最初のスクリプトファイル

最初の JavaScript ファイルの中身はこんな感じになります。
</code></pre>

<p>var Stork = (function(window, undefined) {
  var Stork = {};</p>

<p>  return Stork;
})(window);
```</p>

<p>一番外側の <code>Stork</code> はアプリケーションをカプセル化するための名前空間オブジェクトです。<code>window</code> と <code>undefined</code> を引数に取っています。これは、<em>よく使う変数をローカル変数として定義することで、JavaScript のミニファイアが働くようになり変数名を短くすることができる</em> からです。
また、<code>undefined</code> はオリジナルの <code>undefined</code> が他の環境によって書き換えられていても問題ないようにするためのテクニックになります。この二つは、<em>JavaScript ライブラリの作者が非常によく使うテクニック</em> になります。</p>

<h3>loadScript 関数</h3>

<p>外部の JavaScript ライブラリを使いたい場合は、パブリッシャにそのスクリプトを読み込んでもらうようにするのはナンセンスです。
パブリッシャに依存ライブラリを追加してもらうのでは、依存ライブラリに変更が入った際にパブリッシャに変更を依頼しなければならなくなります。</p>

<p><em>サードパーティ JavaScript の開発者は依存ライブラリは外部に依存しない形で利用するようにするのが求められます</em>。次のコードは非同期の JavaScript ローダ関数です。必要なスクリプトの読み込みが完了したら、引数の <code>callback</code> 関数を呼び出します。</p>

<pre><code class="javascript">function loadScript(url, callback) {
  var node   = document.getElementsByTagName('script')[0],
      script = document.createElement('script');

  script.src   = url;
  script.async = true;
  node.parentNode.insertBefore(script, node);

  script.onload = script.onreadystatechange = function() {
    var readyState = script.readyState;

    if (!readyState || /complete|loaded/.test(script.readyState)) {
      callback();
      script.onload = script.onreadystatechange = null;
    }
  };
}
</code></pre>

<p>このように、必要なライブラリは、アプリケーションが実行する前に読み込んでおくようにします。</p>

<h4>ライブラリの衝突に注意</h4>

<p>jQuery のようなよく使われるライブラリをこの方法で読み込む際には、すでに存在するオブジェクトと衝突しないように注意しなければなりません。
衝突を防ぐには <strong>名前空間</strong> を使います。jQuery の場合には衝突を避ける <code>noConflict</code> が用意されているので、これを使います。</p>

<pre><code class="javascript">var Stork = Stork || {};
Stork.$ = Stork.jQuery = jQuery.noConflict(true);
</code></pre>

<p>外部ライブラリを使う場合には、既に読み込まれていても衝突しないように注意する必要があります。</p>

<h2>HTML と CSS のレンダリング</h2>

<h3>スタイルを調整する方法</h3>

<p>HTML にスタイルを追加で当てる方法には3つの基本的な方法が考えられます。</p>

<ol>
<li>HTML にインラインでスタイルを当てる</li>
<li>関連する CSS ファイルを別途動的に読み込む</li>
<li>JavaScript にスタイルシートのルールを埋め込む</li>
</ol>


<h4>1. インラインスタイル</h4>

<p>インラインスタイルは他の要素のスタイルと干渉する心配がありません。デメリットは一般の Web サイトでインラインスタイルを使うべきでない理由と同じになります。</p>

<h4>2. CSS ファイルをロードする</h4>

<p>CSS ファイルを動的にロードする方法は、JavaScript を動的にロードする方法とほとんど同じになります。</p>

<pre><code class="javascript">function loadStylesheet(url) {
  var node = document.getElementsByTagName('script')[0],
      link = document.createElement('link');
  link.rel  = 'stylesheet';
  link.type = 'text/css';
  link.href = url;

  node.parentNode.insertBefore(link, node);
}
</code></pre>

<p><code>link</code> タグは <code>rel</code> 属性と <code>type</code> 属性はどちらも必須の属性になります。
CSS が読み込まれたタイミングを知りたい場合には、少し変わった方法が必要になります。ブラウザによっては、<code>link</code> タグは <code>script</code> タグのように読み込みが終わったタイミングで <code>load</code> イベントを発生させない場合があるからです。
CSS が読み込まれたかどうかをチェックするには、要素にスタイルが当たったかどうかを定期的にチェックする必要があります。</p>

<p><blockquote><p>JavaScript やその他のデータを読み込むためのライブラリである Yepnope.js では、document.styleSheets を使って新しく挿入されたスタイルシートをスキャンする方法をとっている。</p></blockquote></p>

<h5>JavaScript で要素の色を調べるときは注意！</h5>

<p><strong>JavaScript で要素の色を調べるときは注意が必要です</strong>。<em>廃止予定のマイクロソフトのアクセサはオリジナルの16進数の値を返します</em>。<em>W3C のアクセサは16進数の値を RGB 表現に変換して返します</em>。</p>

<h4>3. CSS を JavaScript 中に埋め込む</h4>

<p>JavaScript の文字列に CSS を含めてしまう方法です。</p>

<h3>防衛的な HTML と CSS</h3>

<p>サードパーティ CSS においては、名前空間 (prefix) をつけるようにするとよいです。</p>

<pre><code class="css">.stork-container { width: 200px; height: 200px; }
</code></pre>

<h4>CSS 優先順位</h4>

<p>CSS が優先的に当たるルールは次のとおりです。</p>

<ol>
<li>インラインのスタイル(style=&ldquo;&hellip;&rdquo;)</li>
<li>ID</li>
<li>クラス、属性および擬似クラス(:forcus, :hover)</li>
<li>要素(div, span など)、擬似要素(:before, :after)</li>
</ol>


<p>ただし、<code>!important</code> というキーワードでタグ付けされたプロパティは優先順位が最も高くなります。</p>

<pre><code class="css !important の例">.stork-price {
  font-size:       11px  !important;
  color:           #888  !important;
  text-decoration: none  !important;
  display:         block !important;
}
</code></pre>

<p>ブラウザはスコアシステムを使ってどのルールが優先されるかを計算しています。</p>

<table>
<thead>
<tr>
<th> セレクタ / ルールタイプ  </th>
<th> スコア (a, b, c, d) </th>
</tr>
</thead>
<tbody>
<tr>
<td> インラインの style 属性  </td>
<td> 1, 0, 0, 0 </td>
</tr>
<tr>
<td> ID                       </td>
<td> 0, 1, 0, 0 </td>
</tr>
<tr>
<td> クラス、擬似クラス、属性 </td>
<td> 0, 0, 1, 0 </td>
</tr>
<tr>
<td> 要素、擬似要素           </td>
<td> 0, 0, 0, 1 </td>
</tr>
</tbody>
</table>


<p>スコアは <code>a &gt; b</code>、<code>b &gt; c</code>、<code>c &gt; d</code> のように価値が高くなります。(1, 0, 0, 0) は (0, 100, 0, 0) よりも優先されるということです。</p>

<ul>
<li><code>.stork-container</code> (0,0,1,0 - クラスセレクタ1つ)</li>
<li><code>.stork-container span</code> (0,0,1,1 - クラスセレクタ1つ、要素セレクタ1つ)</li>
<li><code>.stork-container .strok-msg</code> (0, 0, 2, 0 - クラスセレクタ2つ)</li>
</ul>


<h4>CSS を過剰に指定すれば優先度は高くなる</h4>

<p>パブリッシャのスタイルよりも優先的にスタイルを当てるための簡単な方法は、過剰にルールを指定することです。</p>

<p>```html</p>

<div id="stork-main">
  <div id="stork-container">
    <h3 class="stork-product">Mikon E90 Digital SLR</h3>
    <img src="http://camerastork.com/img/products/1337-small.png" />
    <p class="stork-price">$599</p>
    <p class="stork-rating">4.3/5.0 &bull; 176 Reviews</p>
  </div>
</div>


<pre><code></code></pre>

<h1>stork-main #stork-container { &hellip; }</h1>

<h1>stork-main #stork-container .stork-product { &hellip; }</h1>

<h1>stork-main #stork-container .stork-price { &hellip; }</h1>

<pre><code>

### コンテンツを iframe に埋め込む

*パブリッシャのスタイルルールによる影響を受けずにスタイルを設定する方法は、`iframe` を使うこと* です。

#### src なし iframe

`src` 属性を指定しない `iframe` を作る場合、独立したウィンドウと DOM 環境を有しているという点で強力な効果があります。そして、**親ページで実行されているスクリプトは直接それらのオブジェクトにアクセスが可能** です。
`iframe` はブラウザによって非同期的に処理されるため、`document.write` のようなブロッキングが発生する処理を `iframe` の中で行ってもブラウザが親ページを処理するのを妨げることはありません。
ただし1つ注意点は、*親ページの `onload` イベントはブロッキングしてしまう* 点です。これは、`iframe` のレンダリングが完了したあとで、`document.close()` を呼び出すことで `onload` を強制的に発生させることで回避できます。

#### 外部 iframe

`iframe` のコンテンツが外部から提供されている場合には *ブラウザは親ページでホストされているスクリプトがそのコンテンツにアクセスすることを許可しません*。


## サーバとの通信

サードパーティアプリケーションでは、**クロスドメイン** の問題を扱わなければなりません。クロスドメイン対応には基本的なテクニックがあります。

- JSONP
- サブドメインプロキシ
- クロスオリジンリソース共有 (CORS)

### AJAX とブラウザの同一生成元ポリシー (SOP)

ブラウザは異なる生成元から配信されたドキュメントがそれぞれお互いに分離されることを保証するという、**同一生成元ポリシー (SOP) ** を備えています。
これによって、ドキュメント上のスクリプトが他のドキュメントにアクセスできるのは *同じドメイン*、*同じポート*、*同じプロトコル* である場合に限ることになります。

すべてのブラウザが、`XMLHttpRequest`、`iframe`、それ以外のドキュメント間のメッセージのやり取りの方法についてこの同一生成元ポリシーを適用しています。

重要な点が1つあります。**HTML の script 要素は SOP の適用を受けません**。つまり、外部の JavaScript ファイルの読み込みは可能になっています。
ただし、*読み込まれた JavaScript はパブリッシャのコンテキストで実行されるということは注意が必要* です。
例えば、camerastork.com の widget.js を publisher.dev の index.html で読み込まれたとしても、widget.js は camerastork.com への `XmlHttpRequest` を開始できません。


### JSONP

SOP は「HTML の script 要素はチェックの対象外」という重要な例外をもっています。この例外を使って、例えば次のような JSON データを返す URL を script 要素を使って読み込んでみます。
</code></pre>

<p>{
  &ldquo;title&rdquo;: &ldquo;Third-party JavaScript&rdquo;,
  &ldquo;authors&rdquo;: [&ldquo;Anton&rdquo;, &ldquo;Ben&rdquo;],
  &ldquo;publisher&rdquo;: &ldquo;Manning&rdquo;
}
```</p>

<p>```html</p>

<script src="http://thirdpartyjs.com/info.json"></script>


<pre><code>
この読み込みはうまくいきます。ただし、問題は、info.json は JavaScript として実行されるということです。
info.json は JavaScript としては正しい構文ではありませんし、もし正しく JavaScript オブジェクトとして評価されたとしても、どこからも使われずに終わってしまいます。

そこで、info.json を次のように変更します。
</code></pre>

<p>var jsonResponse = {
  &ldquo;title&rdquo;: &ldquo;Third-party JavaScript&rdquo;,
  &ldquo;authors&rdquo;: [&ldquo;Anton&rdquo;, &ldquo;Ben&rdquo;],
  &ldquo;publisher&rdquo;: &ldquo;Manning&rdquo;
};
```</p>

<p>こうすると、JavaScript として正しい評価がされ、スクリプトの実行が終わると、グローバルの <code>jsonResponse</code> 変数にオブジェクトが設定され使えるようになります。
変数ではなく、関数を呼び出すこともできます。そして、<strong>JSONP</strong> というのは、この <em>script を読み込む際に URL のクエリパラメータを使って呼び出し元がコールバック関数を指定できる仕組み</em> のことになります。</p>

<pre><code class="javascript">
function jsonpCallback(json) {
  console.log(json);
}

var script = document.createElement('script');
script.async = true;
script.src   = 'http://thirdpartyjs.com/info.js?callback=jsonpCallback';
document.body.appendChild(script);
</code></pre>

<h4>JSONP の制限</h4>

<p>JSONP は <strong>GET リクエストでのみ利用可能</strong> です。RESTful API を提供しているような場合、JSONP に合わせて GET のエンドポイントを用意していあげる必要が出てくるかもしれません。</p>

<p><em>JSONP リクエストは必ず非同期で処理されます</em>。ほとんどないとは思いますが、もしブロッキングが必要になった場合は、JSONP では不可能です。</p>

<h3>サブドメインプロキシ</h3>

<p>SOP は生成元のホスト部分を厳密に区別しています。<code>sub.example.com</code> と <code>example.com</code> は上位レベルのドメインは同じ (example.com) ですが、ブラウザは無関係なドメインとみなします。</p>

<p>デフォルトの動作はこうなりますが、ブラウザは <strong>Web サイトが生成元のホスト名をその上位ドメインに設定することを許可しています</strong>。
そのため、sub.example.com と alt.example.com のような共通の上位ドメインをもつサイト同士であれば両方の生成元を example.com に設定することでお互いに通信することができるようになります。</p>

<p>もし、企業向けの限られた環境だけで使うような JavaScript を作るのであれば、サブドメインの CNAME を割り当ててもらい、同一生成元を上位ドメインに設定することで通信可能にできるかもしれません。</p>

<h4>document.domain を利用してドキュメントの生成元を変更する</h4>

<p>ドキュメントの生成元を変えるには次のようなスクリプトを実行します。</p>

<pre><code class="javascript">document.domain = 'example.com';
</code></pre>

<p>生成元変更にはいくつか注意点があります。</p>

<ul>
<li>生成元を変更するスクリプトは <code>example.com</code> と <code>sub.example.com</code> の <strong>両方</strong> で行う必要がある</li>
<li><code>document.domain</code> を変更できるのは <strong>ページあたり1回だけ</strong></li>
<li><code>document.domain</code> を変更することで、<strong>生成元のポートは80にリセット</strong> される</li>
</ul>


<h4>AJAX から呼び出すためのサブドメイントンネルファイル</h4>

<p><code>document.domain</code> を変更することでドキュメントの生成元を変更することができるようになりましたが、まだこれだけでは AJAX を使ってサブドメインのドキュメントを読み込むことはできません。
<em>AJAX においては、まずリクエストを送ってみない限り取得するドキュメントが同じドメインに参加しようとしているかを知ることができない</em> からです。
CORS の仕様では特別なヘッダを使ってプリフライトリクエストを行うことでこの問題を解決していますが、ここではトンネルファイルを使った方法を見ていきます。</p>

<h5>非表示の iframe を使う</h5>

<p>AJAX リクエストを呼び出すページが呼び出し先のドメインと同じであればリクエストを送ることができますので、予め呼び出し先のドキュメントを同一生成元を変更して読み込めていれば、そのドキュメントを使って AJAX リクエストを送ることができます。</p>

<p>それが、<em>非表示の iframe を使う方法</em> です。非表示の iframe で生成元を変更するスクリプトが書かれたページを読み込み、そのページから AJAX リクエストを送るようにするのです。
そうすれば、サブドメインプロキシを通じて、トンネルファイルの iframe 上の非表示ドキュメントから AJAX リクエストを呼び出すことができ、iframe 上のドキュメントと親ページは同じ同一の生成元にいるのでデータの受け渡しも可能になるという仕組みができます。</p>

<p><img src="/images/2014-02-23-third-party-javascript-01.png" alt="サブドメイントンネルファイル" /></p>

<h5>JSONP と動的フォームを使う</h5>

<p>AJAX リクエストを送るためには非表示の iframe をもちいた中間ファイルが必要になります。中間ファイルを用いない方法として、動的にフォームを作成して、フォームをリクエストするという方法があります。</p>

<p><code>form</code> タグには <code>target</code> 属性が用意されているので、動的にフォームを作る際に結果を受け取るための <code>iframe</code> を作成して、その iframe をターゲットにフォームをポストするといいです。</p>

<h4>Google のブラウザセキュリティハンドブック</h4>

<p>同一生成元ポリシーやそれに伴うセキュリティ上のリスクをもっとよく知りたい場合は、Google の「ブラウザセキュリティハンドブック」のパート2を読むとよいです。</p>

<p><a href="https://code.google.com/p/browsersec/wiki/Part2">ブラウザセキュリティハンドブック Part2</a></p>

<h3>クロスオリジンリソース共有 (CORS)</h3>

<p><strong>クロスオリジンリソース共有 (CORS)</strong> は W3C のワーキングドラフトになっている、きちんと管理された形でドメインをまたがってサーバと通信を行う方法を定めたものです。</p>

<p>CORS では一連の特別な HTTP ヘッダを使ってブラウザとサーバがやり取りを行えるかどうかを決定するようになっています。</p>

<h4>Origin リクエスト</h4>

<p>クロスオリジンの HTTP リクエストを開始する際には、CORS に対応したブラウザは <code>Origin</code> と呼ばれる特殊なヘッダを含むリクエストを使って生成元を示すことになっています。</p>

<pre><code class="plain-raw">Origin: http://www.example.com/
</code></pre>

<p>サーバ側はこのヘッダをチェックして、そのリクエストが許可されるかどうかを決定します。応答するには、サーバは <code>Access-Control-Allow-Origin</code> というレスポンスヘッダにクライアントが送ったのと同じ生成元を入れて返さなければなりません。</p>

<pre><code class="plain-raw">Access-Control-Allow-Origin: http://www.example.com/
</code></pre>

<p>あらゆるところからリクエストを許可するにはワイルドカードを使うこともできます。</p>

<pre><code class="plain-raw">Access-Control-Allow-Origin: *
</code></pre>

<p>リクエストを許可しない場合は、サーバ側は CORS ヘッダを返さないようにします。また、リクエストに <code>Origin</code> ヘッダが存在していない場合は、サーバも CORS ヘッダを送り返すべきではないとされています。</p>

<h4>CORS で Cookie や認証ヘッダを送信する</h4>

<p>デフォルトでは、ブラウザは CORS を行う際には Cookie や HTTP 認証ヘッダを送らないようになっています。
こうした識別情報を送信するべきであると明示する場合には、<code>XmlHttpRequest</code> オブジェクトに <code>withCredentials</code> プロパティを設定します。</p>

<pre><code class="javascript">var xhr = new XmlHttpRequest();
xhr.withCredentials = true;
</code></pre>

<p>サーバ側は、識別情報を必要としている場合には <code>Access-Control-Allow-Origin</code> ヘッダに加えて、<code>Access-Control-Allow-Credentials</code> というヘッダもレスポンスに含める必要があります。
このヘッダがないと、ブラウザはレスポンスを拒否していしまいます。</p>

<pre><code class="plain-raw">Access-Control-Allow-Credentials: true
</code></pre>

<h2>クロスドメインでの iframe 間通信</h2>

<p>パブリッシャのページ上で実行されるアプリケーションコードと iframe 内のサードパーティのドメインで配信されているページとの間でドキュメントをやり取りする方法です。</p>

<h3>HTML5 window.postMessage API</h3>

<p><code>window.postMessage</code> はイベントを利用した安全なクロスドメイン通信 API です。
メッセージを送りたいウィンドウオブジェクトを取得して、<code>postMessage</code> を送るだけです。
送られる側はウィンドウの <code>message</code> イベントで受け取ります。</p>

<p>```html http://publisher.dev/index.html
&lt;!DOCTYPE html>
<html>
<body></p>

<h1>Publisher</h1>




<iframe id="thirdparty" src="http://thirdparty.dev/index.html">
</iframe>




<script>
var frame = document.getElementById('thirdparty');
frame.addEventListener('load', function(e) {
    var win = frame.contentWindow;
    win.postMessage('Hello World!', 'http://thirdparty.dev/');
});
</script>


<p></body>
</html>
```</p>

<p>```html http://thirdparty.dev/index.html
&lt;!DOCTYPE html>
<html>
<body></p>

<h1>thirdparty</h1>


<script>
function receiver(e) {
    console.log(e.data);
    console.log(e.origin);
    console.log(e.source);
}
window.addEventListener('message', receiver, false);
</script>


<p></body>
</html>
```</p>

<h3>easyXDM を利用したクロスドメインメッセージング</h3>

<p><a href="http://easyxdm.net/wp/">easyXDM</a></p>

<p>クロスドメイン間でメッセージをやり取りするためのライブラリに <strong>easyXDM</strong> があります。
このライブラリは複数の異なるクロスドメインメッセージングのテクニックを組み合わせて、そのなかかkらそれぞれのブラウザに適したものを選択してくれます。</p>

<h2>メモ</h2>

<h3>ポップアップブロック機能を回避する方法</h3>

<p><blockquote><p>これを避けるには、新しいウィンドウを常に<strong>ユーザーのアクションの直接の結果</strong>として開くようにすることだ。ユーザーのアクションからウィンドウを開くまでの間に遅延が存在すると、多くのブラウザはそれを悪意ある動作とみなして処理を阻止してしまう。</p></blockquote></p>

<h2>感想</h2>

<p>読んでみて、<strong>本書はサードパーティ JavaScript を書かなくても、サーバ側の API を実装するだけの人も読むべき</strong> だと思いました。
クロスオリジン問題やセキュリティに関する話題も豊富に書かれていて、全てが有用な情報です。</p>

<p>ブラウザとサーバがどんなことをやっているのかをきちんと理解したい人は、是非よんでみてください。絶対に為になります。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScriptで学ぶ関数型プログラミング]]></title>
    <link href="http://hamasyou.com/blog/2014/02/21/functional-javascript/"/>
    <updated>2014-02-21T19:39:56+09:00</updated>
    <id>http://hamasyou.com/blog/2014/02/21/functional-javascript</id>
    <content type="html"><![CDATA[<p><blockquote><p>本書はJavaScriptを使って関数型プログラミングを学ぶ書籍です。関数型言語としてJavaScriptを理解し、使用することにより、コードがより洗練され、美しく、そして読みやすいものになることを目的としています。JavaScriptビルトインのデータ型を上手に利用するための基本知識やJavaScriptにおける関数の持つ特性など、関数型プログラミングの技術とその考え方について解説します。また実際のJavaScriptコーディングに関数型プログラミングのエッセンスを加えるポイントをサンプルを使って丁寧に説明します。関数型プログラミングに精通した著者が書き下ろした本書は、テクニックを増やし、コーディングのイマジネーションを広げたいエンジニア必携の一冊です。</p><footer><strong>内容紹介</strong></footer></blockquote></p>

<p>JavaScript は純粋な関数型プログラミング言語ではありません。が、<strong>関数型言語として JavaScript を理解し使用することでコードがより洗練され、読みやすいものになる</strong> はずという筆者の考えがこの本には現れています。</p>

<p>JavaScript では関数型プログラミングは一つのスタイルにしかすぎず、必要な場面で適切に使うというアプローチをとることでよりよいコードや使いやすい関数になります。</p>

<!-- more -->


<h2>関数型プログラミング</h2>

<p><img src="/images/2014-02-21-functional-javascript-02.jpg" alt="関数型プログラミング" /></p>

<p>本書のおぼえがきです。本書の中から気になった箇所だけ抜き出しているので、意味が通じないかもしれません。。気になったら買って読んでみてください。</p>

<h3>関数型プログラミングとは</h3>

<p><blockquote><p>関数型プログラミングとは、値を抽象の単位に変換する関数を使用して行うプログラミングであり、それらを使ってソフトウェアシステムを構築することである。</p></blockquote></p>

<p>オブジェクト指向では、問題領域をオブジェクトという単位に分解して対処していきますが、関数型プログラミングでは、問題を <strong>関数</strong> のパーツに分解します。</p>

<p>オブジェクト指向のアプローチは問題を「<strong>名詞</strong>」に分解して行う傾向があるのに対して、関数型プログラミングでは、問題を「<strong>動詞</strong>」に分解する傾向があります。</p>

<p>関数を通して、与えられた値を「<strong>変換</strong>」することができます。</p>

<pre><code class="plain-raw">markdown → toHTML → postProcess → modifyDOM
         │        │             │
      テキスト   HTML       編集されたHTML
</code></pre>

<h3>高階関数</h3>

<p><strong>高階関数</strong> とは、関数を引数にとり新しい関数を生成して返す関数のことです。</p>

<p>例えば、JavaScript の Array には <code>sort</code> 関数があります。<code>sort</code> は引数に <code>compareFunction</code> を取ります。値の大小を比較する関数を <code>lessOrEqual</code>、この関数を <code>compareFunction</code> の仕様に変換する関数を <code>compare</code> とします。</p>

<pre><code class="javascript">function lessOrEqual(x, y) {
  return x &lt;= y;
}

function compare(func) {
  return function(x, y) {
    if (func(x, y)) {
      return -1;
    } else if (func(y, x)) {
      return 1;
    } else {
      return 0;
    }
  };
}

[100, 1, 0, 10, -1, -2, -1].sort(compare(lessOrEqual));
// =&gt; [-2, -1, -1, 0, 1, 10, 100]
</code></pre>

<p><code>compare</code> 関数は大小比較を行う関数を引数にとり、<code>compareFunction</code> の仕様に則った関数を生成して返す高階関数になります。</p>

<h3>JavaScript における関数型プログラミング</h3>

<ul>
<li>関数による抽象の定義（<code>existy</code> や <code>truthy</code>）</li>
<li>関数を他の関数の引数に渡すことによる新たな動作の実現</li>
</ul>


<pre><code class="javascript">function existy(x) { return x != null; }
function truthy(x) { return (x !== false) &amp;&amp; existy(x); }

[null, undefined, 1, 2, false].map(existy);
// =&gt; [false, false, true, true, true]
[null, undefined, 1, 2, false].map(truthy);
// =&gt; [false, false, true, true, false]
</code></pre>

<p>これこそが、<strong>関数型プログラミング</strong> です。関数型プログラミングは強力な <strong>データ抽象</strong> とともに実装されて役に立つものです。</p>

<h3>命令型プログラミングと関数型プログラミングの違いの例</h3>

<p>「99本のビール」の歌の歌詞を構築するプログラムを命令型プログラミングと関数型プログラミングで書いてみた例です。</p>

<pre><code class="javascript 命令型プログラミング">var lyrics = [];

for (var bottles = 99; bottles &gt; 0; bottles--) {
  lyrics.push(bottles + '本のビールが残ってる');
  lyrics.push(bottles + '本のビール');
  lyrics.push('ひとつ取って、隣に回せ');
  if (bottles === 1) {
    lyrics.push('もうビールは残ってない');
  }
}
</code></pre>

<p>関数型プログラミングのアプローチで書くとこうなります。</p>

<pre><code class="javascript 関数型プログラミング">// var _ = require('underscore');
function lyricsSegment(n) {
  return _.chain([])
    .push(n + '本のビールが残ってる')
    .push(n + '本のビール')
    .push('ひとつ取って、隣に回せ')
    .tap(function(lyrics) {
        if (n &lt; 1) {
          lyrics.push('もうビールは残ってない');
        }
    })
    .value();
}

function song(start, end, lyricGen) {
  return _.reduce(_.range(start, end, -1),
    function(acc, n) {
      return acc.concat(lyricGen(n));
    }, []);
}

song(99, 0, lyricSegment);
</code></pre>

<p><strong>命令型プログラミングは一度きりの実装となりがちで、再利用が難しいものになります</strong>。</p>

<h3>コレクション中心プログラミング</h3>

<p>関数型プログラミングは、<em>コレクションに入った多数のアイテムに同じ操作を適用するようなタスク</em> を行う際にとても便利です。</p>

<p>一般的な関数型プログラミングによって主張されるコレクション中心の考え方のポイントは、その処理を行うために一貫性のある語彙を確立し、包括的に揃えた関数を再利用出来るようにすることです。</p>

<p><blockquote><p>10種類のデータ構造上で10の関数を動かすよりも、ひとつのデータ構造上で100の関数を動かすほうがよい。</p><footer><strong>Alan Perlis</strong></footer></blockquote></p>

<p>関数型プログラミングでは、<strong>それぞれの関数がすこしずつデータを変換し、最後の解に至る</strong> ようにします。</p>

<h3>値ではなく、関数を使え</h3>

<p>ある値を何度か繰り返す関数はよい関数ですが、<strong>ある計算を何度か繰り返す関数のほうがよりよい</strong> 関数です。</p>

<pre><code class="javascript よい関数">function repeat(times, VALUE) {
  return _.map(_.range(times), function() { return VALUE; });
}

repeat(4, 'Major');
// =&gt; ["Major", "Major", "Major", "Major"]
</code></pre>

<pre><code class="javascript よりよい関数">function repeatedly(times, func) {
  return _.map(_.range(times), func);
}

repeatedly(4, function() { return 'Major'; });
// =&gt; ["Major", "Major", "Major", "Major"]
repeatedly(3, function() { return Math.floor((Math.random() * 10) + 1); });
// =&gt; [1, 3, 8]
</code></pre>

<h2>関数を作る関数を作る意義</h2>

<h3>カリー化</h3>

<p><img src="/images/2014-02-21-functional-javascript-01.jpg" alt="カリー化" /></p>

<p>カリー化された関数というのは、<em>引数を一つ受け取るたびに新しい関数を返す関数</em> のことです。<code>invoker</code> 関数はカリー化された関数といえます。</p>

<pre><code class="javascript カリー化された関数">invoker('reverse', Array.prototype.reverse)([1,2,3]);
// =&gt; [3,2,1]
</code></pre>

<p>JavaScript は変数の値の変更に対しておおらかな言語です。オブジェクト指向のカプセル化のような事をする場合、クロージャを使うと便利です。</p>

<p>クロージャを使うと、生成時のコンテキストにもとづいて特定の動作を行うように「<em>設定された</em>」関数を返すことができます。この設定された関数は外部からカプセル化されており、関数の抽象を高めます。</p>

<p>カリー化された関数も同じ考え方になります。</p>

<h3>JavaScript でカリー化を行う意味</h3>

<p>まず、シンプルな高階関数をつくります。関数を引数に取り、引数をひとつだけ取るように限定された関数を返す関数です。</p>

<pre><code class="javascript curry">function curry(func) {
  return function(arg) {
    return func(arg);
  };
}
</code></pre>

<p>JavaScript の関数は <strong>引数をいくら渡してもエラーになりません</strong>。そこで、いくつかの「<em>専門化を行う</em>」引数をオプションで取る場合がよくあります。</p>

<p>例えば <code>parseInt</code> という関数は、第2引数に n 進数の n をオプションで受け取ります。</p>

<pre><code class="javascript parseInt">parseInt('11');
// =&gt; 11
parseInt('11', 2);
// =&gt; 3
</code></pre>

<p><code>parseInt</code> を第一級関数として使うと第2引数が原因で混乱するケースがあります。</p>

<pre><code class="javascript">['11', '11', '11', '11'].map(parseInt);
// =&gt; [11, NaN, 3, 4]
</code></pre>

<p>JavaScript の <code>map</code> は与えられた関数の第1引数に <em>要素</em>、第2引数に <em>インデックス</em>、第3引数に <em>元の配列</em> を渡します。そのため、こんな結果になってしまいます。</p>

<p>ここで、先ほど定義した <code>curry</code> 関数を利用します。与えられた関数に一つだけ引数を渡すように強制してみます。</p>

<pre><code class="javascript">['11', '11', '11', '11'].map(curry(parseInt));
// =&gt; [11, 11, 11, 11]
</code></pre>

<p>引数を2つ取るようにする <code>curry2</code> は次のようになります。</p>

<pre><code class="javascript curry2">function curry2(func) {
  return function(secondArg) {
    return function(firstArg) {
      return func(firstArg, secondArg);
    };
  };
}

parseIntByBinary = curry2(parseInt)(2);
parseIntByBinary('111');
// =&gt; 7
parseIntByBinary('10');
// =&gt; 2
</code></pre>

<p>このように、<strong>カリー化は JavaScript の関数の動作を「専門化」させるための有効なテクニック</strong> になります。</p>

<h2>再帰</h2>

<p><img src="/images/2014-02-21-functional-javascript-03.jpg" alt="再帰" /></p>

<p>再帰が関数型プログラミングに重要である3つの理由。</p>

<ul>
<li>共通の問題のサブセットに単一の抽象を使用する</li>
<li>可変の状態を隠蔽することができる</li>
<li>遅延評価や無限データ構造の処理を行う手段のひとつ</li>
</ul>


<p>配列の長さを調べる関数を再帰の考え方で解くと。</p>

<ol>
<li>もし配列が空であれば長さは0</li>
<li>配列の最初の要素を取り出し、残りを自身の関数に渡した実行結果に1を加える</li>
</ol>


<pre><code class="javascript length">function length(array) {
  if (_.isEmpty(array)) {
    return 0;
  } else {
    return 1 + length(_.rest(array));
  }
}
</code></pre>

<p>再帰をうまく実装するヒントは、「<strong>値は大きな問題に内包された小さな問題によって組み立てられるものである</strong>」と認識することです。</p>

<p><em>基本的な場合を考える</em> ことで、分解の最初の一歩を踏み出しやすくなります。</p>

<h2>純粋関数と冪等とデータの不変性</h2>

<p><img src="/images/2014-02-21-functional-javascript-05.jpg" alt="データの普遍性" /></p>

<h3>純粋関数</h3>

<p><strong>純粋関数</strong> とは、その関数が外部に一切の影響を与えないことが静的に保証されている関数です。純粋性のルールはつぎのようになります。</p>

<ul>
<li>結果は引数として与えられた値からのみ計算される</li>
<li>関数の外部で変更される可能性のあるデータに一切依存しない</li>
<li>関数実行部の外側に存在する何かの状態を一切変更しない</li>
</ul>


<p><a href="https://github.com/k3kaimu/d-manual/blob/master/function.md#%E7%B4%94%E7%B2%8B%E9%96%A2%E6%95%B0pure">純粋関数</a></p>

<h3>冪等（べきとう）</h3>

<p>RESTful なアーキテクチャが一般化するにつれて <strong>冪等（べきとう）</strong> の考え方も一般に浸透してきました。冪等とは、<em>あるアクションを何度行っても一度行った場合とまったくおなじ効果をもたらす</em> というものです。冪等である関数は次の条件を満たします。</p>

<pre><code class="javascript 冪等な関数">someFunc(arg) == _.compose(someFunc, someFunc)(arg);
</code></pre>

<p>ある引数を与えて実行するということは、その関数を2回連続で呼び出しても同じ結果を返します。</p>

<h3>不変性</h3>

<p>JavaScript はダイナミックな言語です。<em>純粋関数のポリシーに縛られるがゆえに、関数のダイナミックさを犠牲にする必要はありません</em>。</p>

<p>しかし、変数は変更するたびにその変数を参照するタイミングによって異なる値が返ってきます。<em>プログラムのすべての状態変更を除去することは不可能ですが、可能なかぎり減らすほうがよい</em> です。</p>

<p>そして、<em>関数型プログラミングの理想な状況とは、可変なものが全く存在しない</em> という状況です。</p>

<p>関数を <strong>抽象の基本的な単位</strong> としてみる利点は、関数の実装内容が外部に「<em>漏れる</em>」ことがなければ、関数の利用側は関数の実装に無関係であることです。</p>

<p>つまり、関数型プログラミングにおける関数でも、内部で命令的なプログラミングをしていたり、変数の状態を変更していたとしても、外部にもれなければ問題にはならないということです。</p>

<p>JavaScript は <strong>関数が変数の境界をつくる</strong> ので、ローカル変数の状態変更は関数が外部に漏れるのを防いでくれます。</p>

<p><blockquote><p>誰もいない森で木が倒れたら、音がするでしょうか？<br/>不変性を持った戻り値を生成するために、純粋関数がローカルデータを変異させたとしたら、それは良いことなのでしょうか？</p><footer><strong>Rich Hickey</strong> <cite><a href='http://clojure.org/transients'>clojure.org/transients/&hellip;</a></cite></footer></blockquote></p>

<p>結局のところ、答えは <strong>Yes</strong> です。</p>

<h3>不変性を保つためにとりうる手段</h3>

<p>JavaScript のオブジェクトフィールドは常に参照可能なので、オブジェクトは不変ではありません。不変性を保つために関数の実装側がとりえる手段は実質つぎの3つのどれかになります。</p>

<ul>
<li>浅いコピーで十分な場合は <code>_.clone</code> を使ってコピーする</li>
<li>深いコピーが必要な場合は <code>deepClone</code> を使う</li>
<li>純粋関数を使ってコードを記述する</li>
</ul>


<h2>メモ</h2>

<p><img src="/images/2014-02-21-functional-javascript-04.jpg" alt="メモ" /></p>

<p>本書の中に出てきた、関数とかのメモ。</p>

<h3>predicate</h3>

<p>常に真偽値（<code>true</code> or <code>false</code>）を返す関数を <strong>predicate</strong> と呼びます。</p>

<pre><code class="javascript">function lessOrEqual(x, y) {
  return x &lt;= y;
}
</code></pre>

<h3>existy と truthy</h3>

<p><code>existy</code> は与えられた値が存在するかどうかを返す関数です。<code>truthy</code> は与えられた値が <code>true</code> とみなされるかどうかを返す関数です。</p>

<pre><code class="javascript">function existy(x) {
  return x != null;
}

function truthy(x) {
  return (x !== false) &amp;&amp; existy(x);
}
</code></pre>

<p><code>truthy</code> は0を <code>true</code> と判定します。これは JavaScript の標準の動作とは違いますが、0を <code>false</code> と同一とみなすのは C 言語の遺物であると筆者は考えているようです。</p>

<h3>JavaScript 関数の設計指針</h3>

<p>JavaScript ではある条件が <code>true</code> の場合のみ処理を行い、それ以外の場合には <code>undefined</code> か <code>null</code> を返す動作が使いやすい場合が多い。</p>

<h3>メタプログラミングとは</h3>

<p><blockquote><p>プログラミングは何かを行うためにコードを書くものであるが、メタプログラミングは何かを解釈する方法を変更するためにコードを書くものである。</p></blockquote></p>

<h3>第一級関数</h3>

<p>第一級関数は他のデータ型と同じように、扱うことができる関数のことです。</p>

<ul>
<li>変数に格納できる</li>
<li>必要に応じて生成できる</li>
<li>他の関数の引数として渡すことができる</li>
<li>関数の戻り値として返すことができる</li>
</ul>


<h3>コレクション中の <code>null</code> に対する防御用の関数 <code>fnull</code></h3>

<p><code>fnull</code> は関数と可変長引数をとる関数です。与えられた関数の実行を行う際に <code>undefined</code> か <code>null</code> の値の場合にはデフォルト値を使うようにして関数を呼び出します。</p>

<pre><code class="javascript fnull">function fnull(func /* , 可変長のデフォルト引数 */) {
  var defaults = _.rest(arguments);
  return function( /* args */ ) {
    var args = _.map(arguments, function(e, i) { return existy(e) ? e : defaults[i]; });
    return func.apply(null, args);
  };
}

var safeMulti = fnull(function(total, n) { return total * n; }, 1, 1);
_.reduce([1, 2, 3, null, 5], safeMulti);
// =&gt; 30
</code></pre>

<h3>invoker</h3>

<p><code>invoker</code> は関数を返す関数です。引数にメソッド名を取り、メソッドの実行主体のオブジェクトを渡すとそのオブジェクトでメソッドを実行する関数を返します。</p>

<pre><code class="javascript invoker">function invoker(NAME, METHOD) {
  return function(target /* , 任意の引数 */) {
    if (!existy(target)) fail('Must provide a target');

    var targetMethod = target[NAME];
    var args         = _.rest(arguments);
    return doWhen((existy(targetMethod) &amp;&amp; METHOD == targetMethod), function() {
      return targetMethod.apply(target, args);
    });
  };
}

var rev = invoker('reverse', Array.prototype.reverse);
_.map([[1, 2, 3]), rev);
// =&gt; [[3, 2, 1]]
</code></pre>

<p>関数型のスタイルでは、<em>関数の実行主体となるオブジェクトを引数にとる関数の形が好まれます</em>。</p>

<h3>メソッドチェーン</h3>

<p>メソッドチェーンは「<em>流暢な</em>」API を構築するために有用なパターンです。流暢な API とは例えば次のようなものです。</p>

<pre><code class="javascript 流暢な API の例">createPerson()
  .setFirstName('Mike')
  .setLastName('Fogus')
  .setAge(108)
  .toString();
</code></pre>

<p>メソッドチェーンを実現する「<em>魔法</em>」は <em>チェーン内のそれぞれのメソッドが同じホストのオブジェクトの参照を返す</em> ことです。</p>

<p>上の方のメモで、関数が前提条件に合わない引数を受け取った場合は <code>undefined</code> か <code>null</code> を返すのがよいとありました。メソッドチェーンで使うことを考えている関数の場合は <code>undefined</code>、<code>null</code>、<code>同じホストのオブジェクト</code> のどれを返せばいいんでしょうかね。。。</p>

<h2>感想</h2>

<p>JavaScript の関数の基本的なところから説明をはじめて、<strong>関数型プログラミング</strong>、<strong>クロージャ</strong>、<strong>高階関数</strong>、<strong>カリー化</strong>、<strong>再帰</strong>、<strong>フィルタ</strong>、<strong>パイプライン</strong>等の関数の設計方法がふんだんに解説されています。</p>

<p>説明がとても丁寧で分かりやすく、関数型プログラミングのことを知らない人でも理解しやすいと思います。</p>

<p>関数型プログラミングを学ぶと、<strong>純粋関数</strong>、<strong>データの不変性</strong> というテーマに当たります。JavaScript にはないですが、Ruby ではメソッドに <code>!</code> が付いた自分自身を変更する破壊的なメソッドがあります。関数型プログラミングとオブジェクト指向プログラミングをうまい具合に取り入れている言語だと再認識しました。</p>

<p>JavaScript で関数型プログラミングを学ぶというテーマですが、<em>関数型プログラミングを学ぶことで他の言語の面白い点も見えてくる</em> というのが読了しての感想です。</p>

<p>JavaScript は Java に次いで最も多く利用されている言語ですので、<strong>JavaScript をよりよく使うため、他の関数型言語をより楽しむため</strong> に本書を活用してみてはいかがでしょうか。おすすめです。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ステートフルJavaScript ―MVCアーキテクチャに基づくWebアプリケーションの状態管理]]></title>
    <link href="http://hamasyou.com/blog/2012/09/23/487311554X/"/>
    <updated>2012-09-23T22:05:00+09:00</updated>
    <id>http://hamasyou.com/blog/2012/09/23/487311554X</id>
    <content type="html"><![CDATA[<p>本書は、クライアントサイド（ブラウザ）で JavaScript を使ってリッチなアプリを作る際のプラクティスを説明しています。</p>

<p>前半では、JavaScript によるオブジェクト指向開発の方法や MVC 開発の方法を、後半では、JavaScript の MVC デザインパターンに則った、各種ライブラリの説明が行われています。</p>

<p>最近では、ユーザビリティの良いアプリを開発するのに必須なクライアントサイドでの JavaScript の使い方が複雑になってきているように思います。ちょっと jQuery を使って DOM 操作していればよかった頃と比べて、最近では色々なライブラリを組み合わせる必要があったり、クライアントサイドでも MVC パターンが必要になったりと、大変です。</p>

<p>本書は、そんな JavaScript でリッチアプリケーションを作成する際の取っ掛かりを学ぶのに良いと思います。オライリー本なので、読むのが簡単ということはなく、むしろ格式高い感じすらしますが、多少 JavaScript でオブジェクト指向の経験があれば、読み進めるのは難しく無いと思います。</p>

<!-- more -->




<h2>おぼえがき</h2>




<h3>インスタンスメソッド定義のイディオム</h3>


<p>JavaScript ではクラスのプロトタイプに対して関数を追加することでインスタンスメソッドを定義できます。</p>

<pre><code class="javascript">Person.prototype.breath = function() { /* ... */ };
var person = new Person();
person.breath();
</code></pre>

<p>クラスのプロトタイプに <em>fn</em> というエイリアスを設定することが広く行われています。</p>

<pre><code class="javascript">Person.fn = Person.prototype;
Person.fn.run = function() { /* ... */ };
</code></pre>

<h3>関数呼び出しのコンテキスト</h3>


<p>apply() と call() を使うと、関数の呼び出しコンテキストを変更できます。jQuery の API ではイベントハンドラや each() による繰り返しの中で、コンテキスト（this の値）が変更されています。</p>

<pre><code class="javascript">$('.btn').click(function() {
  $(this).hide();
});
</code></pre>

<p>元のコンテキストにアクセスするには、良く self などの名前で this を保存しておき、後で参照する方法がとられます。</p>

<pre><code class="javascript">var self = this;

$('.btn').click(function() {
  self.btnClicked();
});
</code></pre>

<p>apply() を使うと、self を使わなくても同じことができます。</p>

<pre><code class="javascript">var proxy = function(func, context) {
  return (function() {
    return func.apply(context, arguments);
  });
};

$('.btn').click(proxy(function() {
  this.btnClicked();
}, this);
</code></pre>

<p>jQuery の proxy() メソッドがまさしく、これと同じことをしています。</p>

<h3>イベントの発生順序</h3>


<p>ある要素とその祖先の要素が同じ種類のイベントに対してイベントハンドラを登録している場合、先に呼び出されるのはブラウザによって違います。</p>

<p>イベントが呼び出される順番は2種類あり、<strong>イベントキャプチャリング</strong> と<strong>イベントバブリング</strong>になります。</p>

<h4>イベントキャプチャリング</h4>


<p>最も上位（外側）の要素からイベントが発生した要素へとイベントリスナが呼び出されます。つまり、祖先の要素、内側の要素の順番でイベントリスナが呼び出されます。</p>

<h4>イベントバブリング</h4>


<p>イベントが発生した要素（内側）から祖先要素へとイベントリスナが呼び出されます。</p>

<p>W3C の仕様では、addEventListener() の3つめの引数に true を指定するとイベントキャプチャリングで呼び出され、false か 指定しないとイベントバブリングで呼び出されます。</p>

<p>バブリングが行われている際には、イベントオブジェクトの stopPropagation() を呼び出すことによって、バブリングを中止することができます。</p>

<pre><code class="javascript">link.addEventListener('click', function(e) {
  e.stopPropagation();
  /* ... */
});
</code></pre>

<p>ブラウザによってそれぞれのイベントに対するデフォルトのアクションが定義されています。たとえば、リンクのクリックでは、src で指定された URL に遷移する動作や、チェックボックスのクリックで項目が選択状態になる動作などです。</p>

<p>これらのデフォルトのアクションはイベントの伝播が完了した後で実行されます。このデフォルトのアクションを中止するには、 preventDefault() 関数を呼び出します。また、イベントハンドラの戻り値で false を返すことで、preventDefault() を呼び出したのと同じ動作になります。</p>

<pre><code class="javascript">form.addEventListener('submit', function(e) {
  /* e.preventDefault() */
  return confirm('本当に送信しますか？');
});
</code></pre>

<h3>イベントの委譲</h3>


<p>イベントバブリングの性質を考えると、複数ある子孫の要素それぞれにイベントリスナを設定するより、祖先の要素一つだけにイベントハンドラを設定する方が効率がよくなります。</p>

<p>jQuery では、これを delgate() メソッドを使って実装できます。</p>

<pre><code class="javascript">/* 望ましくないコード */
$('ul li').click(function() { /* ... */ });

// こちらのほうが効率が良い
$('ul').delegate('li', 'click', function() { /* ... */ });
</code></pre>

<p>このように、イベント処理を委譲することによるメリットは、動的に追加された要素についても、自動でイベントリスナが適用されることです。</p>

<h3>画面表示時の初期データの読み込み</h3>


<p>ページ上のデータは、最初に読み込まれるページに含まれているか、Ajax や JSONP を使った HTTP リクエストによって事後的に読み込まれます。多くのデータを初期表示時に読み込むのには時間がかかりますが、Ajax や JSONP によるリクエストは、<em>並列処理が可能</em>であるので高速に処理できます。</p>

<p>また、HTTP リクエストで取得したデータは、ローカルのストレージにキャッシュすることができます。ストレージには2種類あり、 <code>localStorage</code> と <code>sessionStorage</code> というオブジェクトでアクセスできます。</p>

<h4>ローカルストレージ</h4>


<p>ブラウザが終了した後も保持される。</p>

<h4>セッションストレージ</h4>


<p>ブラウザが開いている間のみ保持される。</p>

<h3>コントローラと内部状態</h3>


<p>まず言えるのは、<em>DOM 内にモデルの内部状態やその他の情報を保持するべきではありません</em>。頑強な MVC アーキテクチャの実現のためには、内部状態やその他の情報は、コントローラ内に保持させる方がよい。</p>

<p>ビューごとにコントローラを1つずつ用意するというのがよく使われているパターンです。</p>

<h3>リソースとURL</h3>


<p>通常、Ajax などでリソースとなるデータをロードした場合、ブラウザの URL は変化しません。しかし、Web 上の個々のリソースには URL が割り当てられていると考えるのが一般的で、URL が変わらない状況というのは好ましくありません。</p>

<p>そこで、この問題に対しては、内部状態が変化したら URL を変化させるようにします。このとき、よく使われるのが、URL のハッシュ（#以降の文字列）を変更するというものです。ハッシュの値はサーバに送信されないため、ページの再読込を発生させることなく変更できます。</p>

<p>location.hash を使うと、ページのハッシュを取得できます。</p>

<p>主要なブラウザでは、URL のハッシュが変更されたかどうかを調べるのに、hashchange イベントが使えます。</p>

<p>JavaScript で作られたページは、クローラにとってはすべて同じ URL のように見えてしまいます。そこで、Google は、<a href="http://code.google.com/web/ajaxcrawling/index.html" rel="external nofollow">Ajax Crawling</a> という仕様を提案しています。</p>

<h3>Backbone.js ライブラリ</h3>


<p><a href="http://backbonejs.org/" rel="external nofollow"></a> は JavaScript アプリケーションの構築のための優れたライブラリです。Backbone.js も MVC 構造でアプリケーションを作成していきます。</p>

<h2>参考</h2>




<ul><li><a href="http://fingaholic.github.com/posts/2012-06-27-stateful-javascript.html" rel="external nofollow">ステートフルJavaScript 1章 - jekylog</a></li>
<li><a href="http://fingaholic.github.com/posts/2012-07-02-stateful-javascript.html" rel="external nofollow">ステートフルJavaScript 2章 - jekylog</a></li>
<li><a href="http://fingaholic.github.com/posts/2012-07-17-stateful-javascript.html" rel="external nofollow">ステートフルJavaScript 3章 - jekylog</a></li>
<li><a href="http://fingaholic.github.com/posts/2012-07-20-stateful-javascript.html" rel="external nofollow">ステートフルJavaScript 4章 - jekylog</a></li>
<li><a href="http://fingaholic.github.com/posts/2012-07-23-stateful-javascript.html" rel="external nofollow">ステートフルJavaScript 5章 - jekylog</a></li>
<li><a href="http://fingaholic.github.com/posts/2012-07-25-stateful-javascript.html" rel="external nofollow">ステートフルJavaScript 6章 - jekylog</a></li>
<li><a href="http://fingaholic.github.com/posts/2012-08-01-stateful-javascript.html" rel="external nofollow">ステートフルJavaScript 11章 その1 - jekylog</a></li>
<li><a href="http://fingaholic.github.com/posts/2012-08-07-stateful-javascript.html" rel="external nofollow">ステートフルJavaScript 11章 その2 - jekylog</a></li>
</ul>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[オブジェクト指向JavaScript]]></title>
    <link href="http://hamasyou.com/blog/2012/04/27/4048706705/"/>
    <updated>2012-04-27T12:54:00+09:00</updated>
    <id>http://hamasyou.com/blog/2012/04/27/4048706705</id>
    <content type="html"><![CDATA[<p>本書は、JavaScript を理解するためのものです。JavaScript はプロトタイプベースの言語で、クラスがなかったり、プロパティのアクセス修飾子がなかったり、継承の仕方が特別だったりします。</p>

<p>JavaScript を理解するには、JavaScript は全てがオブジェクトであることを覚えておく必要があります。本書は、こう言った、JavaScript が他のオブジェクト指向言語と違う点を整理し、JavaScript ではこう書くというのを丁寧に解説してくれています。</p>

<p>「JavaScript はブラウザ上で動く小さな言語」という認識だった昔とは、昨今では JavaScript の扱いは変わりました。サーバサイドでも JavaScript を動かしたり、スマートフォンの開発に JavaScript を使ったりと、JavaScript が使える舞台は広がっています。</p>

<p>JavaScript をもう一度ちゃんと理解したいという人に、本書はおすすめです。</p>

<!-- more -->




<h2>おぼえがき</h2>




<h3>プリミティブデータ型</h3>




<dl>
<dt>Number</dt>
<dd>1, 100, 3.14 などの数値。浮動小数点を含む。</dd>
<dt>String</dt>
<dd>'hoge', &quot;foo bar&quot;, などで表現される文字列。</dd>
<dt>Boolean</dt>
<dd>true と false。</dd>
<dt>undefined</dt>
<dd>まだ存在していない変数にアクセスすると得られる値。</dd>
<dt>null</dt>
<dd>値がないことを表す値。</dd>
</dl>




<h3>変数の型をしる <code>typeof</code> 演算子</h3>


<p>変数や値の型を調べるときに使える <strong>typeof演算子</strong>は、<em>&quot;number&quot;</em>、<em>&quot;string&quot;</em>、<em>&quot;boolean&quot;</em>、<em>&quot;undefined&quot;</em>、<em>&quot;object&quot;</em>、<em>&quot;function&quot;</em> のいずれかの値（文字列）を返す。</p>

<h3>Infinity（無限）</h3>


<p><strong>Infinity</strong> は JavaScript で扱えない大きな数値を表すのにつかう値。JavaScript で扱える最大の数値は 1.7976931348623157e+308、最小は 5e-324である。</p>

<pre><code class="javascript">&gt;&gt;&gt; Infinity
Infinity
&gt;&gt;&gt; typeof Infinity
"number"
&gt;&gt;&gt; 1e309
Infinity
</code></pre>

<h3>Boolean に変換されると false になる値</h3>




<ul>
<li>空文字列&quot;&quot;</li>
<li>null</li>
<li>undefined</li>
<li>数値の 0</li>
<li>数値の NaN</li>
<li>Boolean型の false</li>
</ul>




<h3>型変換の Tips</h3>


<p>数字のような文字列を数値に変換する方法は parseInt() 関数を使う方法の他に、1 を掛けるという方法もある。</p>

<pre><code class="javascript">&gt;&gt;&gt; var s = "100";
&gt;&gt;&gt; s = s * 1;
&gt;&gt;&gt; typeof s;
"number"
</code></pre>

<p>文字列に変換する場合、空文字と結合する方法がある。</p>

<pre><code class="javascript">&gt;&gt;&gt; var n = 10;
&gt;&gt;&gt; n = "" + n;
&gt;&gt;&gt; typeof n;
"string"
</code></pre>

<h3>配列の要素の削除</h3>


<p>配列の要素の削除には delete 演算子を使うが、この演算子は配列の要素を減らすわけではなく、undefined を設定する。</p>

<pre><code class="javascript">&gt;&gt;&gt; var a = [1, 2, 3];
&gt;&gt;&gt; delete a[1];
true
&gt;&gt;&gt; a.length;
3
&gt;&gt;&gt; a;
[1, undefined, 3]
</code></pre>

<h3>変数が定義されていて、値が割り当てられているかどうかを確認する方法</h3>


<pre><code class="javascript">if (typeof something !== "undefined") {
  // 何かの処理
}
</code></pre>

<h3>自分自身を書き換える関数</h3>


<p>自分自身を書き換える関数の仕組みは、初期化などの一度だけ行ないたい処理がある場合に使う。</p>

<pre><code class="javascript">var a = function() {
  function someSetup() {
    var setup = 'done';
  }
  function actualWork() {
    alert('Worky-worky');
  }
  someSetup();
  return actualWork;
}();
</code></pre>

<h2>オブジェクト</h2>




<h3>オブジェクトリテラル表記</h3>


<p>{} を使ってオブジェクトを定義することをオブジェクトリテラル表記を呼ぶ。</p>

<pre><code class="javascript">var hero = {
  breed: 'Turtle',
  occupation: 'Ninja'
};
</code></pre>

<p>オブジェクトのプロパティ名はクウォートしないのが推奨されている。ちなみに、連想配列（ハッシュ）のキーは文字列である。</p>

<h3>コンストラクタ関数</h3>


<p>関数を new してオブジェクトを作ることで、関数をコンストラクタとして利用することができる。</p>

<pre><code class="javascript">function Hero(name) {
  this.name = name;
}

&gt;&gt;&gt; var h1 = new Hero('hamasyou');
&gt;&gt;&gt; h1.name;
"hamasyou"
</code></pre>

<h3>グローバル変数</h3>


<p>JavaScript のプログラムは様々なホスト環境（たとえばブラウザ環境）で動作する。JavaScript のホスト環境はグローバルオブジェクトを提供していて、グローバル変数はグローバルオブジェクトのプロパティになる。</p>

<p>たとえば、ブラウザ環境では <em>window</em> というグローバルオブジェクトが提供されており、グローバル変数はすべて、window のプロパティになる。</p>

<p class="option">コンストラクタ関数を定義したにもかかわらず、new でオブジェクトをつくらなかった場合、this はグローバルオブジェクトを指すことになる。</p>




<h3>constructor プロパティ</h3>


<p>オブジェクトが作成されると、<em>constructor</em> プロパティと呼ばれる特別なプロパティに、オブジェクトを作成したときに使われたコンストラクタ関数がセットされる。</p>

<pre><code class="javascript">&gt;&gt;&gt; h1.constructor;
Hero(name)
</code></pre>

<h3>instanceof 演算子</h3>


<p><em>instanceof 演算子</em>を使うと constructor プロパティが指定した関数かどうかを調べることができる。</p>

<pre><code class="javascript">&gt;&gt;&gt; h1 instanceof Hero;
true
</code></pre>

<h3>オブジェクトの比較</h3>


<p>オブジェクト同士を比較すると、両方の変数が同じオブジェクトの参照の場合のみ true を返す。</p>

<h2>プロトタイプ</h2>


<p><blockquote><p></p></p><p><ul><br/><li>このプロパティは関数がコンストラクタのときのみ使われる</li><br/><li>この関数を使って作られたオブジェクトも、prototype プロパティを持ち、関数の prototype と同じオブジェクトを参照する。このオブジェクトのプロパティは自分のプロパティと同じように使える</li><br/></ul></p><p><br/><p></p></blockquote></p>

<h3>prototype プロパティ</h3>


<p>関数は、<em>prototype</em> と呼ばれるプロパティを保持している。初期値は空のオブジェクトになっている。</p>

<pre><code class="javascript">function multiply(a, b) {
  return a * b;
}
&gt;&gt;&gt; multiply.constructor;
Function()

&gt;&gt;&gt; typeof multiply.prototype;
"object"

&gt;&gt;&gt; multiply.prototype;
multiply {}
</code></pre>

<p>prototype プロパティに設定されているオブジェクトには、プロパティとメソッドを追加していくことができる。このオブジェクトは、multiply 関数自身にはなんの影響も与えない。追加したプロパティとメソッドは、multiply をコンストラクタとして利用した場合にのみ使われる。</p>

<pre><code class="javascript">&gt;&gt;&gt; multiply.prototype.name = 'hamasyou';
&gt;&gt;&gt; multiply.name;
"multiply"

&gt;&gt;&gt; var hoge = new multiply();
&gt;&gt;&gt; hoge.name;
"hamasyou"
</code></pre>

<p>prototype プロパティをいつ変更しても、すべてのオブジェクトが影響を受ける点は注意が必要。</p>

<h3>prototype オブジェクトのプロパティを上書きする</h3>


<p>オブジェクト自身のプロパティの方が、prototype オブジェクトのプロパティよりも優先して解決される。</p>

<pre><code class="javascript">var Salary = (function() {
  var salary = function() {};
  salary.prototype.base = 50000;
  salary.prototype.total = function() {
    return this.base * 1.05;
  };
  return salary;
})();

&gt;&gt;&gt; var hoge_salary = new Salary();
&gt;&gt;&gt; hoge_salary.base = 20000;
&gt;&gt;&gt; hoge_salary.total();
21000

var hama_salary = new Salary();
&gt;&gt;&gt; hama_salary.total();
52500
</code></pre>

<h2>継承</h2>




<h3>プロトタイプチェーンで継承を実現する</h3>


<p>JavaScript の prototype プロパティはオブジェクトであるので、自身の prototype も持っている。このように prototype をチェーンして辿っていくことで、継承を実現することができる。</p>

<p>次の例は、本書 P.183 のプロトタイプチェーンの例である。</p>

<pre><code class="javascript">function Shape() {
  this.name = 'shape';
  this.toString = function() { return this.name; }
}

function TwoDShape() {
  this.name = '2D shape';
}

function Triangle(side, height) {
  this.name = 'Triangle';
  this.side = side;
  this.height = height;
  this.getArea = function() {
    return this.side * this.height / 2;
  };
}

TwoDShape.prototype = new Shape();
Triangle.prototype = new TwoDShape();
TwoDShape.prototype.constructor = TwoDShape;
Triangle.prototype.constructor = Triangle;

&gt;&gt;&gt; var my = new Triangle(5, 10);
&gt;&gt;&gt; my.getArea();
25
&gt;&gt;&gt; my.toString();
"Triangle"
</code></pre>

<p>Triangle クラスには toString メソッドは定義されていないが、Shape 関数で定義されていることで、プロトタイプチェーンをたどって呼び出すことができる。</p>

<p class="option">継承を行った後は、constructor を再設定しておくとよい。</p>



]]></content>
  </entry>
  
</feed>
