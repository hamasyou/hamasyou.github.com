<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: Swift | それはBooks]]></title>
  <link href="http://hamasyou.com/blog/tags/swift/atom.xml" rel="self"/>
  <link href="http://hamasyou.com/"/>
  <updated>2014-09-19T18:23:10+09:00</updated>
  <id>http://hamasyou.com/</id>
  <author>
    <name><![CDATA[hamasyou]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[Swift] 多次元配列の定義の謎]]></title>
    <link href="http://hamasyou.com/blog/2014/09/12/swift-mysterious-multi-dimensional-array/"/>
    <updated>2014-09-12T11:21:20+09:00</updated>
    <id>http://hamasyou.com/blog/2014/09/12/swift-mysterious-multi-dimensional-array</id>
    <content type="html"><![CDATA[<p>Xcode6 GM でましたね！ Beta1 の頃から Swift 触ってますが、まぁ言語仕様がよく変わること（笑。</p>

<p>で、いつか直るだろうと思ってたけど、GM でも直っていない Swift の多次元配列の定義の謎に関してです。だれか理由分かる人いたら教えてください。。</p>

<p>下のようなコードがあるとします。</p>

<pre><code class="swift">
typealias NameAndValue = Dictionary&lt;String, String&gt;

let dict: [[NameAndValue]] = [
  [
     ["name": "",    "value": ""],
  ],
  [
     ["name": "",    "value": ""],
  ]]
</code></pre>

<p><code>typealias</code> で別名つけて2次元配列を定義しているだけです。要素が <code>Dictionary</code> になっています。ここまでは普通にコンパイルが通ります。</p>

<p>ですが、これをこんなふうに&hellip;</p>

<pre><code class="swift">
let dict: [[NameAndValue]] = [
  [
     ["name": "",    "value": ""],
     ["name": "",    "value": ""],
     ["name": "",    "value": ""],
     ["name": "",    "value": ""],
     ["name": "",    "value": ""],
     ["name": "",    "value": ""],
     ["name": "",    "value": ""],
     ["name": "",    "value": ""],
     ["name": "",    "value": ""],
     ["name": "",    "value": ""],
     ["name": "",    "value": ""],
     ["name": "",    "value": ""],
     ["name": "",    "value": ""],
     ["name": "",    "value": ""],     
     ["name": "",    "value": ""],
     ["name": "",    "value": ""],
     ["name": "",    "value": ""],
     ["name": "",    "value": ""],
     ["name": "",    "value": ""],                         
  ],
  [
     ["name": "",    "value": ""],
  ]]
</code></pre>

<p>配列の要素を増やしていきます。そうするとだいたい <strong>10件くらい</strong> からコンパイルが遅くなり、<strong>15件過ぎたくらいから</strong> コンパイルエラーが出るようになります。</p>

<pre><code>Cannot convert the expression's type '[[NameAndValue]]' to type 'StringLiteralConvertible'
</code></pre>

<p>意味がわからんです。。</p>

<p>仕方ないので</p>

<pre><code class="swift">var dict: [[NameAndValue]] = [[],[]]
dict[0].append(["name": "",    "value": ""])
dict[0].append(["name": "",    "value": ""])
dict[0].append(["name": "",    "value": ""])
dict[0].append(["name": "",    "value": ""])
dict[0].append(["name": "",    "value": ""])
dict[0].append(["name": "",    "value": ""])
dict[0].append(["name": "",    "value": ""])
dict[0].append(["name": "",    "value": ""])
dict[0].append(["name": "",    "value": ""])
dict[0].append(["name": "",    "value": ""])
dict[0].append(["name": "",    "value": ""])
dict[0].append(["name": "",    "value": ""])
dict[0].append(["name": "",    "value": ""])
dict[0].append(["name": "",    "value": ""])
dict[0].append(["name": "",    "value": ""])
dict[0].append(["name": "",    "value": ""])
dict[0].append(["name": "",    "value": ""])
dict[0].append(["name": "",    "value": ""])

dict[1].append(["name": "",    "value": ""])
dict[1].append(["name": "",    "value": ""])
dict[1].append(["name": "",    "value": ""])
dict[1].append(["name": "",    "value": ""])
dict[1].append(["name": "",    "value": ""])
</code></pre>

<p>こうやって、プログラムでデータ登録するようにしました。。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift での Dictionary<String, AnyObject> の扱いメモ]]></title>
    <link href="http://hamasyou.com/blog/2014/08/28/swift-dictionary-anyobject/"/>
    <updated>2014-08-28T00:12:25+09:00</updated>
    <id>http://hamasyou.com/blog/2014/08/28/swift-dictionary-anyobject</id>
    <content type="html"><![CDATA[<p>Swift で <code>Dictionary</code> を扱うときのメモです。API 呼び出しのレスポンスを JSON で扱いたい時に <code>Dictionary&lt;String, AnyObject&gt;</code> として扱う際のポイントです。</p>

<pre><code class="swift">typealias JSONDictionary = Dictionary&lt;String, AnyObject&gt;
let json = NSJSONSerialization.JSONObjectWithData(data, options: .MutableContainers, error: nil) as JSONDictionary

let str1 = json["foobar"]! as String    // String
let str2 = json["foobar"] as AnyObject? as? String  // String?

let str3 = json["foobar"] as String     // これはコンパイルエラー '(String, AnyObject)' is not convertible to 'String'
</code></pre>

<p>最後のはなぜコンパイルエラーになるかというと、<code>Dictionary</code> の <code>subscript</code> が2種類定義されていて、期待したのと違う方が呼び出されているからです。</p>

<pre><code class="swift">struct Dictionary&lt;Key : Hashable, Value&gt; : CollectionType, DictionaryLiteralConvertible {
    ...
    subscript (i: DictionaryIndex&lt;Key, Value&gt;) -&gt; (Key, Value) { get }
    subscript (key: Key) -&gt; Value?
    ...
}
</code></pre>

<p><code>json["foobar"]</code> の戻り値は <code>(Key, Value)</code> か <code>Value?</code> のどちらかですが、<code>as String</code> を付けた際に Optional ではないと判断されてしまい <code>(Key, Value)</code> が戻り値の型と判定されます。それでコンパイルエラーになるわけですね。</p>

<p>期待した通りに取得するには、<code>json["foobar"]</code> の戻り値を <code>Value?</code> として扱う必要があるので、</p>

<pre><code class="swift">json["foobar"]!
json["foobar"] as AnyObject?
</code></pre>

<p>のどちらかでアクセスする必要があるわけです。<code>!</code> を付けると unwrap されるので <code>nil</code> が入っていると実行時エラーになります。逆に <code>as AnyObject? as? String</code> でアクセスすると Optional 型になってしまいます。</p>

<p>API のインターフェースと相談して、どちらの型で処理するか決めるといいんじゃないかと思います。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SwiftでForce Unwrapping型の配列に値を追加できない]]></title>
    <link href="http://hamasyou.com/blog/2014/07/31/swift-array-force-unwrapping/"/>
    <updated>2014-07-31T11:28:11+09:00</updated>
    <id>http://hamasyou.com/blog/2014/07/31/swift-array-force-unwrapping</id>
    <content type="html"><![CDATA[<p>この記事は Xcode6 beta4 を元に記述しています。</p>

<h3>Swift の配列は mutable か immutable</h3>

<p>Swift では配列を <strong>mutable/immutable</strong> の区別なく定義することができるようになりました。</p>

<pre><code class="swift">var numbers = [1, 2, 3]
numbers[0] = 0
println(numbers)    // [0, 2, 3]
</code></pre>

<p><code>let</code> で定義すると <strong>immutable</strong>、<code>var</code> で定義すると <strong>mutable</strong> になり、配列の代入はすべてコピーで行われるようになっています。</p>

<h3>Force UnWrapping 型!</h3>

<p>で、ハマったのが次のようなコードです。</p>

<pre><code class="swift">var numbers: [Int]! = [1, 2, 3]
numbers[0] = 0    // error: '@lvalue $T7' is not identical to 'Int'
</code></pre>

<p>Force Unwrapping 型とでも言うんでしょうかね？変数に必ず値が入ってることを保証するために <code>!</code> が付いた型です。
この型で定義した配列には、値の追加や変更ができなくなっています。。</p>

<p>これで何が困るかというと、<code>UIKit</code> 使って <code>UIViewController</code> のサブクラスにプロパティを定義する際に
初期化を <code>viewDidLoad</code> で行う時には、<code>!</code> をつけないと <code>initializer</code> が必要になってしまうので、プロパティの定義には <code>!</code> を付けていました。</p>

<p>そうすると、<em>mutable</em> で扱いたかったプロパティなのに、変更できないという問題にぶち当たったわけです。。どうすんだこれ。。。</p>

<h4>コンパイルエラーの例</h4>

<pre><code class="swift">class MyViewController: UIViewController {

  var numbers: [Int]!

  override func viewDidLoad() {
    super.viewDidLoad()

    self.numbers = [1, 2, 3]
  }


  func myFunc() {
    self.numbers[0] = 0     // コンパイルエラー
  }
}
</code></pre>

<h4>うまくいく例</h4>

<p>対応としては、一旦変数で受けて、変更後に元に戻すっていうので何とかなりますが、コンパイラの方でなんとかならんもんですかね。。</p>

<pre><code class="swift">  func myFunc() {
    var nums: [Int] = self.numbers
    nums[0] = 0
    self.numbers = nums
  }
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SwiftはenumをAnyObject型の変数に入れられない]]></title>
    <link href="http://hamasyou.com/blog/2014/07/31/swift-enum-anyobject/"/>
    <updated>2014-07-31T10:39:48+09:00</updated>
    <id>http://hamasyou.com/blog/2014/07/31/swift-enum-anyobject</id>
    <content type="html"><![CDATA[<p>Swift で <em>enum</em> を扱う際にハマった問題です。確認は <em>Xcode6 beta4</em> で行っています。</p>

<h3>Swift の enum は AnyObject 型変数に代入できない</h3>

<p>Swift では <code>enum</code> を <code>AnyObject</code> 型の変数に入れることができません。コンパイルエラーになります。<code>Any</code> 型なら代入できます。</p>

<pre><code class="swift">enum SomeType: Int {
    case None = 0
    case Something
}

let something = SomeType.None
something                                     // Enum Value

let anything: AnyObject = SomeType.Something  // error: type 'SomeType' does not conform to protocol 'AnyObject'

let any: Any = SomeType.Something             // Enum Value
</code></pre>

<p>Swift の <code>enum</code> は <code>AnyObject</code> protocol を実装していないので、<code>AnyObject</code> 型の変数に入れることが出来ません。</p>

<h4>ReactiveCocoa とかと組み合わせるときにこまる</h4>

<p>これの何が不便かというと、<code>enum</code> は UIKit でよく使われていて、<a href="https://github.com/ReactiveCocoa/ReactiveCocoa">ReactiveCocoa</a> を Swift で使う際に
<code>enum</code> で設定する例えば <code>UITableViewCellAccessoryType</code> なんかを使いたい場合にコンパイルエラーになってしまいます。</p>

<pre><code class="swift">// これはコンパイルエラーになる
RAC(self, "cell.accessoryType") = RACObserve(self, "viewModel.checked").map { ($0 as Bool) ? UITableViewCellAccessoryType.Checkmark : UITableViewCellAccessoryType.None }

// こうしないといけない。。
RACObserve(self.viewModel, "checked")
    .subscribeNext { [weak self] arg in
        let checked = arg as Bool
        self!.accessoryType = checked ? .Checkmark : .None
}
</code></pre>

<p>既存の Objective-C ライブラリで <code>id</code> が使われている箇所が、Swift では <code>AnyObject</code> に対応するので、
Closure 等で <code>id</code> を引数に取ったり、<code>id</code> を戻り値にしていたりする箇所が <code>AnyObject</code> になってしまい、
<code>enum</code> を利用することができません。</p>

<p>変数に代入するだけなら <code>Any</code> 型にすればいいんですが、既存ライブラリとの連携では難しそうです。 <sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>
これ、何かやり方ないんでしょうかね。。ReactiveSwift 待ちかなぁ</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>Any 型にすれば代入できることを <a href="https://twitter.com/takabosoft">@takabosoft</a> さんに教えてもらいました。ありがとうございます！<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift で UITableView 関連の操作をする際に NSIndexPath を作る方法]]></title>
    <link href="http://hamasyou.com/blog/2014/07/03/swift-uitableview-nsindexpath/"/>
    <updated>2014-07-03T11:53:41+09:00</updated>
    <id>http://hamasyou.com/blog/2014/07/03/swift-uitableview-nsindexpath</id>
    <content type="html"><![CDATA[<p>Swift で <code>UITableView</code> 関連のロジックを書くときに、<code>NSIndexPath</code> を作るときは</p>

<pre><code class="swift">let row = 0, section = 0
NSIndexPath(forRow: row, inSection: section)
</code></pre>

<p>のイニシャライザを使うべし。<code>NSIndexPath(index: row)</code> だと <code>row</code> の参照ができなくてエラーになる。</p>
]]></content>
  </entry>
  
</feed>
