<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: プログラミング | それはBooks]]></title>
  <link href="http://hamasyou.com/blog/tags/puroguramingu/atom.xml" rel="self"/>
  <link href="http://hamasyou.com/"/>
  <updated>2014-02-15T14:41:29+09:00</updated>
  <id>http://hamasyou.com/</id>
  <author>
    <name><![CDATA[hamasyou]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ビューティフルコード]]></title>
    <link href="http://hamasyou.com/blog/2014/02/14/4873113636/"/>
    <updated>2014-02-14T21:19:05+09:00</updated>
    <id>http://hamasyou.com/blog/2014/02/14/4873113636</id>
    <content type="html"><![CDATA[<p>本書は、ブライアン・カーニハンをはじめ一流のプログラマが各々の考える「<em>美しいコード</em>」を紹介するエッセイです。</p>

<p>世界屈指の一流ハッカーがこれぞ！と思うコードを読むことができる貴重な一冊です。</p>

<p>名前付け、アルゴリズム、アーキテクチャ、ショートコードなどなど美しいコードとして紹介されているものは様々です。また、言語も様々なため、知らない言語のコードは美しさがよくわからないところもあるかもしれません。</p>

<p>それでも、30人を越える偉人が紹介する <strong>ビューティフルコード</strong> は、プログラミング好きにはたまらないと思います。</p>

<!-- more -->


<h2>おぼえがき</h2>

<h3>美しいコードの第一歩</h3>

<p>美しいプログラムを書く第一歩は、 <em>だいたい正しく動くコードを書くところ</em> から始まります。エラー処理や例外処理を除いたほとんどの場合に正しく動く。そこから美しいコードは生み出されます。</p>

<p>美しいプログラムは、やさしい条件を先に扱って、難しい条件を後に書きます。</p>

<p><blockquote><p>デザイナーが自分は完璧に達成したんだと分かるのは、付け加えるべきものが何もない時ではなく、取り去るべきものが何もない時である。</p></blockquote></p>

<p>Jon Bentley が自分が書いた一番美しいコードとして紹介しているクイックソートのコードです。</p>

<pre><code class="c quicksort.c">void quicksort(int l, int u)
{
    int i, m;
    if (l &gt;= u) return;
    swap(l, randint(l, u));
    m = l;
    for (i = l+1; i &lt;= u; i++)
        if (x[i] &lt; x[l])
            swap(++m, i);
    swap(l, m);
    quicksort(l, m-1);
    quicksort(m+1, u);
}
</code></pre>

<p><blockquote><p>プログラミングは実用的なスキルだと信じており、「実用的なスキルは、真似をすることと練習することで獲得する」</p></blockquote></p>

<h3>プログラムの速度</h3>

<p>正しく、美しく、速く。プログラムはこの順番であるべきです。クヌース先生は言いました。「<em>未熟な段階での最適化は、プログラミングに置ける諸悪の根源</em>」であると。</p>

<p>正しく動くコードを書いて、O(N<sup>2</sup>) の場合には O(logN) に落とす。できれば O(N) にしたいところですが。正しいコードを美しくすることで、速度が改善されることが往々にしてあります。</p>

<h3>フレームワーク設計</h3>

<p>フレームワークの設計で一番の難題は、API をいったん公開したら、公開 API の仕様を変更したり、インターフェースを変えたりすることが難しくなることです。</p>

<p>この問題に対応するための伝統的な方法が次のものになります。</p>

<ol>
<li>public とするものは公開範囲を小さく保つ</li>
<li>インターフェースを使い、できるだけ実装だけでは公開しない</li>
<li>拡張を意図する場所は「フック」を良く考えて用意しておく</li>
<li>拡張が起こってほしくない場所は拡張できないようにする</li>
</ol>


<p>JavaMail の例です。</p>

<pre><code class="java">package javax.mail;

public final class Session {
    ...
    public static Session getDefaultInstance(Properties props);
    ...
    public Store getStore() throws NoSuchProviderException;
    ...
}
</code></pre>

<pre><code class="java">public abstract class Store extends javax.mail.Service {
    ...
    public void addStoreListener(StoreListener listener);
    ...
}
</code></pre>

<h3>ビューティフル・テスト</h3>

<p>テストを美しくする3つの手法。</p>

<dl>
<dt>簡潔さゆえに美しいと言えるテスト</dt>
<dd>数行のテストコードで対象コードの基本的な動作を文章化したり検証できる。短いコードで端的に動作を説明できているので美しい。</dd>
<dt>コードの優雅さ、保守性、テストしやすさを増す方法が分かるために美しいと言えるテスト</dt>
<dd>コードをもっと美しくするのを助けてくれるようなテストのこと。プログラムの論理的な問題点、構造の問題、設計上の問題に気付く助けになるようなテストは美しい。</dd>
<dt>幅と深さゆえに美しいと言えるテスト</dt>
<dd>基本的なケースや厳選したケースだけでなく、すべてのケースにおいてコードが期待通りに動くという自信を持たせてくれるようなテストコードは美しい。</dd>
</dl>

<h3>大きなビットマップ画像を扱う処理</h3>

<p>縦px×横px×深さの3重ループで処理するのは論外。フィルタロジックをハードコード刷るよりも良い方法は、ビットマップの大きさ、ピクセルの深さ、フィルタの大きさと要素の値に応じて、その場でカスタムコードを生成すること。</p>

<p>（<span class="text-warning">うーむ、ちょっとここはいまいち理解が出来ませんでした。。本書を読んで自分で理解してください。。</span>）</p>

<h3>ネットワーク</h3>

<p><blockquote><p>インターネットを使えば通信線でつながったハッカー達は世界中どこからでも仕事ができる。なんて言われているけど、そんなことを吹聴している奴らはカリフォルニアのごく狭い場所に集まっている。</p></blockquote></p>

<p>エンドユーザ向けのアプリケーションでは、使いやすさが極めて重要です。また、スタートダッシュの為には、まず <em>動くプロトタイプで本質部分を作って</em> そこから製品レベルに持っていくのは常によいアイデア。</p>

<p>システムをできる限りシンプルに保つことは常に偉大なアイデアです。ソフトウェアは <em>なまもの</em> なので、常に注意し、更新し、機能追加し、修正し、調整し、サポートする必要があります。</p>

<h2>感想</h2>

<p>美しいコードの基準は人それぞれですが、共通してい言えることは <strong>正しく動く</strong>、<strong>ムダな部分がない</strong>、<strong>高速に動作する</strong> ものだと思いました。</p>

<p>プログラミングのエッセイだと、やっぱりアルゴリズム系の話題が多いので、ソースコードの見た目が美しいとかいうのはあまりなく、設計思想や短いコードにいろいろな意味が込められているようなものを美しいと感じる偉人が多いようでした。</p>

<p>簡単な問題から解く。正しさが疑いようのないくらいシンプルにコードを保つ。そういうのが大事だと改めて感じました。</p>

<p>ある程度広くコンピュータの知識がある人は、本書を読むと「なるほど」となる場面が多いと思います。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[小飼弾のコードなエッセイ ~我々は本当に世界を理解してコードしているのだろうか? ]]></title>
    <link href="http://hamasyou.com/blog/2013/06/24/4774156647/"/>
    <updated>2013-06-24T22:34:00+09:00</updated>
    <id>http://hamasyou.com/blog/2013/06/24/4774156647</id>
    <content type="html"><![CDATA[<p>コード。ラテン語で codex。codex とはもともとローマ法大全のことを指し示す言葉だそうです。コードは読みとくべきであり、書き下されるべきものである。そしてそれができたとき、喜びが生まれる。弾さんのまえがきにある言葉ですが、コーディング好きなプログラマのみなさんはこの言葉がよくわかると思います。</p>

<p>本書は、プログラミングに関わるいろいろな事柄が短文のエッセイの形でまとめられています。もともと Software Design の連載だったものをまとめたもののようですが、まとめて読むことに価値があると思います。</p>

<p>弾さんのコンピュータの捉え方、プログラミングの姿勢、豊富な知識や知見がまとめられています。スイスイと読んでいける日本版の『<a href="http://www.amazon.co.jp/gp/product/4274066304?ie=UTF8&camp=247&creativeASIN=4274066304&linkCode=xm2&tag=sorehabooks-22" rel="external nofollow">Joel on Software</a>』です。</p>

<!-- more -->




<h2>はじめに</h2>


<p>コードな世界へ、ようこそ!</p>

<p>コード?コードって何でしょう?</p>

<p>元をたどると、この言葉はラテン語 codex に行き着きます。</p>

<p><blockquote><p></p></p><p><p>ORIGIN Middle English: via Old French from Latin codex, codic- (see codex). The term originally denoted a systematic collection of statutes made by one of the later Roman emperors, particularly that of Justinian&hellip;</p></p><p><p></p><footer><strong>Oxford American Dictionary</strong></footer></blockquote></p>

<p>ここに出てくるJustinianとはユスティニアヌス1世のこと。「ローマ法大全」(Corpus Iuris Civilis)を編纂させた人。codexとは、元々はこのローマ法大全のことを指し示す言葉だったのです。固有名詞から生じた一般名詞。</p>

<p>このことはBibleという言葉の対局にあります。こちらは元々は「本」という一般名詞でした。そのことは bibliomania (本の虫&ndash;どこの私だ?)、 bibliography (本の目録)といった英単語からも伺うことができます。Bibleとは"The Book"という意味だったのですね。一般名詞から生じた固有名詞。</p>

<p>コードに話を戻しましょう。本来のコードであったローマ法に関して、塩野七生はこう述べています。</p>

<p><blockquote><p></p></p><p><p>人間の行動原則の正し手を、 宗教に求めたユダヤ人。 哲学に求めたギリシア人。 法律に求めたローマ人。</p></p><p><p></p><footer><strong>ローマ人の物語</strong></footer></blockquote></p>

<p>この意味において、日本を含め、およそ法治国家を標榜する国々の市民はローマ人の末裔ということになります。</p>

<p>ところが、このローマ人、法を作成し、改訂し、施行することには熱心でも、編纂することには少しも熱心ではなかったのです。前述のユスティニアヌス1世の527年から565年。ローマの全盛期はとっくに過ぎて、東西に分裂した後だったのです。</p>

<p>おそらく、それに熱心に取り組んでいる人にとって、それはあまりに当然で必然なことで、わざわざ「外から」編纂するという気持ちにはなりにくかったのでしょう。</p>

<p>ローマ人にとってそうであったように、コードという言葉は現代人にとってそういう存在になりつつあります。ただし現代人にあってローマ人になかったものが一つあります。</p>

<p>それが、電脳(computer)。これはローマ人に奴隷がいて現代人にはいないこと(になっている)ことと対をなしています。ローマ法はあくまでローマ市民に適用されるものであって非市民たる奴隷や異邦人(barbarian)に適用されるものではなかったのですが、現代人は、その電脳で実行されるプログラムのことも、コードと呼んでいます。</p>

<p>本書の「コード」は、その双方を指しています。電脳に適用するコードと、人脳に適用するコード、その双方を。いや、もしかしてもう一つあるかも知れません。この世界自体に適用されている、コード。</p>

<p>最後のそれは、「法則」とも呼ばれます。残念ながらこれは我々が書き下したものではなく、この世界自身に書かれているものです。それを読み解く人が、科学者。そして人電両脳のコードを読み書きする人が、技術者。これは、科学者と技術者の違いでもあります。扱うコードがリードオンリなのかライタブルなのか。</p>

<p>本書の想定読者は、一応後者たる技術者ということになっています。しかしこの両者が深く繋がっていることを、私は「<a href="http://www.amazon.co.jp/gp/product/4041103851?ie=UTF8&camp=247&creativeASIN=4041103851&linkCode=xm2&tag=sorehabooks-22" rel="external nofollow">『中卒』でもわかる科学入門</a>」に書いています。</p>

<p><blockquote><p>およそどんな人でも、幸せな瞬間というのは次の二つしかないのかも知れません。</p></p><p><ol><br/><li>できなかったことができるようになった瞬間</li><br/><li>わからなかったことがわかった瞬間</li><br/></ol></p><p><br/><p></p></blockquote></p>

<p>コードは読み解くべきものでもあり、書き下されるべきものでもある。そしてそれが出来た時、よろこびが生まれる。</p>

<p>それが私にとってのコードであり、本書で扱うコードの範囲(scope)です。</p>

<p>では改めて。コードな世界へ、ようこそ!</p>

<h2>もくじ</h2>




<ul class="list-unstyled">
<li>#0 堂々とevaろう。でもevaりすぎにご用心</li>
<li>#1 Y談。</li>
<li>#2 I/O止めないで</li>
<li>#3 メモレカス、ナマケモノドモ</li>
<li>#4 殺速と複殺</li>
<li>#5 OS、SOS</li>
<li>#6 自縄自縛のススメ</li>
<li>#7 Body and Soul</li>
<li>#8 Mathコミュニケーション</li>
<li>#9 コードと法律の共通点</li>
<li>#10 バカと電脳は使いよう</li>
<li>#11 データは人のためならず</li>
<li>#12 Connect</li>
<li>#13 いまそこにある夢</li>
<li>#14 最後のファイルシステム</li>
<li>#15 ファイルシステムの終わり</li>
<li>#16 From Jobs' Apple to Apple's jobs </li>
<li>#17 Too Beautiful to be Windows</li>
<li>#18 点と線</li>
<li>#19 1%のコードと99%のコンフィギュレーション</li>
<li>#20 言語のチュウス[ウイ]</li>
<li>#21 並べ方と並べ替え方</li>
<li>#22 参照にしか値しない</li>
<li>#23 働いたら負けなら、働いてもらえばいいじゃない</li>
<li>#24 安物買いの安全失い</li>
<li>#25 Not Even Odd</li>
<li>#26 安増税の税失い</li>
<li>#27 たまには( )つけてみよう</li>
<li>#28 ニシキヘビに呑み込めないもの</li>
<li>#29 三位<一体</li>
<li>#30 Where do(es) you(r heart) want to go today</li>
<li>#31 The Round Lens Square Hole</li>
<li>#32 Can we still stay hungry?</li>
<li>#33 Where has all the foolish gone?</li>
<li>Ex.0 美しいプログラムの美しくないソース</li>
<li>Ex.1 アマグラマのすすめ美徳その1:怠慢</li>
<li>Ex.2 アマグラマのすすめ美徳その2:短気</li>
<li>Ex.3 アマグラマのすすめ美徳その3:傲慢</li>
<li>Ex.4 プログラマでなくても名前ぐらい覚えておきたいアルゴリズム×11</li>
<li>Ex.5 プログラミングいつまでに学ぶ? なぜ学ぶ?</li>
</ul>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ディジタル作法 －カーニハン先生の「情報」教室－]]></title>
    <link href="http://hamasyou.com/blog/2013/06/23/4274069095/"/>
    <updated>2013-06-23T17:31:00+09:00</updated>
    <id>http://hamasyou.com/blog/2013/06/23/4274069095</id>
    <content type="html"><![CDATA[<p>本書は、現在のコンピュータシステムや通信システムがどのように動作しているのかを、ハードウェアとソフトウェアの両方の視点から解説している一般の人向けの本です。コンピュータのことをもっとよく知りたい、コンピュータがどのように動作しているかをもっと知りたい、そういった人にオススメの一冊です。</p>

<p><blockquote><p></p></p><p><p>&ldquo;D is for Digital&rdquo; （ディジタル作法） は、コンピュータシステムや通信システムがどのように動作しているかを、簡潔に、それでいて細かいところまで丁寧に説明した本であり、自分たちが暮らしている世界のことをより良く分かっておきたいと考える一般読者（専門家ではない人）を対象にしています。本書では、今日の世界におけるコンピュータシステムや通信システムがどのように動作しているかということを、ハードウェアおよびソフトウェアからインターネット、Webに到るまで、ひととおり説明しています。</p></p><p><p></p><footer><strong>『本書』日本語版の刊行に寄せてより</strong></footer></blockquote></p>

<!-- more -->


<p>コンピュータの理論、コンピュータの仕組みというのは情報系の大学であれば授業で習うと思いますが、情報系の大学を出ていない人にはコンピュータが実際にどのように動作して、コンピュータがなぜインターネットに繋がって、コンピュータがなぜアプリケーションを実行できるのかをきちんと説明するのは難しいと思います。情報系の大学を出ていても説明できない人もいますしね。。</p>

<p>本書は、大学で習うようなこれらの基礎的なことを一般の人にも分りやすい平易な説明や例を使って解説してくれている本になります。ハードウェアとしてのコンピュータ、ソフトウェアの集まりとしてのコンピュータ、PC以外のコンピュータ、コンピュータは色々な形をしています。1から説明をしたのではたった300ページで説明を終えることなど出来るはずはないと思います。</p>

<p>でも、本書を読み終わると一通りコンピュータのことを理解できてしまった気になります。さすがはカーニハン先生が書いただけのことはあるなと。コンピュータがなぜ動いているのか理解した人にオススメです！</p>

<h2>おぼえがき</h2>




<h3>CPU</h3>


<p>CPU はコンピュータが計算するを行うための装置のことです。最近の CPU は「2.1 GHz Intel Core Duo」というような記述があります。Intel は CPU のメーカで、<strong>コア（Core）</strong>というのは CPU と同じ意味になります。CPU はクロックと呼ばれる信号を使用して動作します。1秒間に1刻みする信号を1Hzといい、2.1 GHz は1秒間に2,100,000,000回動作するというわけです。</p>

<h3>ビット・バイト</h3>


<p>コンピュータはディジタル処理装置である。コンピュータは情報をビットで表現する。ビット列に寄って大きな情報が表せる。数値、文字、音、画像、動画、プログラムなどはすべてビット列で表される。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[世界でもっとも強力な9のアルゴリズム]]></title>
    <link href="http://hamasyou.com/blog/2013/02/05/482228493X/"/>
    <updated>2013-02-05T22:17:00+09:00</updated>
    <id>http://hamasyou.com/blog/2013/02/05/482228493X</id>
    <content type="html"><![CDATA[<p><blockquote><p></p></p><p><p>この本で取り上げた偉大なアルゴリズムから導き出せる共通のテーマはあるだろうか。この本の著者として私がとても驚いたのは、これらの大きなアイデアは、どれもコンピュータプログラミングやコンピュータ科学の予備知識を一切必要とせずに説明できることだ。</p></p><p><p>&lt;中略></p></p><p><p>この本のアルゴリズム全体に共通するもう1つの重要なテーマは、コンピュータ科学という学問分野がただのプログラミングよりもずっと大きな世界だということだ。</p></p><p><p>&lt;中略></p></p><p><p>私が目指したのは、読者に偉大なアルゴリズムについての知識を仕入れてもらって、日常のコンピュータ操作の中でもこれはすごいと感じてもらえるようにすることだ。</p></p><p><p></p><footer><strong>本書</strong></footer></blockquote></p>

<p>9つの偉大なアルゴリズム、<em>検索エンジンのインデクシング</em>、<em>ページランク</em>、<em>公開鍵暗号法</em>、<em>誤り訂正符号</em>、<em>パターン認識</em>、<em>データ圧縮</em>、<em>データベース</em>、<em>デジタル署名</em>、<em>決定不能性</em>を知ることで、僕達の周りでこれらのアルゴリズムがどうやって機能していて、何が担保されているのか理解できるようになります。</p>

<p>これらのアルゴリズムを知ることで、コンピュータの世界はすごいことが起こっていると知ってもらい、新たに出てくる問題の解決の一つになるといいなと思います。</p>

<p>読み物なので、どんな人にもおすすめです。</p>

<!-- more -->




<h3>検索エンジンのインデクシング</h3>


<p>検索エンジンは「NEAR」（キーワードが近くにあることを条件にする検索）を使ってランキングの精度を上げている。</p>

<p>また、メタワードトリック（タイトル、見出し、リンクなどのメタ情報のどこにキーワードが含まれているか）をつかって精度を上げている。</p>

<h3>ページランク</h3>


<p>ハイパーリンクトリック（リンクされているかどうか）、オーソリティトリック（有名なところからのリンクは高評価）、ランダムサーファートリック（ランダムにページを選択肢リンクをたどる）などのアルゴリズムが使われている。</p>

<p>なお、Google のページランクはもっと複雑な条件で行われている。</p>

<h3>公開鍵暗号法</h3>


<p>「共有された秘密」をどのように作るかがポイント。</p>

<h3>誤り訂正符号</h3>


<p><q>人に誤っていると教えることと真実を与えることは別のことだ。</q></p>

<p>チェックサムと呼ばれる冗長化符号を付与してデータ通信することで、途中でデータが変更されたかどうかを検知する。</p>

<h3>パターン認識</h3>


<p>パターン認識は、2段階で動作する。訓練データを処理してクラスの特徴を抽出する「学習（訓練）段階」。新しい分類ラベルの付いていないデータを分類する「分類段階」である。</p>

<h3>データ圧縮</h3>


<p>まとまったデータをより短いシンボルで表すロスなし圧縮と、データの一部を取り除いてしまうロス有り圧縮がある。</p>

<h3>データベース</h3>


<p>「to-doリスト」、「仮想テーブル」、「準備してからコミット」。</p>

<h3>デジタル署名</h3>


<p>デジタル署名はあなたが誰か他人に送るものに署名するのではなく、誰か他人があなたにモノを送る前にその送ろうとしているモノに署名をする。</p>

<p>例えば、プログラムをダウンロード、実行しようとするたびに、ウェブブラウザはプログラムがデジタル署名を持っているかどうかをチェックし、その署名が有効かどうかをチェックする。</p>

<p>デジタル署名が提供するのは、機密性ではなく文章の真正性である。</p>

<h3>決定不能性</h3>


<p>他のプログラムを分析し、そのなかに含まれていてプログラムをクラッシュさせる原因になるようなバグをすべて見つけ出すプログラムは書けない。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[プログラマが知るべき97のこと]]></title>
    <link href="http://hamasyou.com/blog/2011/08/16/4873114799/"/>
    <updated>2011-08-16T09:45:00+09:00</updated>
    <id>http://hamasyou.com/blog/2011/08/16/4873114799</id>
    <content type="html"><![CDATA[<p>本書は、「プログラマ」の、「プログラマ」による、「プログラマ」のための本です。</p>

<ul><li>プログラマとして成功したい！</li>
<li>プログラミングの腕を上達させたい！</li>
<li>ソースコードの質を向上させたい！</li>
<li>メンバーと上手くやりたい！</li></ul>


<p>こういった願いを持つ人のために、世界中でよく知られた著者陣のエッセイがまとめられています。</p>

<p>何か壁にぶち当たっている人、成功したプログラマはどんなことを考えていたのか知りたい人、どういうことを考えてプログラムを書けば質が上がるのか知りたい人。</p>

<p>すべての「プログラマ」におすすめの一冊です。</p>

<p><section></p>

<h4 class="note">参考</h4>


<p><a href="http://ja.wikisource.org/wiki/%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9E%E3%81%8C%E7%9F%A5%E3%82%8B%E3%81%B9%E3%81%8D97%E3%81%AE%E3%81%93%E3%81%A8" rel="external nofollow">プログラマが知るべき97のこと - Wikisource</a></p>

<p></section></p>

<!-- more -->




<h2>カテゴリ別目次</h2>




<ul>
<li>バグとその修正</li>
<li>ビルドとデプロイメント</li>
<li>コーディングガイドラインとコードレイアウト</li>
<li>設計原則とコーディングテクニック</li>
<li>ドメインの考慮</li>
<li>エラー、例外とその処理</li>
<li>技術、知識の習得</li>
<li>夜と魔法</li>
<li>パフォーマンス向上、最適化、その具体策</li>
<li>プロとしての心構え、態度</li>
<li>プログラミング言語とパラダイム</li>
<li>リファクタリングと保守</li>
<li>再利用と重複</li>
<li>スケジュールと納期、見積もり</li>
<li>シンプルさ</li>
<li>チームワークと強調</li>
<li>テストとその実践、テスター</li>
<li>ツール、自動化、開発環境</li>
<li>コードと顧客</li>
</ul>




<h2>おぼえがき</h2>


<p>本書は、良いことばかり書いてあり、おぼえがきを真面目に書こうとすると全部抜き出すことになっちゃうので適当に抜き出しました。</p>

<p>すごくいいことがいっぱい書いてあるので、一度本屋で立ち読みしてみるといいと思います。</p>

<h3>コードの再利用</h3>


<p>コードの再利用をするときは、<em>コンテキスト</em>が同じかどうかを確認すること。システム内に同じことをするコードが二つあったとしてもそれぞれが違う役割をしていたら、それはコンテキストが違うから再利用のメリットは少ない。</p>

<p><blockquote><p>「再利用」は一般に良いこととされており、確かに基本的には良いことだからです。コンテキストさえ適切なら、間違いなく有効です。しかし、コンテキストが不適切だと、メリットよりもコストのほうが大きくなるのです。</p></p><p><p></p><footer><strong>本書-共有は慎重により</strong></footer></blockquote></p>

<h3>DRY原則</h3>


<p>「<strong>DRY（Don&rsquo;t Repeat Yourself:繰り返しを避ける）原則</strong>」とは「すべての<em>知識</em>はシステム内において、単一、かつ明確な、そして信頼できる表現になっていなければならない」という条件をみたすこと。</p>

<p>「知識」が唯一であるということがポイントで、その知識を取り出すコードの重複は DRY 原則違反ではない。その知識を取り出すコードの重複を一箇所にまとめることは、<strong>OAOO（Once and Only Once）</strong>と呼ぶ。</p>

<h3>技術的例外とビジネス例外を明確に区別する</h3>


<p>技術的例外、たとえばネットワークに繋がらない、データベースに繋がらない、配列のインデックスを超えてアクセスしたなどの例外と、預金額を超える額のお金を口座から引き出そうとしたというようなビジネス例外は、明確に別れた例外階層を使うべき。</p>

<h3>良いインターフェース仕様の条件は「正しい使い方を簡単に、誤った使い方を困難に」</h3>


<p>良いインターフェースは、<em>正しく使用することが操作ミスをするよりも簡単</em>である。良い API を設計するときに考えることは「<strong>それが一番自然かどうか</strong>」</p>

<h3>名前重要</h3>


<p>「<em>すべての人物・事物には真の名前があり、その名前を知るものはそれを支配することができる</em>」本当にしっくりくる名前を選択することは、とても重要なことで、適切な名前を選択できたら8割は設計が完成したと考えても大げさではない。</p>
]]></content>
  </entry>
  
</feed>
