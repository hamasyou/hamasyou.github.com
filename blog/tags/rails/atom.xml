<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: Rails | それはBooks]]></title>
  <link href="http://hamasyou.com/blog/tags/rails/atom.xml" rel="self"/>
  <link href="http://hamasyou.com/"/>
  <updated>2014-03-04T15:24:11+09:00</updated>
  <id>http://hamasyou.com/</id>
  <author>
    <name><![CDATA[hamasyou]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[canonicalなURLってなにがいいんだろう？]]></title>
    <link href="http://hamasyou.com/blog/2014/03/04/canonical-url/"/>
    <updated>2014-03-04T12:27:08+09:00</updated>
    <id>http://hamasyou.com/blog/2014/03/04/canonical-url</id>
    <content type="html"><![CDATA[<p>ちょっと疑問に思ったこと。Web の SEO をやっていると <strong>canonical</strong> ページっていうのを聞いたことがあるとおもいます。
canonical ページとは、Google 先生曰く「<em>複数の類似した内容のページの中で優先されるページです。</em>」だそうです。
僕は <strong>URL の正規化</strong> に使うものだという認識ですが、間違ってませんよね？？</p>

<p>で、この canonical URL ってどう付けたらいいんだろう？っていう疑問です。</p>

<!-- more -->


<h2>canonical URL ってどっち？</h2>

<h3>RESTful リソースの URL</h3>

<p>Web サービスやっていると、<strong>RESTful</strong> な URL 設計大事！ってなりますよね。
Rails なんかをやっていると、ルーティングが自動的に RESTful になってて便利です。こんな感じ。</p>

<pre><code class="console-raw">{% raw %}
       hypermedia GET    /hypermedia(.:format)            hypermedia#index
                  POST   /hypermedia(.:format)            hypermedia#create
  new_hypermedium GET    /hypermedia/new(.:format)        hypermedia#new
 edit_hypermedium GET    /hypermedia/:id/edit(.:format)   hypermedia#edit
      hypermedium GET    /hypermedia/:id(.:format)        hypermedia#show
                  PATCH  /hypermedia/:id(.:format)        hypermedia#update
                  PUT    /hypermedia/:id(.:format)        hypermedia#update
                  DELETE /hypermedia/:id(.:format)        hypermedia#destroy
{% endraw %}
</code></pre>

<p>こういうルーティングだと、<code>http://example.com/hypermedia/1</code> みたいな感じでリソースにアクセスできます。
で、例えば、作ってる Web サービスで、<code>hypermedia/1</code> リソースの別名で、hypermedia の URL を使ってもアクセスできるようにしたい。こんな感じで。</p>

<pre><code class="console-raw">http://example.com/hamasyou.com
</code></pre>

<p>ルーティングに</p>

<pre><code class="ruby">get '*url', to: 'hypermedia#show', format: false
</code></pre>

<p>を追加しておくと <code>hypermedia#show</code> の中で <code>params[:url]</code> から <code>hamasyou.com</code> っていう値をとれるようになります。
なので、こういう URL に別名付けてちょっとクールな感じの Web サービスを気取ってみたくなりました。</p>

<h3>どっちがいいの？</h3>

<p>で、本題ですが、こういうリソースの別名扱いの URL があるとき、canonical URL として指定するのは</p>

<ol>
<li><code>/hypermedia/:id</code></li>
<li><code>*url</code></li>
</ol>


<p>のどっちがいいんだろう？という疑問です。HTML 的に書くとこんな感じ。</p>

<pre><code class="html">&lt;link rel="canonical" href="http://example.com/hypermedia/1"&gt;
&lt;link rel="canonical" href="http://example.com/hamasyou.com"&gt;
</code></pre>

<p>どっちでもいい。好みの問題って感じもしなくもないですが、皆さんどっちを選ぶのが多いんでしょう？</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Capistrano3をRailsで使ってみた感想]]></title>
    <link href="http://hamasyou.com/blog/2014/02/20/capistrano3/"/>
    <updated>2014-02-20T11:25:05+09:00</updated>
    <id>http://hamasyou.com/blog/2014/02/20/capistrano3</id>
    <content type="html"><![CDATA[<p><strong>Capistrano3</strong> がかなりシンプルになって使いやすくなったのでプロジェクトで使ってみました。うん。なかなかよさげです。</p>

<p>Capistrano2 にあった <em>copy_via</em> がなくなっていたので、デプロイ先のサーバから Git リポジトリにアクセスできるようにしないといけなかったりとちょっと面倒なこともありましたが概ね良好です。</p>

<!-- more -->


<p><a href="https://github.com/capistrano/capistrano">capistrano / capistrano</a></p>

<p>Capistrano3 の導入はこの記事がオススメです。</p>

<p><a href="http://threetreeslight.com/post/68344998681/capistrano-3-x-rails">capistrano 3.x系を使ってrailsをデプロイ</a></p>

<p>Capistrano3 になって、独自DSLから Rake に変わりました。なので、コマンドも結構すっきりして書きやすくなりました。</p>

<p>サンプルプロジェクトで使った <code>config/deploy.rb</code> の例です。</p>

<pre><code class="ruby config/deploy.rb"># config valid only for Capistrano 3.1
lock '3.1.0'

set :application, 'capbox'
set :repo_url, 'git@github.com:hamasyou/git_demo.git'
set :deploy_to, '/var/webapp/capbox'

set :linked_files, %w{config/database.yml}
set :linked_dirs, %w{bin log tmp/pids tmp/cache tmp/sockets vendor/bundle public/system solr}

namespace :deploy do

  before :restart, :start_solr do
    on roles(:app), in: :groups do
      within release_path do
        with rails_env: fetch(:rails_env) do
          execute :rake, 'sunspot:solr:stop'
          execute :rake, 'sunspot:solr:start'
        end
      end
    end
  end

  desc 'Restart application'
  task :restart do
    on roles(:app), in: :sequence, wait: 5 do
      execute :touch, release_path.join('tmp/restart.txt')
    end
  end

  after :publishing, :restart

  after :restart, :sitemap do
    on roles(:app), in: :groups, limit: 3, wait: 10 do
      # Here we can do anything such as:
      within release_path do
        with rails_env: fetch(:rails_env) do
          execute :rake, 'tmp:cache:clear'
          execute :rake, 'sitemap:refresh'
        end
      end
    end
  end
end
</code></pre>

<p>タスクの実行時に指定できる <code>sequence</code>、<code>groups</code>、<code>parallel</code> の説明はこちら。</p>

<p>{% blockquote Capistrano Version 3 Release Announcement http://capistranorb.com/2013/06/01/release-announcement.html %}
Other modes for parallelism include:</p>

<pre><code class="ruby">    # Capistrano 3.0.x
    on :all, in: :groups, max: 3, wait: 5 do
      # Take all servers, in groups of three which execute in parallel
      # wait five seconds between groups of servers.
      # This is perfect for rolling restarts
    end

    on :all, in: :sequence, wait: 15 do
      # This takes all servers, in sequence and waits 15 seconds between
      # each server, this might be perfect if you are afraid about
      # overloading a shared resource, or want to defer the asset compilation
      # over your cluster owing to worries about load
    end

    on :all, in: :parallel do
      # This will simply try and execute the commands contained within
      # the block in parallel on all servers. This might be perfect for kicking
      # off something like a Git checkout or similar.
    end
</code></pre>

<p>{% endblockquote %}</p>

<p>Capistrano2 と互換性がないですが、新規プロジェクトには使えるんじゃないかと。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RailsのI18n.localizeでnilもゆるすようにすると捗る]]></title>
    <link href="http://hamasyou.com/blog/2014/02/19/rails-i18n-localize/"/>
    <updated>2014-02-19T22:30:13+09:00</updated>
    <id>http://hamasyou.com/blog/2014/02/19/rails-i18n-localize</id>
    <content type="html"><![CDATA[<p>Rails の <code>I18n.localize</code> は <code>nil</code> を渡すと例外が発生します。でも、コレだといろいろ使いづらいのでいつも</p>

<pre><code class="ruby config/initializers/relaxed_i18n.rb">module I18n
  class &lt;&lt; self
    alias_method :original_localize, :localize
    def localize(object, options = {})
      object.present? ? original_localize(object, options) : ''
    end
  end
end
</code></pre>

<p>こんな感じのコードを <code>config/initializers</code> の下において使っています。<code>nil</code> を渡すと空文字を返します。</p>

<p>今のところコレで問題は起きていないのでオススメしてもいいかなと。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RailsでつくるRESTful APIのrequest specを書く]]></title>
    <link href="http://hamasyou.com/blog/2014/02/17/rails-request-rspec/"/>
    <updated>2014-02-17T14:09:38+09:00</updated>
    <id>http://hamasyou.com/blog/2014/02/17/rails-request-rspec</id>
    <content type="html"><![CDATA[<p>Rails 環境で RESTful API を提供する場面があると思います。API もコントローラで提供するので、コントローラのテストで記述してもいいのですが、RESTful API であれば、<strong>request spec</strong> を使うほうがよさそうなので request spec を書くメモです。</p>

<ul>
<li>Rails 4.0.2</li>
<li>rspec 2.14.1</li>
</ul>


<!-- more -->


<h2>テスト用のプロジェクトを整える</h2>

<p>まずは、チュートリアル用のプロジェクトを作成します。</p>

<p>{% terminal %}
$ rails new specbox &ndash;skip-bundle
$ cd specbox
{% endterminal %}</p>

<p><code>Gemfile</code> を開いて次の gem を追記します。</p>

<pre><code class="ruby Gemfile">group :development, :test do
  gem 'rspec-rails'
  gem 'guard-rspec'
  gem 'factory_girl_rails'
  gem 'spring'
  gem 'spring-commands-rspec'
end
</code></pre>

<p>rspec と scaffold の設定を行います。</p>

<p>{% terminal %}
$ bundle install &ndash;path vendor/bundle
$ bundle exec rails g rspec:install
$ bundle exec guard init rspec
$ bundle exec rails g model Book title:string author:string price:integer
$ bundle exec rails g scaffold_controller Books
$ bundle exec rake db:migrate
$ bundle exec rake db:test:prepare
{% endterminal %}</p>

<p><code>config/routes.rb</code> にルーティングを追加します。</p>

<pre><code class="ruby config/routes.rb">Specbox::Application.routes.draw do
  ...
  resources :books
  ...
end
</code></pre>

<p>テストを実行します。</p>

<p>{% terminal %}
$ bundle exec guard
15:12:01 - INFO - Run all
15:12:01 - INFO - Running all specs
..**&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;..</p>

<p>Pending:
  Book add some examples to (or delete) /Users/hamasyou/tmp/specbox/spec/models/book_spec.rb
    # No reason given
    # ./spec/models/book_spec.rb:4
  BooksHelper add some examples to (or delete) /Users/hamasyou/tmp/specbox/spec/helpers/books_helper_spec.rb
    # No reason given
    # ./spec/helpers/books_helper_spec.rb:14</p>

<p>Finished in 0.18066 seconds
30 examples, 0 failures, 2 pending</p>

<p>Randomized with seed 14063
{% endterminal %}</p>

<p>これで rspec の設定ができました。それでは <em>request spec</em> を書いていきます。</p>

<h2>request spec を書く</h2>

<p><em>request spec</em> は他の rspec のテストとほとんど変わりありません。テストは <code>spec/requests</code> フォルダの下に作成していきます。</p>

<p><code>scaffold_controller</code> でコントローラを作成したので、すでに <code>spec/requests/books_spec.rb</code> があるはずです。テストコードを見てみます。</p>

<pre><code class="ruby spec/requests/books_spec.rb">require 'spec_helper'

describe "Books" do
  describe "GET /books" do
    it "works! (now write some real specs)" do
      # Run the generator again with the --webrat flag if you want to use webrat methods/matchers
      get books_path
      response.status.should be(200)
    end
  end
end
</code></pre>

<p>request spec もコントローラのテストと同じように、<code>get</code>、<code>post</code>、といったメソッドを使ってテストを行います。<code>books_spec.rb</code> を次のように書き換えてみます。</p>

<pre><code class="ruby spec/requests/books_spec.rb">require 'spec_helper'

describe 'Books' do
  describe 'GET /books' do

    it '登録されている本が返されること' do
      book = FactoryGirl.create(:book)
      get '/books', format: 'json'
      expect(response).to be_success
      expect(json).to be_a_kind_of(Array)
      expect(json[0]['id']).to eq book.id
    end
  end
end
</code></pre>

<p>request spec はこういう感じで、<strong>実際に呼び出す URL を記述する</strong> のと、<strong>json の中身をチェックする</strong> のが大事だと思っています。</p>

<p>コントローラのテストではビューの中身までチェックしませんし、ビューのテストとコントローラのテストを2つ書くのはテストを把握しづらいので、request spec のテストのように一箇所で同時にテストするのが効果的だと思います。</p>

<p>API はインターフェース（<em>入力パラメータ</em> と <em>出力形式</em> ）が大事なのでここをきっちり押さえておくテストを書く必要があります。</p>

<p>で、テストケースを変えると当然テストが失敗するので、テストが通るようにヘルパを書き換えます。</p>

<h3>request_helpers.rb を作成する</h3>

<p>request spec を書くときに便利なメソッドをいくつか用意しておきます。</p>

<p>RESTful API は出力を json で返すものが多いと思うので、json を扱いやすくするヘルパーを用意します。</p>

<p>また、 <code>AuthenticationHelper</code> は認証が必要な API を呼び出すときの便利メソッドとして記述してありますが、不要であれば削除、仕様が違うようであれば書きなおしてつかいます。</p>

<p>次のファイルを <code>spec/support/request_helpers.rb</code> として作成します。</p>

<pre><code class="ruby spec/support/request_helpers.rb">module Requests
  module JsonHelpers
    def json
      @json ||= JSON.parse(response.body)
    end
  end

  module AuthenticationHelper
    %w(get post put delete).each do |method_name|
      define_method("auth_#{method_name}") do |uri, auth_user, params = {}, env = {}, &amp;block|
        __send__(method_name, uri, params, env.reverse_merge(HTTP_AUTHORIZATION: "token #{auth_user.access_token}"), &amp;block)
      end
    end
  end
end
</code></pre>

<p>このヘルパを <code>spec/spec_helper.rb</code> に追加します。</p>

<pre><code class="ruby spec/spec_helper.rb">RSpec.configure do |config|
  ...
  config.include Requests::JsonHelpers, type: :request
  config.include Requests::AuthenticationHelper, type: :request
  ...
end
</code></pre>

<p>これでテストが通るようになりました。</p>

<h2>まとめ</h2>

<p>Rails で RESTful な API を作ることはよくあると思いますが、今までは API のテストもコントローラのテストで行っていました。</p>

<p>でも、request spec を使ったほうが <strong>呼び出しのURL</strong>、<strong>必要なパラメータ</strong>、<strong>出力形式</strong> を素直にテストとして書けるので、API のテストは request spec を使うようにするといいかなと思います。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Railsで手書きの図や絵をプログラムに取り込む方法]]></title>
    <link href="http://hamasyou.com/blog/2013/12/03/rails/"/>
    <updated>2013-12-03T19:05:00+09:00</updated>
    <id>http://hamasyou.com/blog/2013/12/03/rails</id>
    <content type="html"><![CDATA[<p>スマホやタブレットが増えてきて、Railsアプリでも手書きで書いた絵や図を取り込みたいというような案件があるのではないでしょうか？手書き画像が保存する方法はいろいろありますが、そのひとつをちょっとメモのため残しておきます。特別なgemとかは必要ありません。使うのは HTML5 の canvas だけです。</p>

<!-- more -->




<h2>環境</h2>




<ul>
<li>Ruby 2.0.0p353</li>
<li>Rails 4.0.1</li>
<li>bundler</li>
</ul>




<h2>手順</h2>


<p>まず、Rails 環境を作成して足場をつくります。</p>

<p>{% terminal %}
$ rails new blog &ndash;skip-bundle
      create
      create  README.rdoc
      create  Rakefile
      create  config.ru
      create  .gitignore
      create  Gemfile
      create  app
      create  app/assets/javascripts/application.js
      create  app/assets/stylesheets/application.css
      create  app/controllers/application_controller.rb
      create  app/helpers/application_helper.rb
      create  app/views/layouts/application.html.erb
      create  app/assets/images/.keep
      create  app/mailers/.keep
      create  app/models/.keep
      create  app/controllers/concerns/.keep
      create  app/models/concerns/.keep
      create  bin
      create  bin/bundle
      create  bin/rails
      create  bin/rake
      create  config
      create  config/routes.rb
      create  config/application.rb
      create  config/environment.rb
      create  config/environments
      create  config/environments/development.rb
      create  config/environments/production.rb
      create  config/environments/test.rb
      create  config/initializers
      create  config/initializers/backtrace_silencers.rb
      create  config/initializers/filter_parameter_logging.rb
      create  config/initializers/inflections.rb
      create  config/initializers/mime_types.rb
      create  config/initializers/secret_token.rb
      create  config/initializers/session_store.rb
      create  config/initializers/wrap_parameters.rb
      create  config/locales
      create  config/locales/en.yml
      create  config/boot.rb
      create  config/database.yml
      create  db
      create  db/seeds.rb
      create  lib
      create  lib/tasks
      create  lib/tasks/.keep
      create  lib/assets
      create  lib/assets/.keep
      create  log
      create  log/.keep
      create  public
      create  public/404.html
      create  public/422.html
      create  public/500.html
      create  public/favicon.ico
      create  public/robots.txt
      create  test/fixtures
      create  test/fixtures/.keep
      create  test/controllers
      create  test/controllers/.keep
      create  test/mailers
      create  test/mailers/.keep
      create  test/models
      create  test/models/.keep
      create  test/helpers
      create  test/helpers/.keep
      create  test/integration
      create  test/integration/.keep
      create  test/test_helper.rb
      create  tmp/cache
      create  tmp/cache/assets
      create  vendor/assets/javascripts
      create  vendor/assets/javascripts/.keep
      create  vendor/assets/stylesheets
      create  vendor/assets/stylesheets/.keep
$ cd blog
$ bundle install &ndash;path vendor/bundle
Fetching gem metadata from https://rubygems.org/……….
Fetching gem metadata from https://rubygems.org/..
Resolving dependencies…
Installing rake (10.1.0)
Installing i18n (0.6.5)
Installing minitest (4.7.5)
Installing multi_json (1.8.2)
Installing atomic (1.1.14)
Installing thread_safe (0.1.3)
Installing tzinfo (0.3.38)
Installing activesupport (4.0.1)
Installing builder (3.1.4)
Installing erubis (2.7.0)
Installing rack (1.5.2)
Installing rack-test (0.6.2)
Installing actionpack (4.0.1)
Installing mime-types (1.25.1)
Installing polyglot (0.3.3)
Installing treetop (1.4.15)
Installing mail (2.5.4)
Installing actionmailer (4.0.1)
Installing activemodel (4.0.1)
Installing activerecord-deprecated_finders (1.0.3)
Installing arel (4.0.1)
Installing activerecord (4.0.1)
Using bundler (1.3.1)
Installing coffee-script-source (1.6.3)
Installing execjs (2.0.2)
Installing coffee-script (2.2.0)
Installing thor (0.18.1)
Installing railties (4.0.1)
Installing coffee-rails (4.0.1)
Installing hike (1.2.3)
Installing jbuilder (1.5.2)
Installing jquery-rails (3.0.4)
Installing json (1.8.1)
Installing tilt (1.4.1)
Installing sprockets (2.10.1)
Installing sprockets-rails (2.0.1)
Installing rails (4.0.1)
Installing rdoc (3.12.2)
Installing sass (3.2.12)
Installing sass-rails (4.0.1)
Installing sdoc (0.3.20)
Installing sqlite3 (1.3.8)
Installing turbolinks (1.3.1)
Installing uglifier (2.3.2)
$ bundle exec rails g scaffold post
      invoke  active_record
      create    db/migrate/20131203101546_create_posts.rb
      create    app/models/post.rb
      invoke    test_unit
      create      test/models/post_test.rb
      create      test/fixtures/posts.yml
      invoke  resource_route
       route    resources :posts
      invoke  scaffold_controller
      create    app/controllers/posts_controller.rb
      invoke    erb
      create      app/views/posts
      create      app/views/posts/index.html.erb
      create      app/views/posts/edit.html.erb
      create      app/views/posts/show.html.erb
      create      app/views/posts/new.html.erb
      create      app/views/posts/_form.html.erb
      invoke    test_unit
      create      test/controllers/posts_controller_test.rb
      invoke    helper
      create      app/helpers/posts_helper.rb
      invoke      test_unit
      create        test/helpers/posts_helper_test.rb
      invoke    jbuilder
      create      app/views/posts/index.json.jbuilder
      create      app/views/posts/show.json.jbuilder
      invoke  assets
      invoke    coffee
      create      app/assets/javascripts/posts.js.coffee
      invoke    scss
      create      app/assets/stylesheets/posts.css.scss
      invoke  scss
      create    app/assets/stylesheets/scaffolds.css.scss
$ bundle exec rake db:migrate
==  CreatePosts: migrating ====================================================
– create_table(:posts)
   -> 0.0010s
==  CreatePosts: migrated (0.0011s) ===========================================
{% endterminal %}</p>

<p><code>app/views/posts/_form.html.erb</code> を開いて次のコードを追加します。このコードが手書き入力部分（canvas）になります。</p>

<pre><code class="html+erb app/views/posts/_form.html.erb">  &lt;canvas id="paper" class="paper" width="400" height="400" data-target="#sign"&gt;
    ご利用のブラウザではサインは表示できません。
  &lt;/canvas&gt;
  &lt;button type="button" name="clearCanvas" class="clear-canvas"&gt;クリア&lt;/button&gt;
  &lt;input type="hidden" id="sign" name="sign" value="" /&gt;
</code></pre>

<p><code>app/assets/javascripts</code> に paint.js.coffee ファイルを作成し、次のコードをコピペします。</p>

<pre><code class="coffeescript app/assets/javascripts/paint.js.coffee">jQuery ($) -&gt;
    screen2client = (e) -&gt;
        [px, py] = if e.type.startsWith('touch') then [e.originalEvent.touches[0].clientX, e.originalEvent.touches[0].clientY] else [e.clientX, e.clientY]
        rect = e.target.getBoundingClientRect()
        {x: px - rect.left, y: py - rect.top}
    drawFlag = false
    oldX = 0
    oldY = 0
    $canvas = $('#paper')
    $canvas.on 'mousedown touchstart', (e) -&gt;
        drawFlag = true
        {x, y} = screen2client(e)
        [oldX, oldY] = [x, y]
    $canvas.on 'mouseup mouseout touchend touchcancel', -&gt;
        drawFlag = false
        data = $canvas[0].toDataURL()
        $($canvas.data('target')).val(data)
    $canvas.on 'mousemove touchmove', (e) -&gt;
        return unless drawFlag
        {x, y} = screen2client(e)
        context = $canvas[0].getContext('2d')
        context.strokeStyle = '#C71C22'
        context.lineWidth = 1
        context.beginPath()
        context.moveTo(oldX, oldY)
        context.lineTo(x, y)
        context.stroke()
        context.closePath()
        oldX = x
        oldY = y
        e.preventDefault()
        return
    $('.clear-canvas').on 'click', -&gt;
        context = $canvas[0].getContext('2d')
        context.clearRect(0, 0, $canvas[0].width, $canvas[0].height)
        $($canvas.data('target')).val(null)
</code></pre>

<p><code>app/assets/javascript/application.js</code> を開き、ファイルの最後に次のコードを追加します。</p>

<pre><code class="javascript app/assets/javascript/application.js">if (typeof String.prototype.startsWith != 'function') {
    String.prototype.startsWith = function(str) {
        return this.substring(0, str.length) === str;
    }
}
</code></pre>

<p>最後に、画像データを受け取って画像ファイルにする処理をコントローラに追加します。<code>app/controllers/posts_controller.rb</code> を開き、<code>def create</code> に次のコードを追加します。</p>

<pre><code class="ruby app/controllers/posts_controller.rb">f = Tempfile.new(['sign', '.png'], encoding: Encoding::BINARY)
f.write Base64.decode64(params[:sign].sub('data:image/png;base64,', ''))
f
</code></pre>

<p>これで、一時ファイルにキャンバスデータを書き込んでファイル化できます。サーバを起動して <code>http://localhost:3000/posts/new</code> にアクセスして試してみてください。</p>

<p><img src="/images/2013-12-03-rails-ss.png" height="526" width="517" alt="スクリーンショット" /></p>
]]></content>
  </entry>
  
</feed>
