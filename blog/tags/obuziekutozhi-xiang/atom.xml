<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: オブジェクト指向 | それはBooks]]></title>
  <link href="http://hamasyou.com/blog/tags/obuziekutozhi-xiang/atom.xml" rel="self"/>
  <link href="http://hamasyou.com/"/>
  <updated>2014-06-26T23:54:49+09:00</updated>
  <id>http://hamasyou.com/</id>
  <author>
    <name><![CDATA[hamasyou]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[オブジェクト指向JavaScript]]></title>
    <link href="http://hamasyou.com/blog/2012/04/27/4048706705/"/>
    <updated>2012-04-27T12:54:00+09:00</updated>
    <id>http://hamasyou.com/blog/2012/04/27/4048706705</id>
    <content type="html"><![CDATA[<p>本書は、JavaScript を理解するためのものです。JavaScript はプロトタイプベースの言語で、クラスがなかったり、プロパティのアクセス修飾子がなかったり、継承の仕方が特別だったりします。</p>

<p>JavaScript を理解するには、JavaScript は全てがオブジェクトであることを覚えておく必要があります。本書は、こう言った、JavaScript が他のオブジェクト指向言語と違う点を整理し、JavaScript ではこう書くというのを丁寧に解説してくれています。</p>

<p>「JavaScript はブラウザ上で動く小さな言語」という認識だった昔とは、昨今では JavaScript の扱いは変わりました。サーバサイドでも JavaScript を動かしたり、スマートフォンの開発に JavaScript を使ったりと、JavaScript が使える舞台は広がっています。</p>

<p>JavaScript をもう一度ちゃんと理解したいという人に、本書はおすすめです。</p>

<!-- more -->




<h2>おぼえがき</h2>




<h3>プリミティブデータ型</h3>




<dl>
<dt>Number</dt>
<dd>1, 100, 3.14 などの数値。浮動小数点を含む。</dd>
<dt>String</dt>
<dd>'hoge', &quot;foo bar&quot;, などで表現される文字列。</dd>
<dt>Boolean</dt>
<dd>true と false。</dd>
<dt>undefined</dt>
<dd>まだ存在していない変数にアクセスすると得られる値。</dd>
<dt>null</dt>
<dd>値がないことを表す値。</dd>
</dl>




<h3>変数の型をしる <code>typeof</code> 演算子</h3>


<p>変数や値の型を調べるときに使える <strong>typeof演算子</strong>は、<em>&quot;number&quot;</em>、<em>&quot;string&quot;</em>、<em>&quot;boolean&quot;</em>、<em>&quot;undefined&quot;</em>、<em>&quot;object&quot;</em>、<em>&quot;function&quot;</em> のいずれかの値（文字列）を返す。</p>

<h3>Infinity（無限）</h3>


<p><strong>Infinity</strong> は JavaScript で扱えない大きな数値を表すのにつかう値。JavaScript で扱える最大の数値は 1.7976931348623157e+308、最小は 5e-324である。</p>

<pre><code class="javascript">&gt;&gt;&gt; Infinity
Infinity
&gt;&gt;&gt; typeof Infinity
"number"
&gt;&gt;&gt; 1e309
Infinity
</code></pre>

<h3>Boolean に変換されると false になる値</h3>




<ul>
<li>空文字列&quot;&quot;</li>
<li>null</li>
<li>undefined</li>
<li>数値の 0</li>
<li>数値の NaN</li>
<li>Boolean型の false</li>
</ul>




<h3>型変換の Tips</h3>


<p>数字のような文字列を数値に変換する方法は parseInt() 関数を使う方法の他に、1 を掛けるという方法もある。</p>

<pre><code class="javascript">&gt;&gt;&gt; var s = "100";
&gt;&gt;&gt; s = s * 1;
&gt;&gt;&gt; typeof s;
"number"
</code></pre>

<p>文字列に変換する場合、空文字と結合する方法がある。</p>

<pre><code class="javascript">&gt;&gt;&gt; var n = 10;
&gt;&gt;&gt; n = "" + n;
&gt;&gt;&gt; typeof n;
"string"
</code></pre>

<h3>配列の要素の削除</h3>


<p>配列の要素の削除には delete 演算子を使うが、この演算子は配列の要素を減らすわけではなく、undefined を設定する。</p>

<pre><code class="javascript">&gt;&gt;&gt; var a = [1, 2, 3];
&gt;&gt;&gt; delete a[1];
true
&gt;&gt;&gt; a.length;
3
&gt;&gt;&gt; a;
[1, undefined, 3]
</code></pre>

<h3>変数が定義されていて、値が割り当てられているかどうかを確認する方法</h3>


<pre><code class="javascript">if (typeof something !== "undefined") {
  // 何かの処理
}
</code></pre>

<h3>自分自身を書き換える関数</h3>


<p>自分自身を書き換える関数の仕組みは、初期化などの一度だけ行ないたい処理がある場合に使う。</p>

<pre><code class="javascript">var a = function() {
  function someSetup() {
    var setup = 'done';
  }
  function actualWork() {
    alert('Worky-worky');
  }
  someSetup();
  return actualWork;
}();
</code></pre>

<h2>オブジェクト</h2>




<h3>オブジェクトリテラル表記</h3>


<p>{} を使ってオブジェクトを定義することをオブジェクトリテラル表記を呼ぶ。</p>

<pre><code class="javascript">var hero = {
  breed: 'Turtle',
  occupation: 'Ninja'
};
</code></pre>

<p>オブジェクトのプロパティ名はクウォートしないのが推奨されている。ちなみに、連想配列（ハッシュ）のキーは文字列である。</p>

<h3>コンストラクタ関数</h3>


<p>関数を new してオブジェクトを作ることで、関数をコンストラクタとして利用することができる。</p>

<pre><code class="javascript">function Hero(name) {
  this.name = name;
}

&gt;&gt;&gt; var h1 = new Hero('hamasyou');
&gt;&gt;&gt; h1.name;
"hamasyou"
</code></pre>

<h3>グローバル変数</h3>


<p>JavaScript のプログラムは様々なホスト環境（たとえばブラウザ環境）で動作する。JavaScript のホスト環境はグローバルオブジェクトを提供していて、グローバル変数はグローバルオブジェクトのプロパティになる。</p>

<p>たとえば、ブラウザ環境では <em>window</em> というグローバルオブジェクトが提供されており、グローバル変数はすべて、window のプロパティになる。</p>

<p class="option">コンストラクタ関数を定義したにもかかわらず、new でオブジェクトをつくらなかった場合、this はグローバルオブジェクトを指すことになる。</p>




<h3>constructor プロパティ</h3>


<p>オブジェクトが作成されると、<em>constructor</em> プロパティと呼ばれる特別なプロパティに、オブジェクトを作成したときに使われたコンストラクタ関数がセットされる。</p>

<pre><code class="javascript">&gt;&gt;&gt; h1.constructor;
Hero(name)
</code></pre>

<h3>instanceof 演算子</h3>


<p><em>instanceof 演算子</em>を使うと constructor プロパティが指定した関数かどうかを調べることができる。</p>

<pre><code class="javascript">&gt;&gt;&gt; h1 instanceof Hero;
true
</code></pre>

<h3>オブジェクトの比較</h3>


<p>オブジェクト同士を比較すると、両方の変数が同じオブジェクトの参照の場合のみ true を返す。</p>

<h2>プロトタイプ</h2>


<p><blockquote><p></p></p><p><ul><br/><li>このプロパティは関数がコンストラクタのときのみ使われる</li><br/><li>この関数を使って作られたオブジェクトも、prototype プロパティを持ち、関数の prototype と同じオブジェクトを参照する。このオブジェクトのプロパティは自分のプロパティと同じように使える</li><br/></ul></p><p><br/><p></p></blockquote></p>

<h3>prototype プロパティ</h3>


<p>関数は、<em>prototype</em> と呼ばれるプロパティを保持している。初期値は空のオブジェクトになっている。</p>

<pre><code class="javascript">function multiply(a, b) {
  return a * b;
}
&gt;&gt;&gt; multiply.constructor;
Function()

&gt;&gt;&gt; typeof multiply.prototype;
"object"

&gt;&gt;&gt; multiply.prototype;
multiply {}
</code></pre>

<p>prototype プロパティに設定されているオブジェクトには、プロパティとメソッドを追加していくことができる。このオブジェクトは、multiply 関数自身にはなんの影響も与えない。追加したプロパティとメソッドは、multiply をコンストラクタとして利用した場合にのみ使われる。</p>

<pre><code class="javascript">&gt;&gt;&gt; multiply.prototype.name = 'hamasyou';
&gt;&gt;&gt; multiply.name;
"multiply"

&gt;&gt;&gt; var hoge = new multiply();
&gt;&gt;&gt; hoge.name;
"hamasyou"
</code></pre>

<p>prototype プロパティをいつ変更しても、すべてのオブジェクトが影響を受ける点は注意が必要。</p>

<h3>prototype オブジェクトのプロパティを上書きする</h3>


<p>オブジェクト自身のプロパティの方が、prototype オブジェクトのプロパティよりも優先して解決される。</p>

<pre><code class="javascript">var Salary = (function() {
  var salary = function() {};
  salary.prototype.base = 50000;
  salary.prototype.total = function() {
    return this.base * 1.05;
  };
  return salary;
})();

&gt;&gt;&gt; var hoge_salary = new Salary();
&gt;&gt;&gt; hoge_salary.base = 20000;
&gt;&gt;&gt; hoge_salary.total();
21000

var hama_salary = new Salary();
&gt;&gt;&gt; hama_salary.total();
52500
</code></pre>

<h2>継承</h2>




<h3>プロトタイプチェーンで継承を実現する</h3>


<p>JavaScript の prototype プロパティはオブジェクトであるので、自身の prototype も持っている。このように prototype をチェーンして辿っていくことで、継承を実現することができる。</p>

<p>次の例は、本書 P.183 のプロトタイプチェーンの例である。</p>

<pre><code class="javascript">function Shape() {
  this.name = 'shape';
  this.toString = function() { return this.name; }
}

function TwoDShape() {
  this.name = '2D shape';
}

function Triangle(side, height) {
  this.name = 'Triangle';
  this.side = side;
  this.height = height;
  this.getArea = function() {
    return this.side * this.height / 2;
  };
}

TwoDShape.prototype = new Shape();
Triangle.prototype = new TwoDShape();
TwoDShape.prototype.constructor = TwoDShape;
Triangle.prototype.constructor = Triangle;

&gt;&gt;&gt; var my = new Triangle(5, 10);
&gt;&gt;&gt; my.getArea();
25
&gt;&gt;&gt; my.toString();
"Triangle"
</code></pre>

<p>Triangle クラスには toString メソッドは定義されていないが、Shape 関数で定義されていることで、プロトタイプチェーンをたどって呼び出すことができる。</p>

<p class="option">継承を行った後は、constructor を再設定しておくとよい。</p>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[インターフェイス指向設計 アジャイル手法によるオブジェクト指向設計の実践]]></title>
    <link href="http://hamasyou.com/blog/2008/07/05/4873113660/"/>
    <updated>2008-07-05T10:40:00+09:00</updated>
    <id>http://hamasyou.com/blog/2008/07/05/4873113660</id>
    <content type="html"><![CDATA[<p>本書は、プログラムにおけるインターフェース設計へアドバイスを与えるものです。GUIやデザインの話ではありません。高凝集度で疎結合な設計を行うためにインタフェース設計をどのように進めたらよいか、どのように考えてインターフェースを作れば良いかなどを説明しています。</p>

<p>システム開発というのは複雑な作業です。その複雑さを少しでも解消するために<strong>分割して統治せよ（Divide and Conquer）</strong>という理論を用いることが良いことだとされています。このときに大切になってくるのが「<strong>凝集度</strong>」と「<strong>結合度</strong>」になります。</p>

<p>凝集度は高いほど良い、つまり責任範囲が明確でが軸ぶれないほどよいです。結合度は低いほど、つまりそっちはそっちで勝手にやっててねとできるほどよいです。高凝集で低結合（英語で言うと「High Cohesion and Low Coupling!」）なプログラム部品にするために必要なのが「<strong>良いインターフェース</strong>」なのです。本書は、この良いインターフェースとは何か？どうやって良いインターフェースを設計するか？を解説するものです。</p>

<p>本書の対象読者は、プログラム経験があり設計に興味がある人、DI（Dependency Injection）って流行ってたけど未だに何が良いのかわからない人、テスト容易性が大事って聞くけどどうやって設計したらいいかわからない人です。</p>

<p>200ページくらいしかなく、かなり薄い本になっていますのでサクサク読めると思いますが、実はあまり詳しい説明というのが載っていません。内容が薄いのではなく、説明が薄いのです。「こんな場合こういう考えでインターフェースを切ると良いよ。作り方は二種類ある。長所はこれで、短所はこれ」みたいな説明が多いように思えました。</p>

<p>それでもかなりの良書の部類に入ると思います。さらっと読んで、良く理解できなかった部分は先輩に聞いたり、Webで質問したりして、自分なりに噛み砕いていく。そういう読み方をする本かなと思います。</p>

<!-- more -->




<h2>本書に出てくるキーワード</h2>




<h3>インターフェイスの三原則</h3>




<ol>
<li>インターフェイス実装は、そのメソッド名が示す通りの処理をしなければならない</li>
<li>インターフェイス実装は他に危害を加えてはならない</li>
<li>インターフェイス実装は、責務を果たせない場合にそれを呼び出し元に伝えねばならない</li>
</ol>


<p>つまり、「名前どおりの処理をし」、「後始末は自分でする、自分がエラーでも他に迷惑をかけない」、「自分で処理できないときは、呼び出し元に誤りをいれる」ということ。</p>

<h3>契約（Contract）、契約による設計（Design By Contract）</h3>


<p>インターフェイスの呼び出し元とインターフェイスとの間で交わされる約束のこと。事前条件、事後条件、不変表明の3つからなる。</p>

<p><strong>事前条件</strong>はインターフェイスの呼び出し元が守らなければならない条件で、事前条件を満たない状態でインターフェイスを呼び出すと正しく動作しない。</p>

<p><strong>事後条件</strong>はインターフェイスが守らなければならない条件で、事前条件を満たした状態で呼び出しが行われた場合に満たさなければならないもの。事後条件を満たせない場合は Java であれば例外をスローしたりする（原則3）</p>

<p><strong>不変表明</strong>はインターフェイスのインスタンスが満たさなければいけない内部状態を表すもの。</p>

<h3>データインターフェイスとサービスインターフェイス</h3>


<p>データインターフェイスとは、属性の設定や取得のメソッドで構成されるインターフェイスのこと。JavaBeans などが該当する。</p>

<p>サービスインターフェイスとは、処理を行うメソッドで構成されるインターフェイスのこと。よくある3階層アーキテクチャのサービス層を司るものや、GUIのボタン押下で呼び出されるメソッドなどを持つもの。</p>

<h3>エンティティ、バウンダリ、コントロール</h3>


<p><strong>エンティティ</strong>は、データインターフェイスに相当する。</p>

<p><strong>バウンダリ</strong>は、サービスインターフェイスに相当する。主に GUI やユーザインターフェイスとして動作する種類のサービスインターフェイス。</p>

<p><strong>コントロール</strong>も、サービスインターフェイスに相当する。主にビジネスロジックやビジネスルール、サービスを処理する種類のサービスインターフェイス。</p>

<h3>ステートフルインターフェイスとステートレスインターフェイス</h3>


<p>インターフェイスも状態を持つことができる。</p>

<p><strong>ステートフルインターフェイス</strong>は、メソッドの呼び出しに順序があり、呼び出し順で状態が変わるもの。</p>

<p><strong>ステートレスインターフェイス</strong>は、メソッドの呼び出しに順序がなく振る舞いが変わらないもの。</p>

<h3>凝集度</h3>


<p>責務の似具合のこと。共通のコンセプトに基づいたメソッドばかりで構成されたインターフェイスは凝集度が高いといえる。</p>

<h3>結合度</h3>


<p>相手がいないと動作できない具合のこと。相手のモジュールの処理に依存していない場合には結合度が低いといえる。</p>

<h3>継承とインターフェイス</h3>


<p>継承は機能の連鎖。is_a （である）や is_kind_of （の一種である） で表されることが多い。共通の処理や属性をまとめる際に使える。</p>

<p>インターフェイスはロールの連鎖。インターフェイスの継承は provides-a （提供する）で表されることが多い。</p>

<p>（適当に書いてみたけど、説明が難しいというか感覚的な感じなので、本書を読んでください。。。）</p>

<h3>手続き型インターフェイスとドキュメント型インターフェイス</h3>


<p>リモートインターフェイスとしてのインターフェイスを考える際の種類。</p>

<p><strong>手続き型インターフェイス</strong>は、メソッドの処理を定義するタイプのインターフェイス。CORBA や RMI なんかがそれ。</p>

<p><strong>ドキュメント型インターフェイス</strong>は、データメッセージをやり取りするタイプのインターフェイス。JSON や XML なんかがこれに当たる。</p>

<h2>感想</h2>


<p>良書だと思いました。ただし、インターフェイスってこういうものだっていう考えがある人が読まないと、頭が混乱してくる気がしました。それは、インターフェイスという言葉がいろいろな意味で使われているからです。Java のインターフェイスを表していることもあれば、相手とのやり取りそのものをインターフェイスといったり、メソッド定義もインターフェイス定義だよねというような、広い意味でインターフェイスといったりと。</p>

<p>インターフェイス設計の総おさらいのような感じで読むこともできるし、おお！こんな考え方があったのか！という新しい発見もあるしという感じです。</p>

<h3>本書には書いてなかった気がするもの</h3>




<h4>インターフェイスの定義は呼び出し元がするべし！</h4>


<p>これは私の持論（？）ですが、インターフェイスの定義というものは、使う側が指定するべきだと思っています。哲学とか入ってきてしまいますが、「自分が今ここにいるのは、他人がそう認識しているから」というイメージです。</p>

<p>「<a href="http://blog.goo.ne.jp/glass-_-onion/e/91d51585d966f1a005f957eacacc01de" rel="external nofollow">依存関係逆転の法則</a>」的な考え方ともいえると思います。</p>

<dl>
<dt class="tips">Tips</dt>
<dd>「<strong>インターフェイスが変わるときは、ユーザの要求が変わったときである。</strong>」</dd> 
</dl>




<h2>参考</h2>




<div class="rakuten">
<table  width="400" border="0" cellpadding="5"><tr><td colspan="2"><a href="http://www.amazon.co.jp/exec/obidos/ASIN/4797347783/sorehabooks-22/ref=nosim/" rel="external nofollow">G-Tools</a></font></td></tr></table>
</div>




<div class="rakuten">
<table width="400" border="0" cellpadding="5"><tr><td colspan="2"><a href="http://www.amazon.co.jp/exec/obidos/ASIN/4894712741/sorehabooks-22/ref=nosim/" rel="external nofollow">G-Tools</a></font></td></tr></table>
</div>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[オブジェクト指向入門 第2版 原則・コンセプト]]></title>
    <link href="http://hamasyou.com/blog/2007/07/16/4798111112/"/>
    <updated>2007-07-16T11:15:00+09:00</updated>
    <id>http://hamasyou.com/blog/2007/07/16/4798111112</id>
    <content type="html"><![CDATA[<p>元祖オブジェクト本の第2版です。原則・コンセプトで構成された本書と、方法論・実践で構成される別冊の二冊をあわせて『オブジェクト指向入門 完全版』になります。</p>

<p>本書は、オブジェクト技術の核となる4つのアイデア、<strong>構造化手法</strong>、<strong>信頼性の規律</strong>、<strong>認識論上の原則</strong>、<strong>分類の技法</strong>をソフトウェア工学からの立場で解説している言わばエンジニアリング本です。</p>

<p>結構小難しい言葉で書かれている部分があり、またページ数が多いため結構読むのが大変でした。その分本来のオブジェクト指向の考え方や良いプログラミングにつながる考え方が深くまで解説されていたりして、とても為になりました。</p>

<p>本書の対象読者は、オブジェクト指向技術に興味のある技術者や良い作法のプログラムを書きたいプログラマです。読むのは大変ですが損はない、むしろ読まないと損するくらいの本です。おすすめです。</p>

<!-- more -->




<h2>真のモジュール性</h2>


<p>プログラミングの世界でモジュールと言うと一連のサブルーチンのまとまりを指します。このモジュールを再利用し、モジュールの組み合わせでプログラムを組み立てるモジュール・プログラミングという考えがあります。再利用可能なモジュールは独立性が高く、異なるアーキテクチャに組み込んでも安定して稼動することが求められます。</p>

<p>モジュールに再利用可能という性質を組み込むための5つの基準（criteria）、5つの規則（rule）、5つの原則（principle）が存在します。そして、これらを満たしたものが<strong>クラス</strong>の基礎となります。</p>

<dl>
<dt class="tips">サブルーチンの内訳</dt> 
<dd>サブルーチンは結果として戻り値を返すものと返さないものの二種類に分けられます。戻り値を返すものを<strong>関数（function）</strong>と呼びます。戻り値を返さない手続きを<strong>プロシージャ（procedure）</strong>と呼びます。</dd> 
</dl>


<p></p>

<h3>5つの基準</h3>


<p>次の5つの基準を満たす設計手法は価値のあるモジュールを生み出す最低条件を満たします。</p>

<dl>
<dt>分解しやすさ</dt><dd>他システムへの依存性を低く抑えることができる</d>


<p><dt>組み合わせやすさ</dt><dd>異なる環境においても自由に組み合わせることができる</dd>
<dt>分かりやすさ</dt><dd>独立性が高く、他のモジュールの知識を必要としない</dd>
<dt>連続性</dt><dd>変更の局所化が行えている</dd>
<dt>保護性</dt><dd>モジュールの内部で発生したエラーの影響を閉じ込めることができる</dd>
</dl></p>

<table>
<caption>5つの基準の例</caption>
<tr><th>基準</th><th>例</th></tr>
<tr><td>分解しやすさ</td><td>分解しやすさを満たす設計手法の有名な例はトップダウン設計（サブシステム分割）</td></tr>
<tr><td>組み合わせやすさ</td><td>Unix の シェルコマンド（ls や more など）</td></tr>
<tr><td>分かりやすさ</td><td>悪い例として、順序に依存するような呼び出しを想定しているモジュールがある</td></tr>
<tr><td>連続性</td><td>シンボリック定数、動的配列</td></tr>
<tr><td>保護性</td><td>モジュールの入り口で他システムからの入力をチェックする</td></tr>
</table>


<p></p>

<h3>5つの規則</h3>


<p>5つの基準から、モジュール性を保障するための次の規則が導き出されます。</p>

<dl>
<dt>直接的な写像</dt><dd>解こうとしている問題領域のモデルとモジュールの構造が写像（マッピング）されている</dd>
<dt>少ないインターフェース</dt><dd>他のモジュールとの連携を行う際できる限り少ない数のモジュールとのやり取りで済ませる</dd>
<dt>小さいインターフェース</dt><dd>他のモジュールと通信する場合、最小限の情報のみをやり取りすること</dd>
<dt>明示的なインターフェース</dt><dd>他のモジュールと通信する場合、そのことがインターフェースから明らかに分かること</dd>
<dt>情報隠蔽</dt><dd>適切な情報のみを公開すること。不要な情報は隠蔽しておくこと</dd>
</dl>




<h3>5つの原則</h3>


<p>基準、規則から次の5つの原則が導かれる。</p>

<dl>
<dt>言語としてのモジュール単位</dt><dd>モジュールは言語の構文構造に対応していなければならない</dd>
<dt>自己文書化</dt><dd>モジュールについての情報をモジュールの一部として作成する</dd>
<dt>統一形式アクセス</dt><dd>統一された表記によってアクセスできなければならない</dd>
<dt>開放/閉鎖の原則（Open-Closed Principle）</dt><dd>拡張に対して開き、修正に対して閉じている</dd>
<dt>単一責任の原則（Single Responsibility Principle）</dt><dd>ひとつの役割だけをもつこと。変更の理由はただひとつでなければならない</dd>
</dl>




<h3>再利用</h3>


<p>再利用と一言で言っても、何を再利用するのか？ 何が再利用できるのか？ を考える必要があります。本書では次の7つの What への再利用の考えが述べられています。</p>

<ul>
<li>人材</li>
<li>仕様</li>
<li>設計</li>
<li>パターン</li>
<li>ソースコード</li>
<li>専用の部品</li>
<li>抽象化されたモジュール</li>
</ul>




<dl>
<dt class="info">車輪の再発明は悪なのか？</dt>
<dd>
<p>よく「車輪の再発明は悪」といわれますが「車輪」って何のことを指しているのでしょうか？ 本書で述べられている「仕様」のことなのか、「設計」のことなのかそれとも「ソースコード」のことなのか。</p>

<p>僕は「車輪」とは「仕様」のことだと理解しています。「走行抵抗を低くして対象に駆動力を与える」という「仕様」を再発明する必要はありません。でも、それを「車輪を円形で作成し、エンジンと連携させてコロコロ回るようにする」という設計や「空気によって地面に設置しなくても動く」という設計、設計を変えてつくることは全然良いことだと思っています。また、同じ円形の車輪でも「ゴムで作る」のと「木で作る」、実装を変えて作るのも全然良いことだと思います。</p></dd> 
</dl>




<h4>多重定義の役割</h4>


<p><blockquote><p>ルーチンの多重定義は顧客のための機能である。ある1つの概念を表す異なる実装を使うとき、顧客は1つの記述で済ませることができる。</p></p><p><p></p><footer><strong>P.120 第4章 再利用性へのアプローチ「多重定義の役割」より</strong></footer></blockquote></p>

<p>つまり、意味は同じだけど実装を隠蔽する場合に多重定義（<strong>オーバーロード</strong>）を使うということです。</p>

<h4>総称性の役割</h4>


<p><blockquote><p>総称性は供給者モジュールの作者のための機能である。ある特定の概念を表す1つの実装を異なる種類のオブジェクトに適用するときに、同じ供給者モジュールテキストを書くことが可能になる。</p></p><p><p></p><footer><strong>P.125 第4章 再利用性へのアプローチ「総称性の役割」より</strong></footer></blockquote></p>

<p>総称性（C++ のテンプレートや Java のジェネリクス）は開発者が楽するものという位置づけです。</p>

<h2>抽象データ型</h2>


<p><blockquote><p>抽象とは、物体についての認知可能な性質を、そのほかの性質から、あるいは、その性質が当てはまる物体から分離することにほかなりません。</p></p><p><p></p><footer><strong>P.157 第6章 抽象データ型より</strong></footer></blockquote></p>

<p>オブジェクトを抽象のまま扱うには、そのオブジェクトの概念に対する操作や概念の属性に注意を向けるようにします。操作がデータ構造を定義するものとして操作を定義すると良い抽象データ構造が定義できるようになります。</p>

<p>オブジェクト操作として考えなければならない概念として、モジュールの供給者（supplier）、モジュールの顧客（client）そしてプロトコル（契約）があります。モジュールはプロトコル（契約）を基本とした相互動作を行います。</p>

<h2>契約による設計（Design by Contract）</h2>


<p>すべてのモジュールにおいてお互いの権利と義務を明確に定義することで信頼性の高い大規模システムが実現できます。このような考えを「<strong>契約による設計（Design by Contract）</strong>」と言います。</p>

<p>契約による設計では表明（assertion）を使ってモジュールの仕様を表します。</p>

<dl>
<dt>事前条件</dt><dd>ルーチン（メソッド）が呼び出される時に顧客が満たされなければならない条件</dd>
<dt>事後条件</dt><dd>事前条件を満たした状態でルーチンが呼び出された場合に供給者が満たさなければならない条件</dd>
<dt>不変条件</dt><dd>ルーチン呼び出しによって変わらないオブジェクトの条件</dd>
</dl>




<h3>事前条件</h3>




<h4>事前条件はルーチンの顧客が満たす</h4>


<p>事前条件は、ルーチン（メソッド）の呼び出し側、つまり顧客（Client）が満たさなければならない条件です。呼び出し側はルーチンの事前条件を満たしているかどうかを確認してからルーチンを呼び出します。</p>

<h4>ルーチンの供給側は事前条件を確認できる操作を公開する</h4>


<p>ルーチンの供給側は顧客が事前条件を満たしているかどうかを判断できる操作を公開しなければなりません。公開されている操作で顧客が事前条件を確認できない場合には、事前条件がおかしいか公開している操作が足りません。</p>

<h4>事前条件は人間の入力、システム連携には使用しない</h4>


<p>契約はルーチン間（供給者と顧客）で取り交わすものです。<strong>ここでいう供給者と顧客とはソフトウェア同士のこと</strong>です。ソフトウェアと人間、ソフトウェアと外界の間には契約は成り立ちません。</p>

<p>人間や外界のシステムが相手の場合には入力検査の仕組みを導入しなければなりません。たとえば、入力チェックモジュールによるフィルタなどが考えられます。</p>

<h3>事後条件</h3>




<h4>事前条件が満たされない場合の事後条件は保証されない</h4>


<p>事前条件が満たされないでルーチンが呼び出された場合、ルーチンの事後条件は保証されません。つまり供給者側はそれをエラーにしても良いし、でたらめな値を返してもよいということです。</p>

<h4>事前条件が満たされたのに事後条件を満たせない場合</h4>


<p>事前条件が満たされているのに、事後条件が満たせない場合には、供給側は例外をスローします。</p>

<h3>表明違反の規則</h3>


<p><blockquote><p></p></p><p><ul><br/><li>実行時の表明違反は、そのソフトウェアにバグがある証拠である。</li><br/><li>事前条件違反は顧客側にバグがある証拠である。</li><br/><li>事後条件違反は供給側にバグがある証拠である。</li><br/></ul></p><p><br/><p></p><footer><strong>本書</strong></footer></blockquote></p>

<h2>参考</h2>




<div class="rakuten">
<table width="400"  border="0" cellpadding="5"><tr><td colspan="2"><a href="http://www.amazon.co.jp/exec/obidos/ASIN/4797323361/sorehabooks-22/ref=nosim/" rel="external nofollow">G-Tools</a></font></td></tr></table>
</div>




<div class="rakuten">
<table  border="0" cellpadding="5"><tr><td colspan="2"><a href="http://www.amazon.co.jp/exec/obidos/ASIN/4822282376/sorehabooks-22/ref=nosim/" rel="external nofollow">G-Tools</a></font></td></tr></table>
</div>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[たのしいRuby―Rubyではじめる気軽なプログラミング]]></title>
    <link href="http://hamasyou.com/blog/2006/04/27/4797314087/"/>
    <updated>2006-04-27T01:21:00+09:00</updated>
    <id>http://hamasyou.com/blog/2006/04/27/4797314087</id>
    <content type="html"><![CDATA[<p>Ruby をはじめるなら、この本からはじめるのをお勧めします。かなりわかりやすいです。わかりづらいだろうなという部分に関しては、ちゃんと詳しく説明がされているし、ちょっと気になるなということはコラムが別に用意されているという具合です。『<a href="http://www.amazon.co.jp/exec/obidos/ASIN/4274063852/sorehabooks-22/250-1891990-4739433?%5Fencoding=UTF8&camp=247&link%5Fcode=xm2" rel="external nofollow">Rubyプログラミング入門</a><img src="http://hamasyou.com/images/linkext.gif" alt="linkext" />』 より全然読みやすく理解しやすいです。</p>

<p>この本で Ruby の基本を抑えたら、あとはWeb上の Ruby リファレンスマニュアルで何とかなるのではないかと思います。</p>

<h4>参考</h4>


<ul>
<li><p><a href="http://www.ruby-lang.org/ja/man/?cmd=view;name=Ruby%A5%EA%A5%D5%A5%A1%A5%EC%A5%F3%A5%B9%A5%DE%A5%CB%A5%E5%A5%A2%A5%EB;navi=Ruby%A5%EA%A5%D5%A5%A1%A5%EC%A5%F3%A5%B9%A5%DE%A5%CB%A5%E5%A5%A2%A5%EB" rel="external nofollow">Ruby リファレンスマニュアル</a></p></li>
<li><p><a href="http://d.hatena.ne.jp/brazil/20050816/1124136877" rel="external nofollow">[翻訳]RubyについてJavaプログラマが知るべき10の事柄</a></p></li>
</ul>


<!-- more -->




<h2>Ruby 覚書 目次</h2>




<ul>
<li><a href="#chapter1" rel="external nofollow">基本文法</a>
</li>
<li><a href="#chapter2" rel="external nofollow">基本クラス</a>
</li>
<li><a href="#chapter3" rel="external nofollow">コマンドライン</a>
</li>
<li><a href="#chapter4" rel="external nofollow">変数</a>
<ul>
<li><a href="#section1" rel="external nofollow">組み込み変数</a></li>
</ul>
</li>
<li><a href="#chapter5" rel="external nofollow">メソッド</a>
<ul>
<li><a href="#section2" rel="external nofollow">組み込み関数</a></li>
</ul>
</li>
<li><a href="#chapter6" rel="external nofollow">クラス</a>
<ul>
<li><a href="#section3" rel="external nofollow">クラスメソッドの定義方法</a></li>
<li><a href="#section4" rel="external nofollow">既存のクラスにメソッドを追加する</a></li>
<li><a href="#section5" rel="external nofollow">クラスの継承</a></li>
<li><a href="#section6" rel="external nofollow">メソッドの公開修飾子</a></li>
</ul>
</li>
<li><a href="#chapter7" rel="external nofollow">モジュール</a>
<ul>
<li><a href="#section7" rel="external nofollow">Mix-in</a></li>
</ul>
</li>
<li><a href="#chapter8" rel="external nofollow">例外処理</a>
<ul>
<li><a href="#section8" rel="external nofollow">例外を発生させる</a></li>
<li><a href="#section9" rel="external nofollow">catch と throw</a></li>
</ul>
</li>
<li><a href="#chapter9" rel="external nofollow">数値クラス (Integer)</a>
</li>
<li><a href="#chapter10" rel="external nofollow">配列クラス (Array)</a>
</li>
<li><a href="#chapter11" rel="external nofollow">文字列クラス (String)</a>
</li>
<li><a href="#chapter12" rel="external nofollow">ハッシュクラス (Hash)</a>
</li>
<li><a href="#chapter13" rel="external nofollow">正規表現クラス (Regexp)</a>
</li>
<li><a href="#chapter14" rel="external nofollow">入出力クラス (I/O)</a>
</li>
<li><a href="#chapter15" rel="external nofollow">File クラスと Dir クラス</a></li>
</ul>




<h2 id="chapter1">基本文法</h2>


<p>「<code>&lsquo;</code>(シングルクウォート)」 で囲まれた文字列の中は、エスケープ 「<code>\</code>(バックスラッシュ)」 記法が使えない。</p>

<p><code>puts</code> メソッドは、行の終わりに改行コードが付与される。</p>

<p><code>p</code> メソッドは、オブジェクトの状態に合わせた表示を行う。</p>

<p>コメントの表記法には、「<code>#</code> (シャープ)」 と 「<code>=begin</code>」、「<code>=end</code>」 で囲む方法の2種類がある。</p>

<pre class="code"><code><span class="comment"># if - else 構文 </span>
<span class="keyword">if</span> 条件 
  処理 
<span class="keyword">elsif</span>  条件 
  処理 
<span class="keyword">else</span> 
  処理 
<span class="keyword">end</span> 
 
 
<span class="comment"># unless 構文 </span>
<span class="keyword">unless</span> 条件 
  処理 
<span class="keyword">end</span> 条件 
 
 
<span class="comment"># while 構文 </span>
<span class="keyword">while</span> 条件 
  処理 
<span class="keyword">end</span> 
 
 
<span class="comment"># times メソッド </span>
繰り返し回数.times { 
  処理 
} 
 
 
<span class="comment"># each メソッド </span>
オブジェクト.each {|n| 
  処理 
} 
 
 
<span class="comment"># case 構文 </span>
<span class="keyword">case</span> 比較したいオブジェクト 
<span class="keyword">when</span> 値1 
  処理 
<span class="keyword">when</span> 値2 
  処理 
<span class="keyword">when</span> 値3 
  処理 
<span class="keyword">else</span> 
  処理 
<span class="keyword">end</span> 
 
 
<span class="comment"># if 構文 の変形版 </span>
print <span class="literal">"a < b"</span> <span class="keyword">if</span> a < b 
 
 
<span class="comment"># for - in 構文 </span>
<span class="keyword">for</span> 変数 <span class="keyword">in</span> 開始値 .. 終了値 
  処理 
<span class="keyword">end</span> 
 
 
<span class="comment"># until 構文 </span>
<span class="keyword">until</span> 条件 
  処理 
<span class="keyword">end</span> 
 
 
<span class="comment"># loop 構文 (ひたすらループを行う) </span>
<span class="keyword">loop</span> { 
  処理 
} 
</code></pre>




<dl>
<dt class="tips">case 文の比較は ===</dt>
<dd>case 文の条件比較には 「 <code>===</code> 」 演算子が使われる。基本的には 「 <code>==</code> 」 と同じ意味だが、もう少しゆるい意味での一致を判断する。</dd>
</dl>




<dl>
<dt class="tips">Range オブジェクト</dt>
<dd><code>for in</code> 構文には Range オブジェクトが使える。<code>Range</code> オブジェクトは開始値と終了値を持つオブジェクトである。「 <code>..</code> 」 と 「 <code>...</code> 」 の違いは、「 <code>..</code> 」 は <code>array[n]</code> から <code>array[m]</code> までを繰り返すのに対し、「 <code>...</code> 」 は <code>array[n]</code> から <code>array[m-1]</code> までを繰り返す点。「 <code>..</code> 」 が使えるところならどこでも 「 <code>...</code> 」 が使える。<code>for in</code> 構文には、配列をとることもできる。</dd>
</dl>




<dl>
<dt class="tips">繰り返しの制御</dt>
<dd>繰り返し構文には、「 <code>break</code> (繰り返しを終了する)」、「 <code>next</code> (次の条件で繰り返しを行う continue )」、「 <code>redo</code> (同じ条件で繰り返しを行う)」 のキーワードが使える。</dd>
</dl>


<p>条件には、<code>true / false / nil</code> で判断できる条件を記述する。<code>false と nil</code> は 偽、それ以外は 真 として処理される。</p>

<dl>
<dt class="tips">Tips</dt>
<dd>数値の 0 も真として判定される。</dd>
</dl>




<h4>メソッド定義</h4>




<pre class="code"><code><span class="keyword">def</span> メソッド名(引数1, 引数2) 
  処理 
<span class="keyword">end</span> 
</code></pre>


<p>他のライブラリを取り込みたいときは 「 <code><span class="keyword">require</span></code> &quot;ライブラリファイル名&quot; 」 を使う。ライブラリファイル名には拡張子 「.rb」 は不要。</p>

<h3 id="chapter2">基本クラス</h3>


<p>配列を生成するときには 「 <code>[obj]</code> 」 を使う。</p>

<p>ハッシュを生成するときは 「 <code>{key =&gt; value}</code> 」 を使う。</p>

<p>ハッシュオブジェクトにアクセスするときには 「 <code>オブジェクト[key]</code> 」 で行う。</p>

<p>配列のサイズを取得するには 「<code>size</code> 」 メソッドを使う。</p>

<h4>ハッシュの each は、ブロック変数を2つとる</h4>




<pre class="code"><code>hash.each {|key, val| 
  処理 
<span class="keyword">end</span> 
</code></pre>


<p>Ruby では、正規表現は、「 <code><b>/パターン/ =~ &quot;文字列&quot;</b></code> 」 のように、パターンを左側に置くのが慣習になっている。</p>

<p>パターンマッチングの結果は、数値で返される。マッチングしなかった場合は 「 <code><span class="keyword">nil</code></span> 」 が返される。</p>

<h3 id="chapter3">コマンドライン</h3>


<p>コマンドライン引数は 「 <code><b>ARGV</b></code> 」 で受け取る。これは配列オブジェクトである。</p>

<p>オープンしたファイルハンドルの 「 <code>read</code> 」 メソッドは、内容をテキストとして返す。一行ずつ取り出したいときは 「 <code>gets</code> 」 を使う。</p>

<p>ruby を起動する際に、「 <code><b>-e &lsquo;command&rsquo;</b></code> 」 を指定すると、直接コマンドを実行する。</p>

<h3 id="chapter4">変数</h3>


<p>表記法によって変数の意味が変わる。</p>

<table>
<caption>変数の表記法</caption>
<tr><th>種類</th><th>表記法</th><th>例</th></tr>
<tr><td>ローカル変数</td><td>先頭がアルファベットの小文字か、「_ (アンダーバー)」で始まるもの</td><td> hoge, foo, _bar</td></tr>
<tr><td>グローバル変数</td><td>先頭が 「 <code>$</code> 」 で始まるもの</td><td>$global</td></tr>
<tr><td>インスタンス変数</td><td>先頭が 「 <code>@</code> 」 で始まるもの</td><td>@name, @age</td></tr>
<tr><td>クラス変数</td><td>先頭が 「 <code>@@</code> 」 で始まるもの</td><td>@@count</td></tr>
<tr><td>定数</td><td>先頭がアルファベットの大文字で始まるもの</td><td>Parameter, RUBY_VERSION</td></tr>
</table>


<p><br /></p>

<p>オブジェクトの同一性 (ID) を取得するには 「 <code>id</code> 」 メソッドを使う。ID で比較するには、「 <code>equal?</code> 」 メソッドを使う。値の比較を行うときは 「 <code>==</code> 」 演算子を使う。厳密な値の比較を行いたいときは 「 <code>eql?</code> 」 メソッドを使う。</p>

<dl>
<dt class="tips">変数の式展開</dt>
<dd>「 &quot; &quot; 」 で囲んだ文字列の中で変数を展開するには 「 <code><b>#{ }</b></code> 」 を使う。</dd>
</dl>




<dl>
<dt class="tips">Tips</dt>
<dd>Ruby では、演算子もクラスのメソッドとして定義されている。そのため、演算子のオーバーライドが可能である。</dd>
</dl>




<h4 id="section1">組み込み変数</h4>


<p>組み込み変数に関しては、<a href="http://www.ruby-lang.org/ja/man/?cmd=view;name=%C1%C8%A4%DF%B9%FE%A4%DF%CA%D1%BF%F4" rel="external nofollow">Rubyリファレンスマニュアル (組み込み変数)</a> を参照。</p>

<p>組み込み定数に関しては、<a href="http://www.ruby-lang.org/ja/man/?cmd=view;name=%C1%C8%A4%DF%B9%FE%A4%DF%C4%EA%BF%F4" rel="external nofollow">Rubyリファレンスマニュアル (組み込み定数)</a> を参照。</p>

<h3 id="chapter5">メソッド</h3>


<p>Ruby では、真偽値を返すメソッドには 「 <code><b>?</b></code> 」 を慣習としてつける。例： <code>obj.equal?</code></p>

<p>破壊的メソッドには 「 <code><b>!</b></code> 」 を慣習としてつける。 例： <code>&quot;&nbsp;&nbsp; 破壊的メソッド&nbsp;&nbsp; &quot;.chomp!</code></p>

<dl>
<dt class="tips">破壊的メソッド</dt>
<dd>メソッド名に 「 <code><b>!</b></code> 」 がついたメソッドを破壊的メソッドと呼ぶ。このメソッドは、自分自身の状態を変更する。</dd>
</dl>


<p>引数をとらないメソッドは、「 <code>()</code> 」 をつけないのが慣習らしい。</p>

<p>メソッドの引数にはデフォルト値を設定することができる。「 <code>引数名 = 値</code> 」 と記述する。</p>

<p>メソッドの戻り値には 「 <code><span class="keyword">return</b></code></span> 」 を使う。<code>return</code> を書かないときは、メソッドの最後に評価された値が戻り値になる。<code>return</code> の引数を省略すると <code>nil</code> を返すことになる。</p>

<p>メソッド引数に「*」をつけると、可変引数をまとめて配列として受け取ることが出来る。</p>

<h4>可変引数の例</h4>




<pre class="code"><code><span class="keyword">def</span> print_all(*args) 
    p args 
<span class="keyword">end</span>  
print_all(1, 2, 3, 4, 5) <span class="comment">#=> [1, 2, 3, 4, 5]</span>
</code></pre>




<h4 id="section2">組み込み関数</h4>


<p>組み込み関数に関しては <a href="http://www.ruby-lang.org/ja/man/?cmd=view;name=%C1%C8%A4%DF%B9%FE%A4%DF%B4%D8%BF%F4" rel="external nofollow">Rubyリファレンスマニュアル (組み込み関数)</a> を参照。</p>

<h3 id="chapter6">クラス</h3>


<p>インスタンスが何クラスのオブジェクトなのかを知るには 「 <code>class</code> 」 メソッドを使う。</p>

<p>インスタンスがクラスに属するかどうかを判定するには 「 <code>instance_of?</code> 」 メソッドを使う。</p>

<p>インスタンスがクラスに属するかどうかを、継承関係までさかのぼって判定するには 「 <code>is_a?</code> 」 メソッドを使う。</p>

<p>コンストラクタは 「 <code><b>initialize</b></code> 」 メソッド。</p>

<p>インスタンス変数のアクセサメソッドは、「 <code>attr_reader :属性</code> 」、「 <code>attr_writer :属性</code> 」、「 <code>attr_accessor :属性</code> 」 で定義する。</p>

<p>クラスの定数にアクセスするには 「 <code>クラス名::定数</code> 」 といった表記を使う。</p>

<h4>アクセサメソッドの定義例</h4>




<pre class="code"><code><span class="keyword">class</span> クラス名 
 
  attr_accessor :name 
  attr_reader :age 
 
  def initialize(引数)     <span class="comment"># コンストラクタ </span>
    @name = <span class="literal">"hamasyou"</span> 
    @age = 23 
  <span class="keyword">end</span> 
<span class="keyword">end</span> 
</code></pre>




<h4 id="section3">クラスメソッドの定義方法</h4>


<p>クラスメソッドの定義には3種類ある。「 <code>def クラス名.メソッド名 end</code> 」、「<code>class &lt;&lt; クラス名 def メソッド名 end end</code> 」、「<code>def self.メソッド名 end</code> 」。</p>

<h4>クラスメソッド定義方法</h4>




<pre class="code"><code><span class="comment"># 定義方法1 </span>
<span class="keyword">class</span> クラス名 
  <span class="keyword">def</span> クラス名.メソッド名 
    処理 
  <span class="keyword">end</span>  
<span class="keyword">end</span>  
 
 
<span class="comment"># 定義方法2 </span>
<span class="keyword">class</span> クラスB 
<span class="keyword">end</span> 
 
<span class="keyword">class</span> << クラスB 
  <span class="keyword">def</span> メソッド名 
    処理 
  <span class="keyword">end</span>  
<span class="keyword">end</span>  
 
 
<span class="comment"># 定義方法3 </span>
<span class="keyword">class</span> クラス名 
  <span class="keyword">def</span> <span class="keyword">self</span>.メソッド名 
    処理 
  <span class="keyword">end</span>  
<span class="keyword">end</span>  
</code></pre>




<h4 id="section4">既存のクラスにメソッドを追加する</h4>


<p>定義済みのクラスにメソッドを追加するには、同名のクラスを定義し、その中でメソッドを定義すればよい。</p>

<h4>既存のクラスの拡張</h4>




<pre class="code"><code><span class="keyword">class</span> String 
  <span class="keyword">def</span> len 
    <span class="keyword">return</span> <span class="keyword">self</span>.length 
  <span class="keyword">end</span>  
<span class="keyword">end</span>  
</code></pre>




<dl>
<dt class="tips">self 変数</dt>
<dd>メソッドの内部から自分自身を参照するには 「 <code><b>self</b></code> 」 変数を使う。</dd>
</dl>




<h4 id="section5">クラスの継承</h4>


<p>クラスの継承は 「 <code><b>class サブクラス &lt; スーパークラス end</b></code> 」 で行う。</p>

<dl>
<dt class="tips">super メソッド</dt>
<dd>メソッドの内部から 「 <code><b>super</b></code> 」 メソッドを呼び出すことで、スーパークラスの同名のメソッドを呼び出すことができる。</dd>
</dl>




<h4 id="section6">メソッドの公開修飾子</h4>


<p>「 <code><b>public</b></code> (インスタンスメソッドとして公開) 」、「 <code><b>protected</b></code> (クラスの内部と同一クラス (サブクラスを含む) 内からレシーバ経由で呼び出せる) 」、「 <code><b>private</b></code> (クラス内部からのみ呼び出せる) 」。</p>

<h4>公開修飾子の例</h4>




<pre class="code"><code><span class="keyword">class</span> クラス名 
  <span class="keyword">def</span> パブリックメソッドA 
    処理 
  <span class="keyword">end</span>  
  public :メソッドA 
 
  <span class="keyword">def</span> プライベートメソッドA 
    処理 
  <span class="keyword">end</span>  
  private :プライベートメソッドA 
 
  public  <span class="comment"># 引数を指定しない場合は、ここ以降が  public になる  </span>
 
  <span class="keyword">def</span> パブリックメソッドB 
    処理 
  <span class="keyword">end</span> 
<span class="keyword">end</span>  
</code></pre>




<dl>
<dt class="tips">レシーバとは</dt>
<dd>「 <code>オブジェクト.メソッド（引数）</code> 」 の形式で呼び出されるオブジェクトのことを、レシーバと呼ぶ。メソッド呼び出しのメッセージを受け取るものという意味。</dd>
</dl>




<h3 id="chapter7">モジュール</h3>


<p>モジュールは、クラスと違いインスタンス化することができない。モジュールは継承することができない。</p>

<p>モジュールは、名前空間を切る役割を持つ。「 <code><b>モジュール名::メソッド名</b></code> 」 といった形式でメソッドを呼び出すことになる。</p>

<p>「 <code><span class="keyword">include</b></code> モジュール名</span> 」 キーワードを使うと、モジュールを現在の名前空間に取り込むことができる。つまり、「 <code>メソッド名</code> 」で呼び出すことができるようになる。</p>

<h4 id="section7">Mix-in</h4>


<p>モジュールをクラスに取り込むことを Mix-in と呼ぶ。クラス定義の中で 「 <code>include</code> 」 を行うことでクラスにモジュールで定義されているメソッドや定数を取り込むことができる。</p>

<h4>モジュールの作成例</h4>




<pre class="code"><code><span class="keyword">module</span> モジュール名 
  <span class="keyword">def</span> モジュールメソッドA 
    処理 
  <span class="keyword">end</span>  
 
 
  <span class="comment"># モジュールメソッドとして公開する </span>
  module_function :モジュールメソッドA
<span class="keyword">end</span>
</code></pre>




<dl>
<dt class="notice">module_function として公開しなければ使えない</dt>
<dd>モジュールで定義したメソッドは、「 <code>module_function</code> 」 キーワードを使って公開しなければ、「 <code>モジュール名::メソッド名</code> 」 の形で呼び出すことができない。「 <code>module_function</code> 」 がされていないメソッドは、同一モジュール内か、「 <code>include</code> 」 で取り込まれたときしか呼び出すことができない。</dd>
</dl>




<h3 id="chapter8">例外処理</h3>




<h4>例外処理構文</h4>




<pre class="code"><code><span class="keyword">begin</span> 
  <span class="comment"># 例外が起きる可能性のある処理 </span>
<span class="keyword">rescue</span> 例外クラスA => 変数 
  <span class="comment"># 例外クラスAが起きたときの処理 </span>
<span class="keyword">rescue</span> => 変数 
  <span class="comment"># その他の例外が起きたときの処理 </span>
<span class="keyword">ensure</span> 
  <span class="comment"># 例外が起きる起きない関わらず </span>
  <span class="comment"># 絶対に呼び出される処理 </span>
<span class="keyword">end</span>  
</code></pre>




<dl>
<dt class="tips">処理をやり直す</dt>
<dd>「 <code>rescue</code> 」 で例外を捕捉した場合、「 <code><b>retry</b></code> 」 キーワードを使うことで 「 <code>begin</code> 」 から処理をやり直しすることができる。</dd>
</dl>




<h4 id="section8">例外を発生させる</h4>


<p>「 <code><span class="keyword">raise</b></code> メッセージ</span> 」 か 「 <code><span class="keyword">raise</b></code> 例外クラス [, メッセージ]</span> 」 で例外を発生させることができる。</p>

<dl>
<dt class="tips">rescue 節の中で raise すると</dt>
<dd>rescue 節 の中で 「 <code>raise</code> 」 を単独で呼び出すと、最後に発生した例外 (<b>$!</b>) を再スローすることができる。</dd>
</dl>




<dl>
<dt class="info">$! と $@</dt>
<dd>「 <code><b>$!</b></code> 」 は最後に起こった例外を表す。「 <code><b>$@</b></code> 」 は例外が起こった場所に関する情報を表す。</dd>
</dl>




<h4 id="section9">catch と throw</h4>


<p>Ruby における 「 <code><span class="keyword">catch</b></code> と <span class="keyword">throw</span></span> 」 は <code>goto</code> 文として使うことができる。「 <code>catch</code> 」 の引数に指定したシンボルが、catch 節中でスローされたら、catch 節を抜け出すことができます。</p>

<h4>catch - throw の例</h4>




<pre class="code"><code>catch (:exit) 
  <span class="keyword">if</span> a == 10 
    <span class="keyword">if</span> b == 20 
      <span class="keyword">if</span> c == 30 
        throw :exit, <span class="literal">"catch の戻り値になる"</span> 
      <span class="keyword">end</span>  
    <span class="keyword">end</span>  
  <span class="keyword">end</span>  
<span class="keyword">end</span>  
</code></pre>


<p><blockquote><p><strong>シンボルとは</strong>、Ruby が内部でメソッド名などの識別に使っている数値で、任意の文字列に対して異なった値が割り当てられます。メソッド名の先頭に 「:」 をつけることで、対応するシンボルオブジェクトを得ることができます。</p></p><p><p></p><footer><strong>『たのしいRuby』 P.125</strong></footer></blockquote></p>

<h3 id="chapter9">数値クラス (Integer)</h3>




<pre>
x.divmod(y)
x を y で割ったときの商とあまりを配列にして返す。
 
x.remainder(y)
x を y で割ったときの余りを返す。符号は、x の符号に一致する。
 
obj.to_xxx
obj を 別の型に変換する。
to_i は Integer 型、to_f は Float 型にそれぞれ変換する。
 
n.times {|i| ...}
n 回の繰り返しを行う。i には 0 .. n-1 の値が渡される。
 
from.upto(to) {|i| ...}
from から to に達するまで i を加算しながら繰り返す。
 
from.down(to) {|i| ...}
from から to に達するまで i を減算しながら繰り返す。
 
from.step(to, step) {|i| ...}
from から to に達するまで step を加算しながら繰り返す。
</pre>




<h3 id="chapter10">配列クラス (Array)</h3>




<pre>
%w(あ か さ た な)
#=&gt; [&quot;あ&quot;, &quot;か&quot;, &quot;さ&quot;, &quot;た&quot;, &quot;な&quot;]
 
&quot;あ か さ た な&quot;.split()
#=&gt; [&quot;あ&quot;, &quot;か&quot;, &quot;さ&quot;, &quot;た&quot;, &quot;な&quot;]
 
[&quot;あ&quot;, &quot;か&quot;, &quot;さ&quot;, &quot;た&quot;, &quot;な&quot; ][1 .. 3]
#=&gt; [&quot;か&quot;, &quot;さ&quot;, &quot;た&quot;]
 
[&quot;あ&quot;, &quot;か&quot;, &quot;さ&quot;, &quot;た&quot;, &quot;な&quot; ][1 ... 3]
#=&gt; [&quot;か&quot;, &quot;さ&quot;]
 
[&quot;あ&quot;, &quot;か&quot;, &quot;さ&quot;, &quot;た&quot;, &quot;な&quot; ][1, 3]
#=&gt; [&quot;か&quot;, &quot;さ&quot;, &quot;た&quot;]
 
array.slice(n .. m)
array 配列の n 番目から m 番目 までの配列を返す。
array[n .. m] と同じ処理。
 
array.slice(n, len)
array 配列の n 番目から len 要素分 の配列を返す。
arrray[n, m] と同じ処理。
 
array.value_at(n1, n2, ...)
array 配列の n1 番要素 n2 番要素 ... を集めた配列を返す。
[&quot;あ&quot;, &quot;か&quot;, &quot;さ&quot;, &quot;た&quot;, &quot;な&quot; ].value_at(0, 1, 3)
#=&gt; [&quot;あ&quot;, &quot;さ&quot;, &quot;な&quot;]
 
array.unshift(obj)
配列の先頭に obj を追加する。
 
array.shift()
配列の先頭から要素を一つ取り出し返す。配列は詰められる。
 
array.push(obj)
obj を配列の末尾に追加する。
 
array.pop()
配列の末尾の要素を一つ取り出し返す。配列からはなくなる。
 
array.uniq()
array.uniq!()
配列中の重複する要素を削除した配列を返す。
 
array.collect {|item| ...}
array.collect! {|item| ...}
配列の各要素をブロックで評価した値と入れ替える。
要素の数は変わらない。
 
array.reverse()
array.reverse!()
配列の要素を逆順に並び替える。
 
array.sort()
array.sort!()
array.sort {|a, b| ...}
array.sort! {|a, b| ...}
配列の要素を並び替える。
並び替えの方法を指定する場合はブロックを伴う方を使う。
 
array.each {|item| ...}
array.each_with_index {|item, i| ...}
配列の要素をイテレーションする。
each_with_index は、配列のインデックスがブロックに渡される。
 
array.reject {|item| ...}
array.reject! {|item| ...}
要素を評価した結果が真になったものを除いた配列を作る。
</pre>




<h3 id="chapter11">文字列クラス (String)</h3>


<p>「 <code>&quot;</code> 」 で囲まれた文字列中で 「 <code><b>#{ }</b></code> 」 を使うと、変数を展開できる。</p>

<p>「 <code>%Q</code>、 <code>%q</code> 」 を使うと、「 &quot; 」 と 「 &lsquo; 」 の代わりになる。「 <code>%Q</code> 」 が 「 &quot; 」 の代わりで、「 <code>%q</code> 」 が 「 &rsquo; 」 の代わりになる。</p>

<p>ヒアドキュメントも使える。</p>

<pre>
%Q, %q
%Q| 「" "」 や 「' '」の代わりに使える\n |
%q{ 区切り文字には何でも使えるみたい }
 
sprintf(format, arg, ...)
printf と同じ処理を行うが、画面表示ではなく、文字列を作る。
 
str.size
str.length
文字列のバイト数を返す。長さではないので注意すること。
 
str.chop
str.chop!
str.chomp
str.chomp!
chop は文字列の最後の一文字を切り捨てる。
chomp は文字列の最後に改行があれば切り捨てる。
 
str.index(&quot;abc&quot;)
str.rindex(&quot;abc&quot;)
文字列が最初に現れるインデックスを返す。
rindex は後ろから調べる。
 
str.include?(&quot;abc&quot;)
文字列が含まれているかどうかを返す。
 
str.sub(pattern, replace)
str.sub(pattern) {|matched| ...}
str.sub!(pattern, replace)
str.sub!(pattern) {|matched| ...}
str.gsub(pattern, replace)
str.gsub(pattern) {|matched| ...}
str.gsub!(pattern, replace)
str.gsub!(pattern) {|matched| ...}
sub は最初にパターンにマッチした部分を置き換える。
ブロックを伴う場合はブロックの戻り値で置き換える。
gsub はパターンにマッチした部分すべてを置き換える。
 
str.upcase
str.upcase!
str.downcase
str.downcase!
str.swapcase
str.swapcase!
str.capitalize
str.capitalize!
メソッドの名の通り。
</pre>




<dl>
<dt class="tips">日本語の文字列の長さを調べる</dt>
<dd>正規表現を使うと日本語も正しく文字数を調べられる。

<ul>
<li>'オブジェクト指向スクリプト言語Ruby'.split(//e).length # 文字コードが EUC-JP の場合</li>
<li>'オブジェクト指向スクリプト言語Ruby'.split(//s).length # 文字コードが Shift_JIS の場合</li>
</ul>
</dd>
</dl>




<h3 id="chapter12">ハッシュクラス (Hash)</h3>


<p>ハッシュを作るには 「 <code>{ }</code> 」 を使う。「 <code>key =&gt; value</code> 」 の形で要素を作る。</p>

<pre>
hash.keys
hash.each_key {|key| ...}
キーを返す。
 
hash.values
hash.each_value {|value| ...}
値を返す。
 
hash.each {|key, value| ...}
キーと値をペアで返す。
 
hash.has_key?(key)
hash.has_value?(val)
has_key? はハッシュがキーを持っているかを判定する。
has_value? はハッシュが値を持っているかを判定する。
 
hash.size
ハッシュのキーの数を返す
</pre>




<h3 id="chapter13">正規表現クラス (Regexp)</h3>


<p>パターンマッチングは、「 <code><b>/pattern/ =~ 文字列</b></code> 」 の形で行うことができる。マッチしたときは、その位置を返す。マッチしなければ 「 <code>nil</code> 」 を返す。</p>

<p>「 <code>^</code> や <code>$</code> 」 は、行頭や行末にマッチする。ただし、「 <code>&quot;abc\nhoge&quot;</code> 」 のように、文字列の途中に改行がある場合に 「 <code>^</code> 」 を使うと <code>abc と hoge</code> にマッチすることになる。</p>

<p>文字列の先頭、末尾にマッチングさせたいときには 「 <code><b>\A</b></code> と <code><b>\Z</b></code> 」 を使う。<code>\A</code> は文字の先頭に、<code>\Z</code> は文字の末尾にそれぞれマッチする。</p>

<dl>
<dt class="tips">%r の使い方</dt>
<dd><b>%r</b> を使うと、パターン中で 「 / 」 を使いたいときに便利。例： 「 <code>%r{this is a pattern} や %r|this is a pattern|</code> 」</dd>
</dl>


<p>正規表現の詳しい表記法に関しては <a href="http://www.ruby-lang.org/ja/man/?cmd=view;name=%C0%B5%B5%AC%C9%BD%B8%BD" rel="external nofollow">Rubyリファレンスマニュアル (正規表現)</a> を参考にすること。</p>

<h3 id="chapter14">入出力クラス (I/O)</h3>


<p>標準入力(STDIN) と標準出力(STDOUT) は、バッファリングされる。標準エラー出力(STDERR) はバッファリングされずにすぐにフラッシュされる。</p>

<p>それぞれ、<code>$stdin、$stdout、$stderr</code> のグローバル変数か、<code>STDIN、STDOUT、STDERR</code> の組み込み定数で参照できる。</p>

<pre>
File.open(filename, &quot;r|r+|w|w+|a|a+|b&quot;) {|f| ...}
 　ファイルを開く。ブロックを抜けるとファイルが閉じられる。
 
io.readlines
I/O オブジェクトの各行を配列にして返す。一気に読み出す。
 
io.each {|line| ...}
I/O オブジェクトをイテレーションする。
 
io.lineno
現在の読み込み行数を返す。
 
io.gets
io.puts
文字列の最後に改行コードをつけて読み込む / 書き込む。
 
io.getc
io.putc
文字列を1バイト読み込む / 書き込む。
 
io.printf(format, arg1, arg2)
フォーマットして I/O オブジェクトに出力する。
 
io.write(str)
文字列を書き込む。
 
io.flush
出力バッファをフラッシュする。
</pre>




<h3 id="chapter15">File クラスと Dir クラス</h3>


<p>ファイルを表すのが 「 <code>File</code> 」 クラス。ディレクトリを表すのが 「 <code>Dir</code> 」 クラス。</p>

<dl>
<dt class="tips">File クラスの拡張</dt>
<dd>ファイルクラスに 「 <code>copy や move</code> 」 といったメソッドを拡張するためには、「 <code>require &quot;ftools&quot;</code> 」 を行う。</dd>
</dl>




<dl>
<dt class="tips">Find モジュール</dt>
<dd>「 <code>require &quot;find&quot;</code> 」 で取り込まれる <code><b>Find</b></code> モジュールを使うと、ファイルの検索等ができるようになる。

<pre class="code"><code>require <span class="literal">"find"</span> 
Fild::find(dir) {|path| ...} 
</code></pre>
</dd>
</dl>




<dl>
<dt class="tips">Tempfile クラス</dt>
<dd>「 <code>require &quot;tmpfile&quot;</code> 」 で使えるようになる <code><b>Tempfile</b></code> クラスは、テンポラリファイルを扱うクラス。<code>new</code> で作成したテンポラリファイルは、<code>close</code> が行われると削除される。ただし、実際に削除されるのは GC(ガーベージコレクション) が発生したとき。<code>close(true)</code> を行うことですぐに削除することもできる。</dd>
</dl>




<pre>
File.rename(before, after)
ファイル名を変更するクラスメソッド。
 
File.delete(filename)
ファイルを削除するクラスメソッド。
 
File.basename(path [, suffix])
パスの最後の &quot;/&quot; 以降を返すクラスメソッド。
suffix を与えると、その部分を取り除いて返す。
File.basename('/home/ruby.rb', '.rb')  #=&gt; ruby
 
File.dirname(path)
ディレクトリのパスを返すクラスメソッド。
File.dirname('/usr/bin/ruby')  #=&gt; /usr/bin
 
File.split(path)
パスをディレクトリとファイルに分けて配列で返すクラスメソッド。
カレントのファイルパスを与えると、ディレクトリは &quot.&quot; になる。
File.split('/home/hamasyou/ruby.rb')  
    #=&gt; ['/usr/hamasyou', 'ruby.rb']
 
Dir.pwd
現在のディレクトリを返すクラスメソッド。
 
Dir.chdir(path)
現在のディレクトリを変更するクラスメソッド。
 
Dir.glob(filename)
filename にマッチするファイル名を返すクラスメソッド。
filename にワイルドカードが使える。
&quot;*&quot; 全ファイルにマッチ
&quot;*/*.html&quot; サブディレクトリの .html ファイルにマッチ
&quot; **/*.html&quot; カレントディレクトリ以下の .html ファイルにマッチ
 
Dir.mkdir(dirname)
ディレクトリを作成するクラスメソッド。
 
Dir.rmdir(dirname)
ディレクトリを削除するクラスメソッド。
削除するディレクトリは中身が空でないといけない。
 
dir.each {|f| ...}
開いているディレクトリに含まれるコンテンツを返す。
カレントディレクトリ(.)、親ディレクトリ(..)、
その他ディレクトリ、ファイルが返される。
 
=== ftools を require すると使えるメソッド ===
File.copy(from, to)
ファイルをコピーする。
 
File.move(from, to)
ファイルを移動する。
 
File.compare(from, to)
ファイルを比較する。
 
File.makedirs(path)
深いディレクトリも再帰的に作成する。
</pre>




<h2>参考</h2>


<ul>
<li>たのしいRuby を読み終わったらコレ！</li>
</ul>


<div class="rakuten">
<table width="400" border="0" cellpadding="5"><tr><td colspan="2"><a href="http://www.amazon.co.jp/exec/obidos/ASIN/4797324295/sorehabooks-22/" rel="external nofollow">G-Tools</a></font></td></tr></table>
</div>


<ul>
<li>達人プログラマによるRuby解説本</li>
</ul>


<div class="rakuten">
<table width="400"  border="0" cellpadding="5"><tr><td colspan="2"><a href="http://www.amazon.co.jp/exec/obidos/ASIN/4894714531/sorehabooks-22/" rel="external nofollow">G-Tools</a></font></td></tr></table>
</div>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[オブジェクト指向でなぜつくるのか―知っておきたいプログラミング、UML、設計の基礎知識―]]></title>
    <link href="http://hamasyou.com/blog/2005/11/03/4822281957/"/>
    <updated>2005-11-03T20:04:00+09:00</updated>
    <id>http://hamasyou.com/blog/2005/11/03/4822281957</id>
    <content type="html"><![CDATA[<p>『なぜシリーズ』の第5弾となるオブジェクト指向に関する書籍です。「<strong>オブジェクト指向</strong>」というキーワードは一時期Buzzwordでした。それは、オブジェクト指向を<strong>プログラミングの道具</strong>として説明したり、<strong>概念</strong>だけを説明したり、<strong>UMLを使った設計技法</strong>のことを指して説明していたりと、知らない人が聞いたら混乱してしまうような説明しかされていなかったためです。</p>

<p><blockquote><p>実際には「オブジェクト指向が現実世界をそのままソフトウエアに表現する技術である」という説明は間違いです。</p></p><p><p></p><footer><strong>本書</strong></footer></blockquote></p>

<p>この説明が示すように、オブジェクト指向を本当に理解し、使いこなすには、オブジェクト指向に関する誤解を解く必要があると思います。本書はその手助けをしてくれる、正真正銘、本物のオブジェクト指向入門書です。</p>

<p>オブジェクト指向のキーワードに惑わされて疲れてしまった人、オブジェクト指向って難しそうだから敬遠していた人、オブジェクト指向を理解してみたい人、おすすめの一冊です。</p>

<!-- more -->




<h2>特長</h2>




<h3>オブジェクト指向の概念</h3>


<p>オブジェクト指向を理解するには、まず2つのことを理解しなければなりません。</p>

<ol><li><strong>オブジェクト指向が現実世界をそのまま映し出すのは間違い</strong></li><li><strong>オブジェクト指向はソフトウェア開発を楽にするためのもの</strong></li></ol>


<p>まずは、オブジェクト指向の間違った理解や誤解を解き放つことから始まります。これまでは、混乱し、間違った理解のまま進んでしまったため、いまいちオブジェクト指向が分からなかったのだと思います。本書では、すっきり分かりやすくオブジェクト指向の概念を説明します。</p>

<h3>プログラミング技術としてのオブジェクト指向</h3>


<p>カプセル化、ポリモーフィズム、継承のオブジェクト指向プログラミング（OOP）の三大要素を理解します。プログラミング言語に依存しない理解をすることで、どんなオブジェクト指向言語を使うときにも役に立つはずです。</p>

<h3>応用技術としてのオブジェクト指向</h3>


<p>プログラミング技術からスタートしたオブジェクト指向ですが、現在ではUMLや開発プロセスと言ったところにまで発展してきています。オブジェクト指向というキーワードを本当に理解するためには、OOPだけではなく応用技術でどのようにオブジェクト指向が語られているかを理解する必要があります。</p>

<h2>参考</h2>


<ul>
<li>言語はC++。だけどOOPを学ぶためには最高の一冊。</li>
</ul>


<div class="rakuten"><table width="400"  border="0" cellpadding="5"><tr><td colspan="2" ><a href="http://www.amazon.co.jp/exec/obidos/ASIN/4881356194/sorehabooks-22/" rel="external nofollow">G-Tools</a></font></td></tr></table></div>


<ul>
<li>オブジェクト指向開発の奥義、教えます。</li>
</ul>


<div class="rakuten"><table  width="400" border="0" cellpadding="5"><tr><td colspan="2" ><a href="http://www.amazon.co.jp/exec/obidos/ASIN/4797323361/sorehabooks-22/" rel="external nofollow">G-Tools</a></font></td></tr></table></div>


<ul>
<li>オブジェクト指向の神髄。すべてがここに詰まっています。現場向き</li>
</ul>


<div class="rakuten"><table  width="400" border="0" cellpadding="5"><tr><td colspan="2" ><a href="http://www.amazon.co.jp/exec/obidos/ASIN/4822282376/sorehabooks-22/" rel="external nofollow">G-Tools</a></font></td></tr></table></div>



]]></content>
  </entry>
  
</feed>
