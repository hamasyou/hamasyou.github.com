<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: プログラミング言語 | それはBooks]]></title>
  <link href="http://hamasyou.com/blog/tags/puroguraminguyan-yu/atom.xml" rel="self"/>
  <link href="http://hamasyou.com/"/>
  <updated>2014-06-27T00:04:15+09:00</updated>
  <id>http://hamasyou.com/</id>
  <author>
    <name><![CDATA[hamasyou]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Apple Swift プログラミング言語おぼえがき]]></title>
    <link href="http://hamasyou.com/blog/2014/06/26/apple-swift/"/>
    <updated>2014-06-26T08:00:55+09:00</updated>
    <id>http://hamasyou.com/blog/2014/06/26/apple-swift</id>
    <content type="html"><![CDATA[<p>Apple が新しいプログラミング言語 <strong>Swift</strong> を2014年の WWDC で発表しました。言語仕様自体は色々なモダンプログラミング言語のいいとこ取りのような感じです。独特な仕様もいくつかあるのでおぼえがきしておきます。</p>

<p>なお、Swift で作成したアプリは iOS8 と OS X Yosemite がリリースされた時点で審査に入れるようです。</p>

<p><a href="https://developer.apple.com/swift/">Introducing Swift</a></p>

<!-- more -->




<div id="toc"></div>


<h2>The Basics</h2>

<p><code>NSLog</code> の代わりに <code>println</code> が使える。Xcode のコンソールにも表示される。文字列の変数展開は <code>\()</code> を使う。</p>

<pre><code class="swift">let name = "hamasyou"
println("Hello \(name)")  // Hello hamasyou
</code></pre>

<h3>基本型</h3>

<p><code>Int</code>、<code>Double</code>、<code>Float</code>、<code>Bool</code>、<code>String</code>、<code>Array</code>、<code>Dictionary</code> などが用意されている。<code>Int16</code> や <code>UInt8</code> などもある。型の変換は <code>型名()</code> を使う。</p>

<p>Swift では <code>nil</code> を特別な値として定義している。<code>Bool</code> 値は <code>true</code> と <code>false</code>。条件式では <code>Bool</code> 値のみが使える。</p>

<pre><code class="swift">UInt8.max   // 255
UInt8.min   // 0

let three = 3
let floatValue = 0.14159
let pi = Double(three) + floatValue // 3.14159
let integerPi = Int(pi) // 3

if pi {
    // この文法はコンパイルエラーになる。正しくは↓
}

if pi == 3.14159 {
}
</code></pre>

<p>タプルも使える。不要な値を受け取るときは <code>_</code> を使う。</p>

<pre><code class="swift">let httpError = (404, "Not Found")
httpError.0   // 404
httpError.1   // "Not Found"

let otherError = (errorCode: 500, errorMessage: "Internal Server Error")
otherError.errorCode    // 500
otherError.errorMessage // "Internal Server Error"

let (code, msg) = httpError
code  // 404
msg   // "Not Found"

let (_, msg2) = otherError
msg2  // "Internal Server Error"
</code></pre>

<h3>リテラルと変数</h3>

<p>Swift ではリテラルの定義は <code>let</code> を使い、変数の定義は <code>var</code> を使う。<code>let</code> で定義したリテラルは変更できない。</p>

<pre><code class="swift">let myName = "hamasyou"
let π = 3.14
var x = 0.0, y = 0.0, z = 0.0
x = 3.0
</code></pre>

<p>文字列を数値に直すのに <code>toInt</code> メソッドが使える。この時返される値は <code>Int</code> 型でなく、<code>Int?</code> 型なので注意。</p>

<pre><code class="swift">let str = "123"
let num = str.toInt()   // num は Int? か Optional Int として型推論される
</code></pre>

<p>if 文の条件式には <code>Bool</code> しか記述できないが、この、<code>型 + ?</code> の形式で表される <code>Optional 型</code> も if 文の式に記述できる。この場合値が nil ではない場合に <code>true</code> と評価される。</p>

<pre><code class="swift">var str = "123"
var num = str.toInt()

if num {
    println("\(str) is number of \(num!)")
}
</code></pre>

<p>このように、Swift では <code>nil</code> を返す可能性があるメソッドの戻り値の型は <code>Optional 型</code> になる。<code>Optional 型</code> から値を取り出すには <code>!</code> をつける。但し、nil が入っている変数から値を取り出そうとするとランタイムエラーになる。</p>

<pre><code class="swift">str = "abc"
num = str.toInt()

println(num!)   // これはランタイムエラーになるので、必ず下の様に呼び出す

if !num {
    println("\(str) is not number")
}
</code></pre>

<p>Optional 型から値を取り出す方法に、<code>!</code> をつける以外に次のようにも書ける。（Optional Binding）</p>

<pre><code class="swift">let str = "123"
let expectNum = str.toInt()
if let actual = expectNum {
    println(actual)
}
</code></pre>

<h3>Implicity Unwrapped Optionals</h3>

<p>Swift は Objective-C の nil ポインタとは違う <code>nil</code> を採用している。nil が格納される可能性がある変数は Optional 型として定義する必要がある。</p>

<p>Optional 型の変数から値を取り出すには <code>!</code> を使う。必ず値が入っている確証が持てる場合は <code>型名 + !</code> の形で記述することもできる。値が入っていない時に <code>!</code> を使うとランタイムエラーがでるので注意。</p>

<pre><code class="swift">var optioanValue: Int?   // Optional 型の変数は nil で初期化される

let str = "123"
let num: Int! = str.toInt()
num   // num は 123 が入る Int! で定義しない場合は型推論によって Int? 型の Wrapped Value が入っているので 123 ではない
</code></pre>

<h3>Range</h3>

<p><code>(a..b)</code>、<code>(a...b)</code> の形で範囲を求めることができる。<code>(a..b)</code> は b を含まない。Ruby とは逆の動きをする。。。</p>

<pre><code class="swift">for i in (0..3) {
    println(i)    // 0, 1, 2
}
</code></pre>

<h2>String And Character</h2>

<p><code>String</code> は <code>NSString</code> が使われているところでも使える。String は <code>Character</code> のコレクション型である。</p>

<pre><code class="swift">let str = "Hello World"
let c: Character = "!"

let s = str + c

str.isEmpty             // false
str.hasPrefix("Hello")  // true
str.hasSuffix("World")  // true
</code></pre>

<h2>Collection Types</h2>

<h3>Array</h3>

<p>Swift の配列は <code>Array</code> 型。<code>Array&lt;SomeType&gt;</code> で表す。略語として <code>型名[]</code> の形式も使える。<code>NSArray</code>、<code>NSMutableArray</code> が使われているところでも使える。</p>

<pre><code class="swift">var list = ["Hello", "World", "Good"]
list.count
list += "Nice"      // ["Hello", "World", "Good", "Nice"]
list.removeLast()   // "Nice"

var stringList: String[]?             // nil
var anyList: Array&lt;AnyObject&gt;?        // nil
var stringList2: Array&lt;String&gt; = []   // empty String array
</code></pre>

<h3>Dictionary</h3>

<p>Swift の Hash は <code>Dictionary</code> 型。<code>Dictionary&lt;KeyType, ValueType&gt;</code> で定義する。<code>NSDictionary</code>、<code>NSMutableDictionary</code> が使われているところでも使える。</p>

<pre><code class="swift">var airports = ["TYO": "Tokyo", "DUB": "Dublin"]
// var airports: Dictionary&lt;String, String&gt; = ["TYO": "Tokyo", "DUB": "Dublin"] とも書ける
airports.count
airports["OSK"] = "OSAKA"
airports["HOGE"]    // nil
airports.keys       // ["TYO", "DUB", "OSK"]
airports.values

for (code, name) in airports {
}

var dict: Dictionary&lt;String, String&gt;?             // nil
var emptyDict = Dictionary&lt;String, String&gt;()      // empty Dictionary 
var emptyDict2: Dictionary&lt;String, String&gt; = [:]  // empty Dictionary
</code></pre>

<h2>Functions</h2>

<p>関数は <code>func メソッド名(引数: 型) -&gt; 戻り値の型</code> の形で書く。戻り値が必要ない場合は省略するか、<code>Void</code> を記述する。</p>

<p>Swift の関数（メソッド）は <em>第一級関数</em> なので、変数や引数に渡すことができる。</p>

<pre><code class="swift">func hello(name: String, greet: String) -&gt; String {
    return "Hello \(name), \(greet)"
} 
println(hello("hamasyou", "Good Morning"))

func sayHello(name: String) -&gt; Void {
    println("Hello \(name)")
}
sayHello("hamasyou")
</code></pre>

<p>戻り値にはタプルを指定することもできる。</p>

<pre><code class="swift">func count() -&gt; (vowels: Int, consonants: Int, others: Int) {
    var n1 = 3, n2 = 5, n3 = 10
    return (n1, n2, n3)
}

let ret = count()
ret.vowels
ret.consonants
ret.others
</code></pre>

<h3>External Parameter Names</h3>

<p>関数呼び出し時にキーワード引数として呼び出す名前を指定できる。</p>

<pre><code class="swift">func someFunction(externalParameterName localParameterName: Int) {
    var total = 10 + localParameterName
}
someFunction(externalParameterName: 5)

func join(s1: String, s2: String, withJoiner joiner: String) -&gt; String {
    return s1 + joiner + s2
}
join("Hello", "World", withJoiner: "-")
</code></pre>

<p><code>externalParameterName</code> と <code>localParameterName</code> を同じにしたいときは、<code>#</code> を使う。</p>

<pre><code class="swift">func(containsCharacter(#string: String, #characterToFind: Character) -&gt; Bool {
    for character in string {
        if character == characterToFind {
            return true
        }
    }
    return false
}
</code></pre>

<p>引数にデフォルト値を指定することもできる。デフォルト値を指定して、externalParameterName を指定しないときは、localParameterName が externalParameterName になる。</p>

<pre><code class="swift">func join(s1: String, s2: String, joiner: String = "-") -&gt; String {
    return s1 + joiner + s2
}
join("Hello", "World", joiner: " ")    
</code></pre>

<p><code>_</code> を externalParameterName に指定すれば、デフォルト値を設定しても呼び出し時に externalParameterName を指定する必要はなくなる。</p>

<pre><code class="swift">func join(s1: String, s2: String, _ joiner: String = "-") -&gt; String {
    return s1 + joiner + s2
}
join("Hello", "World", " ")
</code></pre>

<h3>In-Out Parameters</h3>

<p>関数の引数は定数（<code>let</code>）として渡される。引数を変数（<code>var</code>）として渡したい場合は、引数名の前に <code>var</code> をつける。</p>

<p>var をつけて引数を定義しても、変更の影響を受けるのは関数の中だけ。関数の外の変数にも影響を及ぼしたい場合には <code>inout</code> をつけて引数を定義して、引数を渡すときに <code>&amp;</code> を使う。</p>

<pre><code class="swift">func swap(inout s1: String, inout s2: String) {
    let tmp = s1
    s1 = s2
    s2 = tmp
}

var s1 = "Hello"
var s2 = "World"
swap(&amp;s1, &amp;s2)
s1    // "World"
s2    // "Hello"
</code></pre>

<h2>Closures</h2>

<p>Swift の Closure は次の点が最適化されている。</p>

<ul>
<li>引数と戻り値の型が推論される</li>
<li>Closre Body が単一式の場合はそれが暗黙の戻り値になる</li>
<li>引数を略式で書ける</li>
<li>Closure を最後の引数として取るメソッドの場合、Closure を <code>()</code> の外側に書くことができる</li>
</ul>


<pre><code class="swift Closure Syntax">{ (parameters) -&gt; returnType in
    statements
}
</code></pre>

<pre><code class="swift Closure syntaxes">let names = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]
sort(names, { (s1: String, s2: String) -&gt; Bool in
    return s1 &lt; s2
})

sort(names, { (s1: String, s2: String) -&gt; Bool in return s1 &lt; s2 })
sort(names, { s1, s2 in return s1 &lt; s2 })
sort(names, { s1, s2 in s2 &lt; s2 })
sort(names, { $0 &lt; $1 })
sort(names) { $0 &lt; $1 }  
</code></pre>

<pre><code class="swift map sample">let digitNames = [
    0: "Zero", 1: "One", 2: "Two",   3: "Three", 4: "Four",
    5: "Five", 6: "Six", 7: "Seven", 8: "Eight", 9: "Nine"
]
let numbers = [16, 58, 510]
let strings = numbers.map { (var num) -&gt; String in
    var output = ""
    while num &gt; 0 {
        output = digitNames[num % 10]! + output
        num /= 10
    }
    return output
}
strings
</code></pre>

<pre><code class="swift Closure sample">func makeIncrementor(forIncrement amount: Int) -&gt; (() -&gt; Int) {
    var runningTotal = 0
    func incrementor() -&gt; Int {
        runningTotal += amount
        return runningTotal
    }
    return incrementor
}

let incrementByTen = makeIncrementor(forIncrement: 10)
incrementByTen()    // 10
incrementByTen()    // 20
incrementByTen()    // 30
</code></pre>

<h2>Enumerations</h2>

<p>Swift では <code>Enumeration</code> も first-class type である。Swift ではデフォルト値を設定しない限り、自動で 0, 1, 2 の様な値がふられることはない。</p>

<pre><code class="swift">enum CompassPoint {
    case North
    case South
    case East
    case West
}
CompassPoint.North

enum Numbers: Int {
    case Zero = 0, One, Two, Three, Four, Five, Six, Seven, Eight, Nine
}
Numbers.Four.toRaw()                // 4
Numbers.fromRaw(7) == Numbers.Seven // true 
</code></pre>

<h3>Associated Values</h3>

<p>Swift の enumerations は関連する値を保持することができる。</p>

<pre><code class="swift">enum Barcode {
    case UPCA(Int, Int, Int)
    case QRCode(String)
}

let productBarcode = Barcode.UPCA(8, 85900_51226, 3)
switch productBarcode {
case let .UPCA(numberSystem, identifier, check):
    println("UPC-A with value of \(numberSystem), \(identifier), \(check).")
case let .QRCode(productCode):
    println("QR code with value of \(productCode).")
} 
</code></pre>

<h2>Classes and Structures</h2>

<p>Swift では、クラスと構造体はほぼ同じ物と考えることができる。構造体は参照ではなく copy value で管理される。</p>

<p><blockquote><p>Unlike value types, reference types are not copied when they are assigned to a variable or constant, or when they are passed to a function. Rather than a copy, a reference to the same existing instance is used instead.</p><footer><strong>Classes Are Reference Types</strong></footer></blockquote></p>

<h4>クラスと構造体の共通点</h4>

<ul>
<li><strong>プロパティ</strong> を定義することができる</li>
<li><strong>メソッド</strong> を定義することができる</li>
<li><strong>subscripts</strong> （配列の<code>[0]</code> のようにアクセスできる仕組み）を提供することができる</li>
<li><strong>イニシャライザ</strong> （コンストラクタ）を定義することができる</li>
<li>デフォルトの振る舞いを拡張することができる</li>
<li><strong>protocol</strong> を使うことができる</li>
</ul>


<h4>クラスだけがもつ機能</h4>

<ul>
<li><strong>継承</strong></li>
<li>タイプキャストが可能</li>
<li><strong>デイニシャライザ</strong> （デストラクタ）を定義することができる</li>
<li>ひとつ以上の参照カウントが許される（構造体は copy-value、クラスは reference）</li>
</ul>


<pre><code class="swift syntax">struct Resolution {
    var width = 0
    var height = 0
}

class VideoMode {
    var resolution = Resolution()
    var interlaced = false
    var frameRate = 0.0
    var name: String?
}
let someResolution = Resolution()
let someVideoMode = VideoMode()
someVideoMode.resolution.width = 1280
</code></pre>

<p>Objective-C とは違って、参照をたどって直接値を設定することも可能。</p>

<p>構造体は、暗黙のイニシャライザを使って、プロパティを初期化することが可能。クラスはイニシャライザを明示的に定義しなければいけない。</p>

<pre><code class="swift">let rvga = Resolution(width: 640, height: 480)
</code></pre>

<h3>クラスと構造体のどちらを選ぶか</h3>

<ul>
<li>構造体を使う一番の理由は関係する値をまとめるため</li>
<li>プロパティのデータを何かしら処理する場合には、クラスの方がいいかも</li>
</ul>


<h3>Array と Dictionary</h3>

<p>Swift の Array と Dictionary は構造体の様に振舞う。</p>

<p>Dictionary は変数に割り当てられる際にコピーされる。Key/Value の Value がさらに Dictionary の場合はそれもコピーされる。</p>

<pre><code class="swift">var ages = ["Peter": 23, "Wei": 35, "Anish": 65, "Katya": 19]
var copiedAges = ages
ages["Peter"] = 24    // 24
copiedAges["Peter"]   // 23
</code></pre>

<p>Array はもうちょっと複雑な動きをする。Array の値がコピーされるのは、コピーが必要になった時に起こる。</p>

<p>変数への割り当て、メソッドの引数で渡しただけではコピーは起こらない。コピーが起こるのは、配列の長さ（<code>length</code>）が変わる処理が行ったとき。</p>

<pre><code class="swift">var nums = [10, 20, 30, 40]
var otherNums = nums

nums[0] = 50
otherNums[0]    // 50

nums += 100     // occure copy, nums is [50, 20, 30, 40, 100]
nums[0] = 10    // nums is [10, 20, 30, 40, 100]
otherNums[0]    // 50, otherNums is [50, 20, 30, 40]
</code></pre>

<p>Array で参照を切りたいときは <code>unshare()</code> メソッドを使う。変数への割り当て時に強制的にコピーしたいときは <code>copy()</code> メソッドを使う。</p>

<h2>Properties</h2>

<h3>Lazy Stored Properties</h3>

<p>最初にアクセスされるまで初期化されないようにするには、<code>@lazy</code> を使用する。変数（var）で定義するプロパティには @lazy をつけるようにするといい。</p>

<p><blockquote><p>You must always declare a lazy property as a variable (with the var keyword), because its initial value may not be retrieved until after instance initialization completes. Constant properties must always have a value before initialization completes, and therefore cannot be declared as lazy.</p><footer><strong>Lazy Stored Properties</strong></footer></blockquote></p>

<pre><code class="swift">class DataManager {
    @lazy var importer = DataImporter()   // DataImporter is assumed to take a non-trivial amount of time to initialize.
}
</code></pre>

<h3>Computed Properties</h3>

<p><code>center</code> プロパティが Computed Property になる。<code>set</code> で受け取る引数は明示してもいいし、明示しない場合は <code>newValue</code> で受け取れる。</p>

<pre><code class="swift">struct Rect {
    var origin = Point()
    var size = Size()
    var center: Point {
    get {
        let centerX = origin.x + (size.width / 2)
        let centerY = origin.y + (size.height / 2)
        return Point(x: centerX, y: centerY)
    }
    set {
        origin.x = newValue.x - (size.width / 2)
        origin.y = newValue.y - (size.height / 2)
    }
    }
}
</code></pre>

<h3>Property Observers</h3>

<p><code>willSet</code>, <code>didSet</code> を使うと、プロパティが設定されるまえ、設定された後にコールバックを受け取ることができる。これらのコールバックは初期化時にはよばれない。</p>

<pre><code class="swift">class StepCounter {
    var totalSteps: Int = 0 {
    willSet(newTotalSteps) {
        println("About to set totalSteps to \(newTotalSteps)")
    }
    didSet {
        if totalSteps &gt; oldValue  {
            println("Added \(totalSteps - oldValue) steps")
        }
    }
    }
}
let stepCounter = StepCounter()
stepCounter.totalSteps = 200
// About to set totalSteps to 200
// Added 200 steps
</code></pre>

<h2>Methods</h2>

<p>メソッドにも関数と同じく <code>externalParameterName</code> と <code>localParameterName</code> を指定できる。メソッドの場合は関数と違って、externalParameterName と localParameterName の定義の振る舞いが違う。</p>

<p>メソッドは最初の引数の externalParameterName は、localParameterName と同じになり、呼び出し時は最初の引数の externalParameterName は省略できる。</p>

<pre><code class="swift">class MyClass {
    func hello(name: String, greet: String) -&gt; String {
        return "Hello \(name) \(greet)"
    }
}

let obj = MyClass()
obj.hello("hamasyou", greet: "Good Morning")
</code></pre>

<p>第二引数以降の呼び出しで externalParameterName を指定したくない場合は <code>_</code> を使う。</p>

<pre><code class="swift">class MyClass {
    func hello(name: String, _ greet: String) -&gt; String {
        return "Hello \(name) \(greet)"
    }
}

let obj = MyClass()
obj.hello("hamasyou", "Good Night")
</code></pre>

<h3>Modifying Value Types from Within Instance Methods</h3>

<p>構造体と Enumerations はデフォルトでメソッドの中からプロパティの変更を行うことができない。変更できるようにするには <code>mutating</code> でメソッドを修飾する。</p>

<pre><code class="swift">struct Point {
    var x = 0.0, y = 0.0
    mutating func moveByX(deltaX: Double, y deltaY: Double) {
        x += deltaX
        y += deltaY
    }
}
</code></pre>

<h2>Subscripts</h2>

<p>Subscript はコレクションにアクセスするための略式を定義するもの。クラスや構造体、Enumeration に定義できる。定義すると <code>[0]</code> などでアクセスできるようになる。</p>

<p><code>subscript</code> の引数は複数指定することもできる。</p>

<pre><code class="swift">subscript(index: Int) -&gt; Int {
    get {
        // return an appropriate subscript value here
    }
    set(newValue) {
        // perform a suitable setting action here
    }
}
</code></pre>

<h2>Inheritance</h2>

<p>メソッドやプロパティのオーバーライドには <code>override</code> キーワードを使用する。override されたくないメソッドやプロパティには <code>@final</code> を指定する。</p>

<h2>Initialization</h2>

<p>イニシャライザは <code>init</code> で定義する。イニシャライザに引数を指定する場合、externalPropertyName を指定しなければ暗黙で localPropertyName が externalPropertyName に指定される。</p>

<p>メソッドと違い、<em>イニシャライザの呼び出し時には全ての externalPropertyName の指定が必要</em>。</p>

<pre><code class="swift">struct Color {
    let red = 0.0, green = 0.0, blue = 0.0
    init(red: Double, green: Double, blue: Double) {
        self.red   = red
        self.green = green
        self.blue  = blue
    }
}
let magenta = Color(red: 1.0, green: 0.0, blue: 1.0)
</code></pre>

<h3>Designated Initializers and Convenience Initializers</h3>

<p><code>Designated Initializer</code> はインスタンスの初期化の目的で定義される。<code>Convenience Initializer</code> は Designated Intitializer を呼び出す際のデフォルト値などを設定する目的で使う。</p>

<pre><code class="swift">class MyClass {
    var name: String
    init(name: String) {
        self.name = name
    }

    convenience init() {
        self.init(name: "hamasyou")
    }
}
let me = MyClass()
</code></pre>

<h2>Type Casting</h2>

<p>型チェックには <code>is</code> を使う。</p>

<pre><code class="swift">for item in library {
    if item is Movie {
        // execute movie logic
    }
}    
</code></pre>

<p>ダウンキャストに <code>as</code> が使える。Optional Type の場合は <code>as?</code> を使う。Dictionary とかから値を取り出すときに使える。</p>

<pre><code class="swift">for item in library {
    if let movie = item as? Movie {
        println("Movie: '\(movie.name)', dir. \(movie.director)")
    } else if let song = item as? Song {
        println("Song: '\(song.name)', by \(song.artist)")
    }
}
</code></pre>

<p>配列の型に <code>AnyObject</code> を使うと、利用時にキャストが必要だが何の型か指定しなくても入れれるようになる。</p>

<pre><code class="swift">let someObjects: AnyObject[] = [
    Movie(name: "2001: A Space Odyssey", director: "Stanley Kubrick"),
    Movie(name: "Moon", director: "Duncan Jones"),
    Movie(name: "Alien", director: "Ridley Scott")
]
for object in someObjects {
    let movie = object as Movie
    println("Movie: '\(movie.name)', dir. \(movie.director)")
}
</code></pre>

<p>配列の型に <code>Any</code> を使うと、なんでもいれれるようになる。</p>

<pre><code class="swift">var things = Any[]()

things.append(0)
things.append(0.0)
things.append(42)
things.append(3.14159)
things.append("hello")
things.append((3.0, 5.0))
things.append(Movie(name: "Ghostbusters", director: "Ivan Reitman"))

for thing in things {
    switch thing {
    case 0 as Int:
        println("zero as an Int")
    case 0 as Double:
        println("zero as a Double")
    case let someInt as Int:
        println("an integer value of \(someInt)")
    case let someDouble as Double where someDouble &gt; 0:
        println("a positive double value of \(someDouble)")
    case is Double:
        println("some other double value that I don't want to print")
    case let someString as String:
        println("a string value of \"\(someString)\"")
    case let (x, y) as (Double, Double):
        println("an (x, y) point at \(x), \(y)")
    case let movie as Movie:
        println("a movie called '\(movie.name)', dir. \(movie.director)")
    default:
        println("something else")
    }
}
</code></pre>

<h2>Extensions</h2>

<p>既存のクラス、構造体、Enumeration に機能を追加できる。</p>

<pre><code class="swift">extension SomeType: SomeProtocol, AnotherProtocol {
    // implementation of protocol requirements goes here
}

extension Double {
    var km: Double { return self * 1_000.0 }
    var m: Double { return self }
    var cm: Double { return self / 100.0 }
    var mm: Double { return self / 1_000.0 }
    var ft: Double { return self / 3.28084 }
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[７つの言語 ７つの世界]]></title>
    <link href="http://hamasyou.com/blog/2011/08/27/4274068579/"/>
    <updated>2011-08-27T22:11:00+09:00</updated>
    <id>http://hamasyou.com/blog/2011/08/27/4274068579</id>
    <content type="html"><![CDATA[<p>本書は、はじめてプログラミングを知ったときに楽しさを思い出させてくれるものです。紹介されているプログラミング言語は7つ。</p>

<ul><li>Ruby</li>
<li>Io</li>
<li>Prolog</li>
<li>Scala</li>
<li>Erlang</li>
<li>Clojure</li>
<li>Haskell</li></ul>


<p>単なる言語紹介の本ではなく、<strong>言語を知る</strong>本です。</p>

<p>本書を読むことで、各言語の長所、短所、原理、思想を知ることができます。プログラマとして一皮向けたい人に、おすすめです。</p>

<p><blockquote><p>禅の指導者は、数学ができるようになりたければラテン語を勉強せよと言うだろう。プログラミングでも同じだ。オブジェクト指向プログラミングの本質を深く理解するには、論理プログラミングや関数型プログラミング（FP）を勉強する必要がある。関数型プログラミングに上達したければ、アセンブラを勉強する必要がある。</p></p><p><p></p><footer><strong>本書序文より</strong></footer></blockquote></p>

<p><blockquote><p>プログラミングとは結局、理解することであり、理解できるかどうかはどれだけアイデアの引き出しがあるかにかかっている。したがって、新しい言語を直接体験することは、プログラミングが何たるかをより深く理解するために欠かせない。</p></p><p><p></p><footer><strong>本書序文より</strong></footer></blockquote></p>

<!-- more -->




<h2>おぼえがき</h2>




<h2>Ruby</h2>


<p><strong>Ruby</strong> は純粋なオブジェクト指向言語である。オブジェクト指向の設計哲学において重要な、実装ではなくインターフェースに合わせてコーディングを行うというのを、Ruby では<em>ダックタイピング</em>によって実現する。</p>

<p>Ruby には多くのシンタックスシュガーが用意されており、開発者の生産性を高める工夫が数多く用意されている。</p>

<p><section></p>

<h4>参考</h4>


<p><a href="http://ja.wikipedia.org/wiki/Ruby" rel="external nofollow">Ruby - Wikipedia</a></p>

<p></section></p>

<p><blockquote><p>スプーン一杯の砂糖があるだけで、苦い薬も飲めるのよ。</p></p><p><p></p><footer><strong>メリー・ポピンズ</strong></footer></blockquote></p>

<h2>Io</h2>


<p><strong>Io</strong>（イオ）は<em>プロトタイプ言語</em>であり、すべてのオブジェクトは別のオブジェクトのクローンである。</p>

<p>Io はオブジェクト指向言語で、シンタックスは単純にメッセージをチェーン接続したものになる。各メッセージはオブジェクトを返す。すべてのものは別のレシーバを返すメッセージである。</p>

<p>Io にはキーワードはない。ただし、キーワードのように振る舞う文字がいくつかある。</p>

<p>クラスとオブジェクトの両方を意識する必要はなく、もっぱらオブジェクトだけを扱えばよい。必要に応じてオブジェクトを複製する。これらのクローンは<em>プロトタイプ</em>と呼ばれる。</p>

<p>プロトタイプベースの言語では、すべてのオブジェクトが既存のオブジェクトのクローンとなる。</p>

<p><section></p>

<h4>参考</h4>


<p><a href="http://ja.wikipedia.org/wiki/Io_(%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E8%A8%80%E8%AA%9E)" rel="external nofollow">Io（プログラミング言語） - Wikipedia</a></p>

<p></section></p>

<p><section></p>

<h3>オブジェクト、タイプ、インスタンス</h3>


<pre><code class="io"># ルートオブジェクトである Object を複製して Person オブジェクトを生成する
Person := Object clone
# Person オブジェクトを複製して hamasyou というスロットを作成する
hamasyou := Person clone
</code></pre>

<p>慣習上、Io ではタイプの先頭文字に大文字を使う。先頭が大文字のオブジェクトを Io はタイプとして認識する。</p>

<p></section></p>

<p><section></p>

<h3>メソッド</h3>


<p>Io ではメソッドは次のように定義する。</p>

<pre><code class="io">method(name, writeln("Hello ", name))
</code></pre>

<p>メソッドもオブジェクトなので、スロットに代入できる。</p>

<pre><code class="io">Person greet := method(name, writeln("Hello ", name))
</code></pre>

<p></section></p>

<p><section></p>

<h3>プロトタイプ・プログラミングのパラダイム</h3>


<p><blockquote><p>- すべてのモノはオブジェクトである。<br/>- オブジェクトとのすべてのやり取りはメッセージを介して行う。<br/>- クラスをインスタンス化するのではなく、他のオブジェクト（プロトタイプという）を複製する（クローンを作成する）。<br/>- オブジェクトは自身のプロトタイプを記憶している。<br/>- オブジェクトにはスロットがある。<br/>- スロットにはオブジェクト（メソッドオブジェクトを含む）が格納される。<br/>- メッセージはスロットが保持している値を返したり、スロットに格納されているメソッドを呼び出したりする。<br/>- オブジェクトは、自分が応答できないメッセージを自分のプロトタイプに送信する。</p><footer><strong>本書P.48より</strong></footer></blockquote></p>

<p></section></p>

<p><section></p>

<h3>コレクション</h3>


<p>Io には List と Map の二つのコレクションが用意されている。</p>

<pre><code class="io">myList := list("Hello", "Good bye")
myMap := Map clone
</code></pre>

<p>list は List プロトタイプを作成するメソッドである。Map を作成する方法はクローンしかない。</p>

<p></section></p>

<p><section></p>

<h3>true, false, nil, シングルトン</h3>


<p>true, false, nil はシングルトンとして定義されている。自分のクラスをシングルトンとして定義するには次のようにする。</p>

<pre><code class="io">MySingleton := Object clone
MySingleton clone := MySingleton
</code></pre>

<p></section></p>

<p><section></p>

<h3>メッセージ</h3>


<p>Io ではほとんどすべてのものがメッセージになる。メッセージは <em>sender（送信元、呼び出し元）</em>、<em>target（送信先、宛先、呼び出し先）</em>、<em>arguments（引数）</em>のコンポーネントからなる。</p>

<p>call メソッドを使うと、任意のメッセージに関するメタ情報を参照できる。</p>

<pre><code class="io">objA := Object clone
# =&gt; Object_0x000000aa
objA myMethod := method(call sender)

objB := Object clone
# =&gt; Object_0x000000bb
objB myMethod := method(objA myMethod)

objB myMethod
# =&gt; Object_0x000000bb
</code></pre>

<p>objA の myMethod スロットは、メソッドの呼び出し元の情報を表示する call sender が定義されている。これを、objB の myMethod スロットが呼び出すことによって、sender は objB が参照されるため、objB のメタ情報が表示される。</p>

<p></section></p>

<p>（Io を Mac OS X にインストールしようとしたところ、make でエラーが出てしまってインストール出来なかったため、おぼえがきはここまで。。）</p>

<h2>Prolog</h2>


<p><em>ルールベース言語</em>である <strong>Prolog</strong> を使えば、論理を表現したり質問をしたりできる。Prolog もデータベースを扱うが、論理ルールと関係から成り、データを表現する部分とデータに質問する部分で構成される。</p>

<p>Prolog は次の構成要素からなる。</p>

<dl><dt>事実</dt>
<dd><p>特定の世界についての基本的な表明</p></dd>
<dt>ルール</dt>
<dd><p>その世界の事実に関する推論</p></dd>
<dt>質問</dt>
<dd><p>その世界に関する質問</p></dd>
</dl>


<p>Prolog では、答えに至る道筋をコーディングするのではなく、純粋な論理を使って知識をコーディングする。あとは Prolog がその知識を組み合わせて答えを見つけてくれる。我々プログラマは、知識ベースに論理を組み込んで、それに対して質問をするという形になる。</p>

<p><section></p>

<h4>参考</h4>


<p><a href="http://ja.wikipedia.org/wiki/Prolog" rel="external nofollow">Prolog - Wikipedia</a></p>

<p></section></p>

<h3>アトムと変数</h3>


<p>Prolog では小文字で始まる単語を<em>アトム</em>と呼び、固定値の定義になる。大文字かアンダースコアで始まる単語は変数である。</p>

<h3>知識ベース（事実、ルール）</h3>


<p>Prolog のプログラムの例</p>

<pre><code class="prolog">likes(hamasyou, udon).
likes(taro, udon).
likes(jiro, ramen).

friend(X, Y) :- ＼+(X = Y), likes(X, Z), likes(Y, Z).
</code></pre>

<p>likes(.., ..) の部分が事実になり、 friend(.., ..) の部分がルールになる。＼+ は否定なので、friend のルールは、X と Y が一致せず、X が Z を好きで、Y が Z を好きな場合となる。</p>

<h3>地図の塗り分け問題の例</h3>


<p>本書より抜粋</p>

<p><img alt="map.gif" src="http://hamasyou.com/images/map.gif" width="320" height="360" class="mt-image-none" style="" /></p>

<pre><code class="prolog">different(red, green).
different(red, blue).
different(green, red).
different(green, blue).
different(blue, red).
different(blue, green).

coloring(Alabama, Mississippi, Georgia, Tennessee, Florida) :-
  different(Mississippi, Tennessee),
  different(Mississippi, Alabama),
  different(Alabama, Tennessee),
  different(Alabama, Mississippi),
  different(Alabama, Georgia),
  different(Alabama, Florida),
  different(Georgia, Florida),
  different(Georgia, Tennessee).
</code></pre>

<p>隣接する州を同じ色にぬらないように色を決めるというコーディングが、たったこれだけでかけてしまう。</p>

<p>Prolog では、事実と推論でロジックを表現し、利用者に質問させる。手順を追った解法を作る必要はない。</p>

<h3>Prolog の得意とする問題</h3>


<p><blockquote><p>Prolog では問題の解法を記述する必要はない。問題を記述するだけでよい。そして、問題を記述するための言語は純粋な論理だけだ。事実と推論から始めれば、あとは Prolog がやってくれる。Prolog のプログラムは高レベルの抽象化を実現する。この事例のスケジュール作成と行動パターンは、Prolog が得意とする問題だ。</p></p><p><p></p><footer><strong>本書P.84</strong></footer></blockquote></p>

<h3>再帰処理のメモリ不足</h3>


<p>ルールをネストする場合、繰り返しか再帰を使う必要がある。宣言型言語である Prolog ではこの問題の場合、再帰を使う。</p>

<p>宣言型言語は、再帰によるスタック領域の消費にともなるメモリ不足への対応として、<em>末尾再帰最適化</em>という手法で解決していることが多い。Prolog は再帰部分がサブゴールの最後にある場合、最適化を行うため、メモリ不足に対処することができる。</p>

<h3>リストとタプル</h3>


<p>リストは、[1, 2, 3]、タプルは (1, 2, 3) のように宣言する。リストは可変長、タプルは固定長である。</p>

<p>リストには、[Head|Tail] という構文でリストを分割する機能がある。_（アンダースコア）はワイルドカードで、何にでもマッチングすることを表す。</p>

<pre><code class="prolog">(1, 2, 3) = (1, 2, 3).
[1, 2, 3] = [1, 2, 3].
[1, 2, 3] = [Head|Tail].
# =&gt; Head = 1
# =&gt; Tail = [2,3]
[a, b, c, d, e] = [_, _|[Head|_]].
# =&gt; Head = c
</code></pre>

<h3>リストと数値計算</h3>


<p>Prolog でリストの合計値を計算する sum を処理するには、次のようにする。</p>

<pre><code class="prolog">sum(0, []).
sum(Total, [Head|Tail]) :- sum(Sum, Tail), Total is Head + Sum.

| ?- &lt;kbd&gt;sum(What, [2, 4, 6])&lt;/kbd&gt;
What is 12 ?
</code></pre>

<p>合計のルールとして、「空のリストの合計は0であり、Tail の合計（Sum）と Head を足したものが Total になる」ということを与えてやるだけで、Prolog が合計の出してくれる。</p>

<h3>Prolog が活躍する場面</h3>


<p>Prolog によるプログラミングはまず知識ベースを構築し、その問題領域に関する質問をすることで行う。一部の質問は表明であり、yes、no で答える。変数を含む質問を行うことで、その変数に入る値の組み合わせを求めることができる。</p>

<p>単純な代入はなく、<em>ユニフィケーション</em>と<em>バックトラック</em>という技法を使用して、変数のとりうる値の推論を行っていく。</p>

<ul><li>自然言語処理</li><li>ゲームの解法</li><li>セマンティックWeb</li><li>人工知能</li><li>スケジューリング</li></ul>


<p>知識ベース、ルールが与えられ解を求めるといったようなコンテキストに置いて、Prolog は力を発揮する。</p>

<h2>Scala</h2>


<p><strong>Scala</strong> は異なるプログラミングパラダイム間の橋渡しをする言語である。主に Java との橋渡しをする。</p>

<ul><li>Java 仮想マシン上で動作するため、既存の環境で共存できる。</li>
<li>Java のライブラリを使用できる。また、Java のフレームワークも利用出来る。</li>
<li>静的に型付けされた言語である。<strong>オブジェクト指向と関数型プログラミング言語のパラダイム</strong>を持つ、マルチパラダイム言語。</li>
</ul>


<p><section></p>

<h4>参考</h4>


<p><a href="http://ja.wikipedia.org/wiki/Scala" rel="external nofollow">Scala - Wikipedia</a></p>

<p></section></p>

<h3>Scala の特徴</h3>




<dl><dt>型推論</dt>
<dd><p>Scala は出来る限り変数の型を推論する。</p></dd>
<dt>関数型概念</dt>
<dd><p>既存の関数をさまざまな方法で用いて新しい関数を作ることができる。</p></dd>
<dt>変更不能な変数</dt>
<dd><p>Scala は、変数は変更不可能な <em>val</em> と変更可能な <em>var</em> を使い分ける。</p></dd>
<dt>アクター理論</dt>
<dd><p>マルチコア時代に対応した並行処理の仕組みを持つ。</p></dd>
</dl>




<h3>Scala の型</h3>


<p>Scala では全てはクラスのインスタンスであり、Java のプリミティブ型も Scala ではオブジェクトとして扱う。ただし、メソッドはオブジェクトではない。関数はクラスのインスタンスであるのでオブジェクトである。</p>

<p>Scala は型推論によってほとんどの変数の型を自動的に解決する。これはコンパイル時に行われる。</p>

<p>Scala には<em>タプル</em>が用意されている。タプルは固定長のオブジェクトリストのことで、それぞれのオブジェクトは型が違っていても構わない。純粋な関数型言語ではオブジェクトとその属性をタプルで表すことが多い。</p>

<p>Scala のルートクラスには <em>Any</em> という型がある。Scala のすべてのクラスは Any を継承している。Scala にはすべてのクラスのサブクラスである <em>Nothing</em> 型もある。</p>

<h3>クラス定義</h3>


<p>Scala でクラスを定義する場合は次のように記述する。</p>

<pre><code class="scala">class Person(firstName: String, lastName: String) {
  val fullName = firstName + " " + lastName

  def name():String = {
    return fullName
  }
}

val person = new Person("syougo", "hamada")
println(person.name)
// =&gt; syougo hamada
</code></pre>

<p>クラスの定義はコンストラクタになる。クラス名に続いてコンストラクタに渡す引数を記述する。</p>

<h3>クラスメソッドの定義</h3>


<p>Java ではクラスメソッドを定義するのに static を利用するが、Scala ではクラスメソッドはシングルトンオブジェクトのインスタンスメソッドとして定義する。</p>

<p>インスタンスを一つしか持たないシングルトンクラスを定義するには <em>object</em> キーワードを使う。</p>

<pre><code class="scala">object Configuration {
 def config = ...
}
</code></pre>

<p>Scala では <em>class 定義と object 定義に同じ名前を使うことができる</em>。クラスメソッドを定義したいときは class 定義で使った名前と同じクラス名を object で使い、クラスメソッドを object 定義内に記述する。</p>

<p>このような class と object で同名のクラスを持つようなオブジェクトを<em>コンパニオンオブジェクト</em>と呼ぶ。</p>

<h3>トレイト</h3>


<p>Java のインターフェースを Scala では<em>トレイト</em>と呼ぶ。トレイトには実装も記述することができる。</p>

<p>トレイトはクラスを部分的に実装したものと考えることができ、単一の関心事を実装するのに使うのがよい。</p>

<pre><code class="scala">trait Nice {
  def greet() = println("Hello!")
}
</code></pre>

<h3>変更不可能な変数</h3>


<p>Scala は並行プログラミングを重視しているため、変更不可能な変数の定義が簡単に行える。Java では final を付けて変数を宣言するが、Scala では <em>val</em> キーワードで変数を定義する。</p>

<p>Scala では可変状態は有害であり、変数は衝突状態をさけるために変更不能（immutable:イミュータブル）にすることが推奨される。</p>

<p>オブジェクト指向プログラミングでは状態はオブジェクトにカプセル化されており、可変であることが多いが、<em>関数型プログラミングの設計哲学では可変状態は並行性を制限するため有害である</em>としている。</p>

<h3>nil の扱い</h3>


<p>Scala では Null はトレイトであり null は Null のインスタンスである。Nil は空のリストになっている。</p>

<h3>高階関数</h3>


<p>高階関数とは、他の関数を入力として受け取る関数、または出力として関数を返す関数のこと。</p>

<p>Scala のコレクションには foreach という関数を引数にとり繰り返し処理するメソッドが用意されている。</p>

<pre><code class="scala">def foreach[U](f: Elem =&gt; U): Unit = {
  val it = iterator
  while (it.hasNext) f(it.next())
}
</code></pre>

<p>foreach の引数 <code>(f: Elem =&gt; U)</code> の部分が関数を受け取ることを表している。Scala では関数の入力を 入力の型 =&gt; 出力の型 という形で表す。</p>

<p>上記の場合、Elem 型のオブジェクトを引数にとり型パラメータ U を返す関数を表す。foreach は例えば次のように利用する。</p>

<pre><code class="scala">val list = List("hoge", "foo", "bar")
list.foreach(elem =&gt; println(elem))
// =&gt; hoge
// =&gt; foo
// =&gt; bar
</code></pre>

<p>foreach に、無名関数を作成して渡している。無名関数のコードブロックは 変数名 =&gt; コード の形で作成する。ここでは、引数 elem に String 型のオブジェクト（list の要素）が渡され、コードの部分が実行される。</p>

<h3>アクターとメッセージパッシング</h3>


<p>Scala は並行性を実現するのに<em>アクター</em>と<em>メッセージパッシング</em>を利用する。アクターは厳密に管理されたキューで構成され、状態を更新したりアクセスしたりするときには必ずメッセージ交換に寄って通信する。</p>

<p>Scala でアクターを利用する場合は react または receive メソッドを loop でラップした形をしている。</p>

<p><section></p>

<h4>参考</h4>


<p><a href="http://www.ibm.com/developerworks/jp/java/library/j-scala04109.html" rel="external nofollow">多忙な Java 開発者のための Scala ガイド: Scala の並行性を掘り下げる - developerWorks</a></p>

<p></section></p>

<h2>Erlang</h2>


<p><strong>Erlang</strong>（アーラン）は、並行処理指向言語で、スケーラブルな並行性と信頼性を備えている。Erlang は<em>関数型言語</em>で、最大の特徴はプロセスをできるだけ軽量にするという軽量プロセスによる、並行処理である。</p>

<p>Erlang には魅力的な機能が備わっている。</p>

<ul><li>エラー処理機構</li>
<li>動的なコード更新メカニズム</li>
<li>ビットレベルのパターンマッチング</li>
</ul>


<p>Erlang のモットーは「非防御的」プログラミングと「クラッシュさせろ」である。</p>

<p>Erlang は<em>難しいことを簡単にし、簡単なことを難しくする</em>言語であり。「普通」のプログラムを書くのは簡単ではない。</p>

<p><section></p>

<h4>参考</h4>


<p><a href="http://ja.wikipedia.org/wiki/Erlang" rel="external nofollow">Erlang - Wikipedia</a></p>

<p><a href="http://erlangworld.web.fc2.com/" rel="external nofollow">Erlang World</a></p>

<p></section></p>

<h3>関数型言語</h3>




<ul><li>プログラムはすべて関数で作成する。オブジェクトは登場しない。</li>
<li>関数は通常、入力が同じであれば出力が同じになる。</li>
<li>関数は通常、副作用を持たない。</li>
<li>すべての変数への代入は1回に限られる。</li>
</ul>


<p>Erlang は<em>純粋な関数型言語ではない</em>。例外が幾つかある。</p>

<h3>軽量プロセス</h3>


<p>Erlang は<em>軽量プロセス</em>という考え方を採用している。Erlang もアクターを用いて並行処理を実現している。</p>

<p>Scala ではアクターはオブジェクトでありスレッドプールが動作基盤になっていたが、Erlang では<em>アクターは軽量プロセス</em>である。</p>

<h3>信頼性</h3>


<p>Erlang の哲学は「クラッシュさせろ」であり、何かエラーがあればすぐにプロセスを強制終了させ新しいプロセスを作成することができる。</p>

<p>Erlang はコードのホットスワップ（停止させずにアプリケーションの一部を取り替えること）ができる。</p>

<p>Erlang にはメッセージパッシング、プロセスの生成、プロセスの監視の機能が備わっているため、並行処理を行うのがとても容易になっている。</p>

<h3>変数とアトム</h3>


<p>Erlang では変数は大文字で始める必要がある。小文字で始めた場合はアトム（定数、シンボル）になる。</p>

<pre><code class="erlang">apple.
% =&gt; apple
Fluit = banana.
% =&gt; banana
</code></pre>

<h3>パターンマッチング</h3>


<p>Erlang では、データ構造をマッチングすることで、変数をタプル内の各値に代入する。</p>

<pre><code class="erlang">Person = {person, {name, "Syougo Hamada"}, {age, 29}}.
{person, {name, Name}, {age, Age} = Person.
Name.
% =&gt; Syougo Hamada
Age.
% =&gt; 29
</code></pre>

<p>Erlang では複数のマッチング文と複数の種類のタプルを使うことがよくあるので、上記のように、タプルの先頭にデータ構造を表すアトムを入れておくデータ構造をよく使う。</p>

<h3>関数</h3>


<p>Erlang は、関数を .erl という拡張子を持つファイルに格納する。ファイルを実行するにはコンパイルが必要になる。コンパイルを行うと .beam という実行ファイルが生成される。コンパイル済みのモジュールは beam という仮想マシン内で動作する。</p>

<p><section></p>

<pre><code class="erlang basic.erl">-module(basic).
-export([mirror/1]).

mirror(Arg) -&gt; Arg.
</code></pre>

<p>basic モジュール内に mirror という関数を定義した。<code>mirror/1</code> は一つの引数を取るという意味。export で外部に公開する関数を指定する。実行するにはコンパイルを行い、次のように呼び出す。</p>

<pre><code class="erlang">c(basic).
basic:mirror(hamasyou).
% =&gt; hamasyou
</code></pre>

<p>関数は、モジュール名を修飾して呼び出す必要がある。</p>

<p></section></p>

<p><section></p>

<pre><code class="erlang matching_number.erl">-module(matching_number).
-export([number/1]).

number(one) -&gt; 1;
number(two) -&gt; 2;
number(three) -&gt; 3.
</code></pre>

<pre><code class="erlang">c(matching_number).
matching_number:number(one).
% =&gt; 1
matching_number:number(two).
% =&gt; 2
matching_number:number(three).
% =&gt; 3
</code></pre>

<p>関数のコードは Prolog のように記述できる。つまり、マッチングである。複数のマッチングの可能性があるコードは終端を ; で終える。最後のケースは . で終わる。</p>

<p></section></p>

<h3>無名関数</h3>


<pre><code class="erlang">Negate = fun(I) -&gt; -I end.
Negate(1).
% =&gt; -1
</code></pre>

<p>無名関数は fun というキーワードで定義する。関数は変数に代入することができる。</p>

<h3>リスト内包表記</h3>


<p>関数型言語で最も重要な関数の一つは map である。map はリスト要素に何かを適用しリストを変形させる。</p>

<pre><code class="erlang">List = [1, 2, 3, 4, 5].
Double = fun(X) -&gt; X * 2 end.
lists:map(Double, List).
% =&gt; [2, 4, 6, 8, 10]
</code></pre>

<p>Erlang は、これと同じことをリスト内包表記と呼ぶ構文で用意している。</p>

<pre><code class="erlang">[Double(X) || X &lt;- List].
</code></pre>

<p>リスト内包表記の完全な形式は次のとおり。</p>

<ul><li>リスト内包表記は [式 || 節1, 節2, ..., 節N] という形式を持つ。</li>
<li>リスト内包表記には任意の数の節を含めることができる。</li>
<li>節には、ジェネレータまたはフィルタを指定できる。</li>
<li>フィルタには、ブール式またはブール値を返す関数を指定できる。</li>
<li><code>Match &lt;- List</code> という形式のジェネレータは、左辺のパターンを右辺のリストの各要素とマッチングする。</li>
</ul>


<pre><code class="erlang">[{X, Y} || X &lt;- [1, 2, 3, 4, 5], X &lt; 3, Y &lt;- [5, 6]].
% =&gt; [{1,5},{1,6},{2,5},{2,6}]
</code></pre>

<h3>並行性を実現するプリミティブ</h3>


<p>Erlang では並行性を実現する基本プリミティブは、<em>メッセージの送信（!を使用）</em>、<em>プロセスの生成（spawn を使用）</em>、<em>メッセージの受信（receive）</em>の3つになる。</p>

<h3>非同期通信</h3>


<p>非同期プロセス側の受信ロジックの例を次に示す。</p>

<pre><code class="erlang">-module(mymodule).
-export([loop/0]).

loop() -&gt;
  receive
    "hoge" -&gt;
      io:format("hoge"),
      loop();

    "foo" -&gt;
      io:format("foo"),
      loop();

    _ -&gt;
      io:format("don't understand"),
      loop()
end.
</code></pre>

<p>受信は receive で行う。無限ループを実行しているが、Erlang も末尾再帰が最適化されるため loop() がreceive 節の最後の処理である限りオーバーヘッドはない。これが Erlang で無限ループを書く際のイディオムの一つである。</p>

<p>次に、非同期プロセスを生成する側のコードを示す。</p>

<pre><code class="erlang">c(mymodule).
Pid = spawn(fun mymodule:loop/0).
</code></pre>

<p>プロセスの生成は spawn で行う。spawn は関数を引数に取る関数である。</p>

<p>最後に、生成したプロセスに対してメッセージを送るコード例を示す。</p>

<pre><code class="erlang">Pid ! "hoge".
</code></pre>

<p>プロセスへのメッセージ送信は ! を使う。</p>

<h3>同期プロセス</h3>


<p>同期プロセスを使う場合は、receive でプロセスのIDと受け取ったメッセージが対となるタプルをマッチさせる。このIDにメッセージを送ることで応答を返す。</p>

<pre><code class="erlang">receive
  {Pid, "hoge"} -&gt;
    Pid ! "Received",
    loop();
    ...
</code></pre>

<p>送信側は、応答を待つようにする必要がある。</p>

<pre><code class="erlang">Pid ! "hoge",
  receive
    Message -&gt; do_something_with(Message)
  end.
</code></pre>

<p>送信側も、receive を使って応答を待つようにする。</p>

<h3>OTP ライブラリ</h3>


<p>Erlang は電話会社で開発されたため、主要なライブラリ OTP(Open Telecom Platform)が用意されている。耐障害性、スケーラビリティ、トランザクション整合性、ホットスワップなどの機能が組み込まれている。</p>

<h3>（おまけ）処理系のインストール</h3>


<p>Erlang を公式サイトからダウンロードしてきて make を行うと下のようなエラーがでた。</p>

<p><div class="terminal-window">
          <nav class="terminal-control-window">
            <a href="#" class="terminal-close" data-rel="close">close</a>
            <a href="#" class="terminal-minimize">minimize</a>
            <a href="#" class="terminal-deactivate">deactivate</a>
          </nav>
          <h1 class="terminal-title">Terminal</h1>
          <div class="terminal-container"><div class="terminal"><table><tr><td class='gutter'><pre class='line-numbers'><span class='line-number'>&nbsp;</span></pre></td><td class='code'><pre><code><span class='line output'>make[3]: *** No rule to make target <code>erl_alloc_types.h', needed by</code>obj/i386-apple-darwin10.8.0/opt/plain/atom.o'.  Stop.</span></code></pre></td></tr></table></div></div>
        </div></p>

<p>Makefile.in に erl_alloc_types のコンパイル方法が書かれていないせいらしい。github にパッチが上がっていたので、Makefile.in を書き換えると上手くコンパイルができた。</p>

<p><a href="https://github.com/erlang/otp/blob/dev/erts/emulator/Makefile.in" rel="external nofollow">Erlang Makefile.in patch</a></p>

<h2>Clojure</h2>


<p><strong>Clojure</strong> は JVM 上で動く Lisp である。</p>

<ul><li>Lisp はリストの言語である。関数呼び出しでは、<em>リストの最初の要素を関数</em>として、<em>残りの要素を引数</em>として用いる。</li>
<li>Lisp は自分自身のデータ構造を用いてコードを表現する。「<em>データとしてのコード</em>」(code as data)の思想で設計されておりマクロ機構をもつ。</li></ul>


<p><section></p>

<h4>参考</h4>


<p><a href="http://ja.wikipedia.org/wiki/Clojure" rel="external nofollow">Clojure - Wikipedia</a></p>

<p></section></p>

<h3>関数の呼び出し</h3>


<p>Clojure は関数呼び出し全体を括弧で囲む。最初の要素は関数名、残りが引数になる。</p>

<pre><code class="clojure">(println "Hello Clojure")
(+ 1 1)
; =&gt; 2
</code></pre>

<h3>リスト、マップ、セット、ベクタ、シーケンス</h3>


<p>Clojure では慣用的に、<em>コードにはリスト</em>を、<em>データにはベクタ</em>を使用する。</p>

<p><section></p>

<h4>リスト</h4>


<p><em>リスト</em>は関数として評価されるため、リストでデータを扱う場合は次のようにする。</p>

<pre><code class="clojure">(list 1 2 3)
</code></pre>

<p></section></p>

<p><section></p>

<h4>ベクタ</h4>


<p><em>ベクタ</em>は各カッコ（[]）で表す。ベクタは順序付きのコレクション。</p>

<pre><code class="clojure">[:hoge :foo :bar]
</code></pre>

<p>ベクタも関数であるため、引数にインデックスを取ることができる。</p>

<pre><code class="clojure">([:hoge :foo :bar] 0)
; =&gt; :hoge
</code></pre>

<p></section></p>

<p><section></p>

<h4>セット</h4>


<p><em>セット</em>は順序なしのコレクション。#{} で囲んで定義する。</p>

<pre><code class="clojure">#{:foo :hoge :bar}
; =&gt; #{:hoge :foo :bar}
</code></pre>

<p></section></p>

<p><section></p>

<h4>マップ</h4>


<p><em>マップ</em>はキーと値のセットで {} で囲んで定義する。</p>

<pre><code class="clojure">{:key1 :hoge, :key2 :foo}
</code></pre>

<p><em>Clojure ではカンマを空白として扱う</em>ため、空白の代わりにカンマを使ってもいい。</p>

<p></section></p>

<p><section></p>

<h4>シーケンス</h4>


<p><em>シーケンス</em>は Clojure のコンテナを実装に依存しない形で抽象化したもの。シーケンスを使うとすべてのコレクションを総称的に扱うことができる。</p>

<p></section></p>

<p>Clojure では先頭に : が付いている単語は<em>キーワード</em>として扱われる。Clojure のキーワードは Ruby のシンボル、Prolog や Erlang のアトムと同じものである。</p>

<h3>変数の定義</h3>


<p>Clojure で変数を定義するのには <em>def</em> を使う。</p>

<pre><code class="clojure">(def mentors {:dearth-vader "obi wan", :luke "yoda"})
</code></pre>

<h3>関数の定義</h3>


<p>Clojure で関数を定義するには <em>defn</em> を使う。形式は <em><code>(defn name [params] body)</code></em> である。</p>

<pre><code class="clojure">(defn greet [] (println "Hello"))
</code></pre>

<p>関数には説明文を指定することもできる。</p>

<pre><code class="clojure">(defn greet
      "This function greet 'Hello'"
      []
      (println "Hello"))
</code></pre>

<h3>無名関数の定義</h3>


<p>Clojure では無名関数は <em>fn</em> で定義する。<em><code>(fn [params] body)</code></em> の形式になる。# という<em>リーダーマクロ</em>を使って簡略化して書くこともできる。リーダーマクロを使うと % がシーケンスの各項にバインドされる。</p>

<pre><code class="clojure">(def people ["hamasyou" "taro"])
(map (fn [w] (* 2 (count w))) people)
; =&gt; (16 8)
(map #(* 2 (count %)) people)
; =&gt; (16 8)
</code></pre>

<h3>バインディング</h3>


<p>関数の引数に実引数の値を代入することを<em>バインディング（束縛）</em>という。Clojure ではバインディングする引数の任意の部分にだけパラメータとしてアクセスする機能がある。それを<em>デストラクチャリング（分配束縛）</em>という。</p>

<p>無視するパラメータには慣習として _ を使う。</p>

<pre><code class="clojure">(def board [[:x :o :x] [:o :x :o] [:o :x :o]])
(defn center [[_ [_ c _] _]] c)
(center board)
; =&gt; :x
</code></pre>

<p><em>let</em> を使えば引数リスト内以外でもデストラクチャリングを起こすことができる。</p>

<pre><code class="clojure">(def person {:name "hamasyou", :age 29})
(let [{name :name} person] (str "The person's name is " name))
</code></pre>

<p>let の第一引数はバインドするシンボルとバインドされる値からなるベクタ。第二引数は式。</p>

<h3>再帰</h3>


<p>Clojure は JVM の制約のため末尾再帰最適化をサポートしていない。そのため、loop と recur を使って再帰を定義する必要がある。</p>

<p><a href="http://sassylog.blogspot.com/2010/03/clojure_7760.html" rel="external nofollow">Clojure 再帰 - sassy log</a></p>

<h3>マクロ展開</h3>


<p>Clojure はマクロ展開と呼ばれる段階を経て、コードを実装または解釈する。</p>

<p><a href="http://d.hatena.ne.jp/sDaigo/20101031/1288509314" rel="external nofollow">Clojure Macro 入門 - Playground of Mine</a></p>

<h3>ソフトウェアトランザクショナルメモリ(STM)</h3>


<p>Clojure では並行性をサポートするために<em>ソフトウェアトランザクショナルメモリ(STM)</em>を用いる。参照を作成するのに ref を使う。</p>

<pre><code class="clojure">(def movie (ref "Star Wars"))
(deref movie)
; =&gt; "Star Wars"
@movie
; =&gt; "Star Wars"
</code></pre>

<p>参照先を参照するのには deref を使う。@ を使ったシンタックスシュガーも用意されている。</p>

<p>参照先の値を書き換えるときには、トランザクション内で実行する必要がある。トランザクションをオープンするのには dosync 関数を使う。</p>

<pre><code class="clojure">(dosync (ref-set movie "Star Wars: The Revenge of the Sith"))
@movie
; =&gt; "Star Wars: The Revenge of the Sith"
</code></pre>

<h3>アトム</h3>


<p>他のアクティビティと連携しない共有データは、単にスレッド安全性を保証したいだけの場合が多い。その場合は<em>アトム</em>を使う。アトムを使うとトランザクション外でもデータの変更を許す。</p>

<pre><code class="clojure">(def config (atom "Configuration Data"))
</code></pre>

<h3>エージェント、フューチャ</h3>


<p>アトムと同様に<em>エージェント</em>を使うとデータを非同期に変更できる。エージェントは Io のフューチャと同じで、デリファレンスされた（参照がとりだされた）エージェントの状態は、値が使用可能になるまでブロックされる。</p>

<p>結果が返されるまで待ちたくない場合はフューチャを使う。</p>

<p><section></p>

<h4>もろもろの並行性に関しての参考</h4>


<p><a href="http://d.hatena.ne.jp/marblejenka/20100626/1277528587" rel="external nofollow">clojureでのrefsの実装について - marblejenkaの日記</a></p>

<p></section></p>

<h2>Haskell</h2>


<p><strong>Haskell</strong> は純粋関数型プログラミング言語である。Haskell は<em>遅延評価</em>を重視している。</p>

<p><section></p>

<h4>参照</h4>


<p><a href="http://ja.wikipedia.org/wiki/Haskell" rel="external nofollow">Haskell - Wikipedia</a></p>

<p></section></p>

<h3>関数の定義</h3>


<p>Haskell の関数定義は型指定と実装に分けて指定する。型指定は省略が可能である。</p>

<p><section></p>

<pre><code class="haskell double.hs">module Main where

  double :: Integer -&gt; Integer
  double x = x + x
</code></pre>

<p>Main という名前のモジュールに double という関数を定義している。Integer 型の引数を取り Integer 型を返すという型定義をしている。この型定義は省略できる。</p>

<p>Haskell のモジュールは関連するコードを同じスコープ内に集めたもの。Main モジュールは特別なモジュールでトップレベルのモジュールになる。</p>

<p></section></p>

<h3>ガードを使った関数の定義</h3>


<p>再帰を利用した階乗計算を行う関数を定義する。</p>

<pre><code class="haskell">module Main where

 factorial :: Integer -&gt; Integer
 factorial x
   | x &gt; 1 = x * factorial (x - 1)
   | otherwise = 1
</code></pre>

<p>Haskell ではガードは引数の値を制限する条件として使われる。ガードはパターンマッチング代わりに利用される。</p>

<h3>タプル</h3>


<p>Haskell のタプル（固定要素のコレクション）はカンマで区切った要素を括弧で囲む。</p>

<pre><code class="haskell">(1, 2, 3)
</code></pre>

<h3>リスト</h3>


<p>Haskell のリストは [] を使う。</p>

<pre><code class="haskell">let (h:t) = [1, 2, 3, 4]
h
-- =&gt; 1
t
-- =&gt; [2,3,4]
</code></pre>

<p><em>let</em> はローカルスコープ内で変数を関数にバインドする。(h:t) という表記は Prolog の[Head|Tail]  構文と同じでリストを分割する。: はリストを作成するときにも使える</p>

<pre><code class="haskell">1:[2, 3]
-- =&gt; [1,2,3]
</code></pre>

<p>リスト内包表記は、Erlang と同じように使える。</p>

<pre><code class="haskell">[x * 2 | x &lt;- [1, 2, 3]]
-- =&gt; [2,4,6]
</code></pre>

<h3>無名関数</h3>


<p>Haskell で無名関数を定義するには <em><code>(＼param1 .. paramn) -&gt; body)</code></em> と書く。</p>

<pre><code class="haskell">(＼x -&gt; x) "hemasyou"
-- =&gt; "hamasyou"
</code></pre>

<h3>部分適用関数とカリー化</h3>


<p>Haskell のすべての関数は一つの引数を取る。Haskell において2つの引数をとる関数は、1つの引数をとり「1つの引数をとる関数」を返す関数同義である。</p>

<p>このように、関数を返すことですべての関数を1つの引数をとる関数として表現することを<em>カリー化</em>と呼ぶ。</p>

<p>次の例は引数を2つとってそれぞれをかけたものを返す関数である。</p>

<pre><code class="haskell">let prod x y = x * y
prod 3 4
-- =&gt; 12
</code></pre>

<p>この関数は、次のように動作する。</p>

<ul><li><code>prod 3</code> を実行して <code>(＼y = 3 * y)</code> という関数を返す</li>
<li><code>(＼y = 3 * y) 4</code> を実行して12を得る</li></ul>




<h3>クラス</h3>


<p>Haskell の<em>クラス</em>は、入力に応じてどの演算が実行可能かを定義したものである。Clojure のプロトコルと同じ。</p>

<h3>モナド</h3>


<p><em>モナド</em>は特別なやり方で複数の関数を組み合わせるための方法である。Haskell は純粋関数型言語なので命令形式で問題を表現したりプログラムの実行結果を蓄積したりする処理が難しくなる。モナドは関数をラップして数珠つなぎにする型構成子である。</p>

<p>モナドは基本的には3つの要素で構成される。</p>

<ul><li>コンテナとなるものの型を変数に取る型構成子。どのコンテナを選ぶかはモナドで何を実行するかによって異なる。</li>
<li>関数をラップしてコンテナに格納する return という名前の関数。</li>
<li>関数をラップする &gt;&gt;=（バインド）と言う名前の関数。バインドを使って関数を数珠つなぎにする。</li></ul>


<p><a href="http://www.sampou.org/haskell/a-a-monads/html/" rel="external nofollow">モナドのすべて - All About Monads</a></p>
]]></content>
  </entry>
  
</feed>
