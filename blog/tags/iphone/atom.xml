<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: iPhone | それはBooks]]></title>
  <link href="http://hamasyou.com/blog/tags/iphone/atom.xml" rel="self"/>
  <link href="http://hamasyou.com/"/>
  <updated>2014-02-14T19:41:23+09:00</updated>
  <id>http://hamasyou.com/</id>
  <author>
    <name><![CDATA[hamasyou]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Titanium Alloy でつくったアプリをリリースしました]]></title>
    <link href="http://hamasyou.com/blog/2013/01/22/titanium-alloy/"/>
    <updated>2013-01-22T11:22:00+09:00</updated>
    <id>http://hamasyou.com/blog/2013/01/22/titanium-alloy</id>
    <content type="html"><![CDATA[<p>Titanium Mobile プラットフォームの開発元である Appcelerator が公開している公式のフレームワーク <strong>Alloy</strong> を使って作ったアプリを公開しました。</p>

<p>アプリ紹介ページは下になります。
<a href="http://mountposition.co.jp/obento/" rel="external nofollow">Thankお弁当: http://mountposition.co.jp/obento/</a></p>

<p><img alt="phones.png" src="http://hamasyou.com/images/phones.png" width="324" height="367" class="mt-image-none" style="" /></p>

<p>Titanium Mobile は JavaScript を使ってスマホアプリを開発できるプラットフォームです。iPhone や Android 向けのアプリを手軽に開発することが出来ます。</p>

<p>Alloy はそんな Titanium Mobile での開発に規約と規律を導入した MVC フレームワークになります。Ruby On Rails に似てる感じです。</p>

<p>Alloy を使うといろいろいいことがありますが、それはまた別の記事で紹介します。</p>

<p>以上、アプリの宣伝でした！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[cocos2dで作る iPhone＆iPadゲームプログラミング]]></title>
    <link href="http://hamasyou.com/blog/2011/08/17/4844330411/"/>
    <updated>2011-08-17T10:16:00+09:00</updated>
    <id>http://hamasyou.com/blog/2011/08/17/4844330411</id>
    <content type="html"><![CDATA[<p>待望の、<strong>cocos2d</strong> 詳細解説本がでました！ 本書を読めば、cocos2d のすべてが分かると言ってもいいんじゃないかというぐらい幅広く詳しく cocos2d のことが書いてあります。</p>

<p>本書は、cocos2d を使ってゲームアプリをつくりながら、cocos2d の機能や cocos2d を使ってゲームアプリを開発する際の手順、こういうふうに設計したら cocos2d ではうまくいくというような事を解説しています。</p>

<p>cocos2d は Objective-C で書かれていて、ゲームアプリも Objective-C を使って作ります。cocos2d が内部に OpenGL-ES を隠してくれているので、すごく簡単に 2D ゲームを作ることができるようになります。</p>

<p>iPhone 用のゲームアプリを作ってみたいがどうやって作ればいいのかわからない人、どのフレームワークを使えばいいか迷っている人に、特におすすめです。</p>

<p>僕の持っている版は cocos2d のバージョン 0.99.5 が解説されています。</p>

<p><section></p>

<p><i class="fa fa-search"></i> <a href="http://www.cocos2d-iphone.org/" rel="external nofollow">cocos2d for iPhone</a></p>

<p></section></p>

<!-- more -->




<h2>各章の紹介</h2>


<p>本書第1章の概要から、各章の紹介の抜粋です。（一部、誤訳や説明の抜けがあったので補足しています）</p>

<dl><dt>第２章　プログラミングを始めるための準備</dt>
<dd><p>cocos2d を使って開発を行うための準備、プロジェクトテンプレートのインストール、最初の「Hello World」プロジェクトの作成について説明します。ここでは、<em>シーンやノードといった cocos2d の基礎</em>を学びます。</p></dd>
<dt>第３章　基礎</dt>
<dd><p><em>Sprite、Transition、Action など、最もよく使われる cocos2d の基本クラス</em>と、そしてもちろん、それらの使用法について説明します。</p></dd>
<dt>第４章　初めてのゲーム</dt>
<dd><p>これは、あなたが初めて作るゲームとなります。ゲーム内容は、画面上から降ってくる敵をデバイスを傾けてかわします。<em>傾きを加速度センサーから取得する方法</em>についても学びます。</p></dd>
<dt>第５章　ゲームの構成要素</dt>
<dd><p>ゲームの規模が大きくなればなるほど、よりしっかりとしたコード構成が必要になります。心の準備はできているでしょうか。ここでは、<em>シーンとノードが階層化される仕組み</em>と、<em>ゲームオブジェクトの間で情報を交換するためのさまざまな方法</em>を取り上げます。</p></dd>
<dt>第６章　スプライトの詳細</dt>
<dd><p><em>テクスチャアトラスとは何</em>か、それを次のゲームに使うのはなぜかについて説明し、Zwoptex ツールを使ってテクスチャアトラスを作成する方法を紹介します。</p></dd>
<dt>第７章　スクロールを使った処理</dt>
<dd><p>テクスチャアトラスの準備ができたところで、<em>タッチ入力によって制御されるパララックススクロール対応</em>のシューティングゲームの実装方法を紹介します。</p></dd>
<dt>第８章　アクションとアニメーションの処理</dt>
<dd><p>シューティングゲームを作る際には、敵がいないとゲームとして成立しません。この章では、<em>敵の大軍を生成するコードとともに、移動、攻撃、アニメーションの作成を行うためのゲームプレイコードを追加する方法</em>を紹介します。</p></dd>
<dt>第９章　パーティクル効果</dt>
<dd><p>ParticleDesigner ツールを使って、横にスクロールするゲームに<em>パーティクル効果を追加</em>します。</p></dd>
<dt>第１０章　タイルマップの処理</dt>
<dd><p>ここで一気に弾みをつけましょう。横にスクロールするゲームから学んだことを<em>横向きモードに応用</em>し、これも人気の高い iOS ゲームジャンルのゲームを作成します。</p></dd>
<dt>第１１章　等角タイルマップ</dt>
<dd><p><em>cocos2d は TMX ファイルフォーマットをサポートしている</em>ため、ここでは Tiled エディタを使ってタイルベースのゲームを作成する方法について見ていきます。</p></dd>
<dt>第１２章　物理エンジン</dt>
<dd><p>指先の動きで目的の場所を指し示す --- ここでは、この機能がどのようにして実現されるのかを示します。<em>Chipmunk と Box2D の2つの物理エンジンを紹介</em>し、それらを驚きの手法で実装します。</p></dd>
<dt>第１３章　ピンボールゲーム</dt>
<dd><p>重力のない宇宙空間で惑星が跳ね返るボールシューティングに実際の物理学を応用します。ゲームの内容は非現実的ですが、この章で扱う物理計算は、公式そのものです。難しい箇所がありますが、面白いので是非読んでください。</p></dd>
<dt>第１４章　Game Center</dt>
<dd><p><em>Game Center と Game Kit API を利用してプレイヤーの認証、スコアの記録、Leaderboard の表示を行う方法</em>について見ていきます。</p></dd>
<dt>第１５章　非凡であれ</dt>
<dd><p>以上が本書の内容ですが、ご心配なく。あなたの旅はここで終わりません。ここからどこへ進めばよいかのヒントがここにあります。</p><dd>
</dl>




<h2>本書の感想</h2>


<p>僕は、Objective-C を使ってゲームを作りたいと思っていたときに cocos2d に出会いました。当時は cocos2d の公式HPくらいしか cocos2d に関する情報が載っておらず、プログラミングをしていて cocos2d の使い方はこれでいいのかな？というようなところが結構ありました。</p>

<p>当時、試行錯誤してたどり着いたコードが、今手元の本のサンプルに書いてあり、どうしてこういうコードを書くのかという説明がされています。あの時、この本が欲しかった！！ほんとにそう思える、cocos2d の詳細解説本になっています。</p>

<p>cocos2d に興味がある人、ちょっと触ってみてみようかなという人は、是非本書を呼んでみてください。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[iOS] Game Center を使った対戦プログラミングの手順メモ]]></title>
    <link href="http://hamasyou.com/blog/2011/08/04/iosgame-center/"/>
    <updated>2011-08-04T11:38:00+09:00</updated>
    <id>http://hamasyou.com/blog/2011/08/04/iosgame-center</id>
    <content type="html"><![CDATA[<p>iOS 4.1 から、正式に <em>Game Center</em> が使えるようになりました。Game Center を使うと、ゲームに簡単に対戦やスコア、達成目標などの機能を追加できます。</p>

<p><blockquote><p>Game Centerは、プレー中のゲームについての情報をプレーヤー同士で共有したり、ほかのプレー ヤーと一緒にマルチプレーヤー対戦に参加できるソーシャルゲーミングサービスです。Game Center は、ワイヤレスネットワークと携帯電話ネットワークのどちらからでもサービスを提供できます。 Game Centerの主な機能は、次の通りです。</p></p><p><ul><li><em>認証</em> - プレーヤーはGame Centerでセキュアなアカウントを作成し、iOSベースのデバイスでGame Centerにアクセスできます。</li><br/><li><em>友だち</em> - プレーヤーはGame Centerのほかのプレーヤーを友だちとして登録できます。友だちは、最近遊んだゲームなどプレーヤーの詳細情報を確認できます。</li><br/><li><em>Leaderboard</em> - プレーヤーのスコアをGame Centerに記録したりGame Centerから取得したりできます。<br/><li><em>アチーブメント(Achievement、成績)</em> - そのゲームでのプレーヤーのアチーブメントを管理します。アチーブメントは、Game Centerサービスに記録され、Game Centerアプリケーションとゲームの中で閲覧できます。</li><br/><li><em>オートマッチ</em> - Game Centerを介して複数のプレーヤーとつながるネットワークゲームを作成できます。プレーヤーは友だちを招待したり、まだ会ったことのないプレーヤーと接続して対戦できます。プレーヤーは、ゲームを実行していないときでも対戦への招待を受信できます。その場合、ゲームが自動的に起動し、招待が処理されます。</li><br/><li><em>ボイス</em> - 対戦に接続されたプレーヤー間で音声通信を行うことができます。</li></ul></p><p><br/><p></p><footer><strong>『Game Kit プログラミングガイド』より</strong></footer></blockquote></p>

<p>Game Center を使うためのプログラミングは形式的ながら、視点が二つ（自分と対戦相手）あるため、どの機能が何に当たるのかを理解していないと混乱しがちです。</p>

<p>本記事は、自分で Game Center を使ったアプリを作ったときの、メモをまとめたものです。</p>

<p><section></p>

<h4>開発時の環境</h4>




<dl><dt>iOS SDK バージョン</dt><dd>4.3</dd>
<dt>クライアント iOS バージョン</dt><dd>自分: iOS 4.3.2 &nbsp;&nbsp;対戦相手: iOS 4.3.5</dd></dl>


<p></section></p>

<!-- more -->




<h2>Game Center を使った対戦機能開発のメモ</h2>


<p>Game Center を使ったアプリの開発手順は、<a href="http://developer.apple.com/jp/devcenter/ios/library/documentation/GameKit_Guide.pdf" rel="external nofollow">『Game Kit プログラミングガイド』</a> - Apple Developer（PDF）に詳しく載っています。わかりやすい説明で読めば大体理解できると思います。対戦相手とのマッチングの部分だけ、自分と相手がいるのと、非同期で処理がされていくためどのメソッドがどの役割かが最初は混乱するかもしれません。</p>

<p>Leaderboard とアチーブメントはたぶん、そんなに混乱しないはず。</p>

<h2>用語のまとめ</h2>




<dl>
<dt>プレイヤー</dt>
<dd>
<p>Game Center でプレイヤーとは、<strong>GKPlayer</strong> クラスで表される Game Center で認証されたユーザのことを指します。GKPlayer インスタンスの <em>alias</em> プロパティでプレイヤーのニックネームを取得できます。</p>

<p>端末上で認証したプレイヤーのこと（自分自身）を特に <strong>GKLocalPlayer</strong> クラスで表します。GKLocalPlayer からは友だちの一覧などの情報を取得できます。</p>
</dd>
<dt>マッチメイク</dt>
<dd>
<p>対戦相手を探す機能のことです。対戦相手は友だちへのゲーム招待（相手に PUSH 機能で通知がいく）と自動マッチングで探すことができます。</p>

<p>当然ですが、一つのアプリで、招待機能（<em>Request</em>）と招待受理機能（<em>Invite</em>）を実装する必要があります。</p>
</dd>
<dt>GKMatchRequest</dt>
<dd><p>対戦相手を探す際の対戦要求を表すクラス。対戦相手の人数など、細かな条件を設定できます。</p></dd>
<dt>GKInvite</dt>
<dd><p>対戦要求によって招待されたことをあわらすクラスです。</p></dd>
<dt>GKMatch</dt>
<dd><p>マッチングされたネットワークセッションを表すクラスです。このオブジェクトに対してデータを送ることで、通信相手にデータが届きます。</p></dd>
</dl>




<h2>Game Center を使ったプログラミングの手順</h2>


<p>Game Center を使ったプログラミングの流れは次のようになります。</p>

<ol>
<li>Game Center が利用可能かどうかを確認する。一度確認すればよい。[<a href="#title4" rel="external nofollow">コード</a>]</li>
<li>アプリケーション起動時に、できるだけはやく Game Center への認証を済ませる。これは、その後のゲーム招待を処理するために必要。[<a href="#title5" rel="external nofollow">コード</a>]</li>
<li>認証が済んだら、ゲーム招待を処理するハンドラを登録する。<em>ゲーム招待を受理してアプリが起動された場合はアプリのトップ画面が表示されるので、アプリのトップで Game Center の認証を行い、続けてゲーム招待を処理するハンドラを登録するべき。</em>そうしないと、せっかくの招待が無駄になる。[<a href="#title6" rel="external nofollow">コード</a>]</li>
<li>自分で対戦要求を作成する場合は、<strong>GKMatchRequest</strong> を作成してマッチメイク画面を開く。招待された側は、ゲーム招待処理ハンドラが呼び出されて、ゲーム招待（<strong>GKInvite</strong>）を利用してマッチメイク画面を開く。[<a href="#title7" rel="external nofollow">コード</a>]</li>
<li>自分で対戦相手を探す場合は、対戦要求を作成する。[<a href="#title8" rel="external nofollow">コード</a>]</li>
<li>対戦相手が決まったら、コールバックメソッドを実装して対戦を開始する。[<a href="#title9" rel="external nofollow">コード</a>]</li>
<li>対戦相手を自動で決める場合は <strong>GKMatchmaker</strong> の findMatchForRequest メソッドを利用する。（後で書く）</li>
<li>対戦が開始されたら、<strong>GKMatch</strong> に対してデータを送ることで通信ができる。[<a href="#title10" rel="external nofollow">コード</a>]</li>
<li>通信を受け取るには、<strong>GKMatchDelegate</strong> プロトコルを実装し、GKMatch の delegate に設定する。[<a href="#title11" rel="external nofollow">コード</a>]</li>
</ol>




<h2>プログラミングコードの断片</h2>




<h3>Game Center が利用出来るかどうか</h3>


<p>SDK が Game Center に対応しているか（GKLocalPlayer クラスが参照できるかで確認）と iOS が 4.1 以降であるかを確認する。</p>

<p>Game Center が利用出来るかどうかは、最初の一度だけ行えば良い。すなわち、メンバ変数にキャッシュできる。以降、gameCenterAvailable 変数がそれ。</p>

<pre><code class="objective-c">- (BOOL)isGameCenterAvailable
{
  // Test for Game Center availability
  Class gameKitLocalPlayerClass = NSClassFromString(@"GKLocalPlayer");
  BOOL localPlayerAvailable = (gameKitLocalPlayerClass != nil);

  // Test if device is running iOS 4.1 or higher
  NSString *requireSysVer = @"4.1";
  NSString *currentSysVer = [[UIDevice currentDevice] systemVersion];
  BOOL isOSVer41 = ([currentSysVer compare:requireSysVer options:NSNumericSearch] != NSOrderedAscending);

  return localPlayerAvailable &amp;&amp; isOSVer41;
}
</code></pre>

<h3>Game Center の認証</h3>


<p>authenticateWithCompletionHandler メソッドで Game Center を使って認証できる。認証済みでない場合は、認証ダイアログが表示される。</p>

<p>認証が済んだら、できるだけはやくゲーム招待を処理するためのハンドラを登録する。</p>

<pre><code class="objective-c">- (void)authenticateLocalPlayer
{
  if (gameCenterAvailable) {
    GKLocalPlayer *localPlayer = [GKLocalPlayer localPlayer];
    if (!localPlayer.authenticated) {
      [localPlayer authenticateWithCompletionHandler:^(NSError *error) {
        self.error = error

        if (error == nil) {
          // ゲーム招待を処理するためのハンドラを設定する
          [self initMatchInviteHandler];
        }
      }];
    }
  }
}
</code></pre>

<h3>ゲーム招待を処理するハンドラを登録する</h3>


<p><strong>GKMatchmaker</strong> の inviteHandler にブロックを渡すことで、招待が処理された際にコールバックされるようになる。</p>

<p><blockquote><p></p></p><p><ul><li>acceptedInviteパラメータは、ゲームが別のプレーヤーから直接招待を受け取るとnil以外の値になります。この場合は、ほかのプレーヤーのゲームがすでに対戦要求を作成しています。 そのため、招待された側のデバイスで実行しているアプリケーションで対戦要求を作成する必要はありません。</li><br/><li>playersToInviteパラメータは、対戦をホストするGame Centerアプリケーションから直接ゲームが起動されるとnil以外の値になります。このパラメータは、ゲームが対戦に招待すべきプレーヤーを示したプレーヤー識別子の配列を保持します。ゲームは新しい対戦要求を作成し、 通常通りにパラメータを割り当ててから、対戦要求のplayersToInviteプロパティをplayersToInviteパラメータで渡された値に設定する必要があります。マッチメーク画面が表示されると、すでに対戦に参加しているプレーヤーのリストがあらかじめ読み込まれます。</li><br/></ul></p><p><br/><p></p><footer><strong>『Game Kit プログラミングガイド』より</strong></footer></blockquote></p>

<pre><code class="objective-c">- (void)initMatchInviteHandler
{
    if (gameCenterAvailable) {
    [GKMatchmaker sharedMatchmaker].inviteHandler = ^(GKInvite *acceptedInvite, NSArray *playersToInvite) {
      // 既存のマッチングを破棄する
      self.currentMatch = nil;

      if (acceptedInvite) {
        // ゲーム招待を利用してマッチメイク画面を開く
        [self showMatchmakerWithInvite:acceptedInvite];
      } else if (playersToInvite) {
        // 招待するユーザを指定してマッチメイク要求を作成する
        GKMatchRequest *request = [[[GKMatchRequest alloc] init] autorelease];
        request.minPlayers = 2;
        request.maxPlayers = 2;
        request.playersToInvite = playersToInvite;

        [self showMatchmakerWithRequest:request];
      }
    };
  }
}
</code></pre>

<h3>マッチメイク画面を開く</h3>


<p>マッチメイク画面を開くには、ViewController が必要。マッチメイク要求（Request）かゲーム招待（Invite）かどちらかを使ってマッチメイク画面を開く。</p>

<p>インターフェースはほとんど同じになる。</p>

<pre><code class="objective-c">- (void)showMatchmakerWithRequest:(GKMatchRequest *)request
{
  GKMatchmakerViewController *viewController = [[[GKMatchmakerViewController alloc] initWithMatchRequest:request] autorelease];
  viewController.matchmakerDelegate = self;
  [self presentModalViewController:viewController animated:YES];
}

- (void)showMatchmakerWithInvite:(GKInvite *)invite
{
  GKMatchmakerViewController *viewController = [[[GKMatchmakerViewController alloc] initWithInvite:invite] autorelease];
  viewController.matchmakerDelegate = self;
  [self presentModalViewController:viewController animated:YES];
}
</code></pre>

<h3>自分で対戦要求を作成する場合</h3>


<p>自分で対戦要求を作成する場合は、<strong>GKMatchRequest</strong> を作って、マッチメイク画面を表示する。</p>

<p>対戦要求は任意のタイミングで作成すればよい。例えば、メニューで「ふたりで対戦する」ボタンが押されたとき等。</p>

<pre><code class="objective-c">- (void)requestMatch
{
  GKLocalPlayer *localPlayer = [GKLocalPlayer localPlayer];
  if (localPlayer.authenticated) {
    // 対戦相手を決める
    GKMatchRequest *request = [[[GKMatchRequest alloc] init] autorelease];
    request.minPlayers = 2;
    request.maxPlayers = 2;

    [self showMatchmakerWithRequest:request];
  }
}
</code></pre>

<h3>対戦相手が決まった際に呼び出されるコールバック</h3>


<p>対戦相手が決まるたびに、呼び出されるコールバックメソッド。これは <strong>GKMatchmakerViewController</strong> の matchmakerDelegate を経由して呼び出される。</p>

<p>コールバックを受け取るには、<strong>GKMatchmakerViewControllerDelegate</strong> プロトコルを実装している必要がある。</p>

<p>matchStarted はゲームがスタートしているかどうかを表すメンバ変数。<em>match.expectedPlayerCount</em> は対戦要求にあと何人の必要プレイヤーがいるかを表す値。0になれば、必要なプレイヤーが揃ったことになる。</p>

<pre><code class="objective-c">- (void)matchmakerViewController:(GKMatchmakerViewController *)viewController didFindMatch:(GKMatch *)match
{
  [self dismissModalViewController];
  self.currentMatch = match;

  // 全ユーザが揃ったかどうか
  if (!matchStarted &amp;&amp; match.expectedPlayerCount == 0) {
    matchStarted = YES;
    // ゲーム開始の処理
  }
}
</code></pre>

<h3>対戦相手にデータを送る</h3>


<p>対戦相手がきまり、現在の通信セッションを表す <strong>GKMatch</strong> が取得できたら、GKMatch に対して sendDataToAllPlayers メソッドを呼び出してデータを送信する。</p>

<p>これによって対戦相手にデータが送られる。</p>

<p>GKMatchSendDataUnreliable モードは、いわゆる UDP で送信するイメージ。GKMatchSendDataReliable モードは TCP で送るイメージ。通常は GKMatchSendDataUnreliable でよいはず。</p>

<p>データの内容や型は、アプリ側で好きに決めることができる。ほとんどの場合、カスタムの構造体を作成してデータを送信する。構造体を作れば、sizeof(myData) でバイトサイズを取得できる。</p>

<pre><code class="objective-c">- (void)sendDataToAllPlayers:(void *)data sizeInBytes:(NSUInteger)sizeInBytes
{
  if (gameCenterAvailable) {
    NSError *error = nil;
    NSData *packetData = [NSData dataWithBytes:data length:sizeInBytes];
    [currentMatch sendDataToAllPlayers:packetData withDataMode:GKMatchSendDataUnreliable error:&amp;error];
    self.error = error;
  }
}
</code></pre>

<h3>対戦相手からデータを受け取る</h3>


<p>対戦相手からデータを受け取るには、GKMatch のデリゲートに GKMatchDelegate を実装したインスタンスを割り当てます。</p>

<p>対戦相手からデータを受け取った場合には、次のコールバックメソッドが呼び出されます。</p>

<pre><code class="objective-c">- (void)match:(GKMatch *)match didReceiveData:(NSData *)data fromPlayer:(NSString *)playerID
{
  // データを受け取ってアプリで利用する
}
</code></pre>

<h2>対戦機能をテストする方法</h2>


<p>Game Center の機能をテストするために、Apple はサンドボックス環境を用意してくれています。サンドボックス環境は、シミュレータ上でも実機でもどちらでも使うことができます。</p>

<p>ただし、<strong>シミュレータ上ではマッチメイクの招待の送受信はできません。</strong>マッチメイクのテストをするには、実機を二台用意する必要があります。</p>

<p>実機を二台用意したら次の手順でテストできます。</p>

<ol>
<li>iTunes Connect にアプリを登録して、Game Center 機能を有効にする。<a href="https://itunesconnect.apple.com/docs/iTunesConnect_DeveloperGuide_JP.pdf" rel="external nofollow">『iTuens Connect デベロッパガイド』</a>参照</li>
<li>実機を二台用意する。</li>
<li>それぞれの実機にテストアプリをインストールする。（Xcode 上でデバッグビルドで起動すれば入る）</li>
<li>サンドボックス環境にスイッチするために、テストアプリ内から認証機能を実行する。</li>
<li>アプリを閉じて、Game Center アプリを立ち上げ、サンドボックス環境であることを確認して友だちを招待する</li>
<li>もう一台の実機のほうでもサンドボックス環境にスイッチし、Game Center アプリを開き友だちリクエストを承認する</li>
<li>アプリに戻り、マッチメイク機能をテストする</li>
</ol>




<p class="option">マッチメイクの招待には PUSH 配信を利用するので、実機で Game Center の通知機能をオンするのを忘れずに。</p>




<h3>サンドボックス環境にスイッチする</h3>


<p>もし、すでに Game Center にサインインしている場合は、一度 Game Center アプリを起動して、サインアウトしておきます。</p>

<p>アプリを立ち上げて、認証機能を実行すると、下の図のようなダイアログが表示されます。</p>

<p><img alt="Game Center 認証画面" src="http://hamasyou.com/images/%E5%86%99%E7%9C%9F.PNG" width="320" height="480" class="mt-image-none" style="" /></p>

<p>Game Center のアカウントを持っていない場合は、ここで開発用のアカウントを作成します。すでに持っている場合は、Use Existing Account を選択して、既存のアカウントでサインインします。</p>

<p>サンドボックス環境と通常の環境とのスイッチは、開発中のアプリケーションでサインインしたかどうかで決まります。アカウントは同じものを使えます。</p>

<p>サンドボックス環境にスイッチできたかどうかは、一度アプリを終了させ、Game Center アプリを起動することで確認できます。</p>

<p><img alt="GameCenterサンドボックス" src="http://hamasyou.com/images/%E5%86%99%E7%9C%9F%20%281%29.PNG" width="320" height="480" class="mt-image-none" style="" /></p>

<h3>サンドボックス環境で友だちを招待する</h3>


<p>サンドボックス環境の Game Center アプリから、友だちリクエストを送ります。このリクエストは、サンドボックス環境内のアカウントに対して送信されるため、 相手もサンドボックス環境にスイッチする必要があります。</p>

<p>二台目の実機のほうもサンドボックス環境にスイッチして、Game Center アプリを起動すると、リクエストタブに友だちリクエストが着ているはずです。</p>

<h3>サンドボックス環境でマッチメイク機能をテストする</h3>


<p>二台ともサンドボックス環境にスイッチできたら、ゲーム内から友だちを招待して対戦機能をテストできます。</p>

<p>下の図は、<a href="#title8" rel="external nofollow">requestMatch</a> メソッドを呼び出した時の画面です。</p>

<p><img alt="Game Center マッチメイク画面" src="http://hamasyou.com/images/%E5%86%99%E7%9C%9F%20%282%29.PNG" width="320" height="480" class="mt-image-none" style="" /></p>

<h2>cocos2d 本おすすめ</h2>




<div class="bookInfo"> 
<div class="bookImg"> 
<a href="http://www.amazon.co.jp/gp/product/4844330411?ie=UTF8&tag=sorehabooks-22&linkCode=xm2&camp=247&creativeASIN=4844330411" rel="external nofollow"></a> 
</div> 
<ul><li><a href="http://www.amazon.co.jp/gp/product/4844330411?ie=UTF8&tag=sorehabooks-22&linkCode=xm2&camp=247&creativeASIN=4844330411" rel="external nofollow"></a></li><li>Steffen Itterheim (著), 畑 圭輔 (監修), 坂本 一樹 (監修), 加藤 寛人 (監修), 高丘 知央 (監修), 株式会社 クイープ (翻訳) </li><li>インプレスジャパン</li></ul> 
<div class="clear"></div> 
</div>


<p>cocos2d は Objective-C で書かれたゲームエンジン、フレームワークです。2D ゲームを作成するに当たっての結構簡単にわかりやすい機能を提供してくれます。</p>

<p>cocos2d は最近 Version 1.0 が正式にリリースされました。<em>OpenGL ES</em> のコードを隠していながら、UIViewController も提供してくれるようになったため、Game Center を使ったアプリともスムーズに連携できるようになりました。</p>

<p>また、『<a href="http://www.amazon.co.jp/gp/product/4844330411?ie=UTF8&tag=sorehabooks-22&linkCode=xm2&camp=247&creativeASIN=4844330411" rel="external nofollow">cocos2dで作る iPhone＆iPadゲームプログラミング</a>』の中にも1章まるまるつかって、Game Center を使ったプログラミングの解説がされています。</p>

<p>おすすめの一冊です。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Titanium Mobileで開発するiPhone/Androidアプリ (Smart Mobile Developer)]]></title>
    <link href="http://hamasyou.com/blog/2011/06/18/4798123986/"/>
    <updated>2011-06-18T10:01:00+09:00</updated>
    <id>http://hamasyou.com/blog/2011/06/18/4798123986</id>
    <content type="html"><![CDATA[<p>本書は、スマートフォンアプリ開発に使う開発ツールを探している人、<strong>Titanium Mobile</strong> という名前を聞いたことがあるけど実際にどういうものかを知りたい人、Titanium Mobile を使って開発を始めたけどこういう書き方で合っているのか不安な人向けの、概要書兼リファレンスブック的な位置づけにあたります。</p>

<p><section></p>

<h4>Titanium Mobile</h4>


<p><a href="http://www.appcelerator.com/products/titanium-mobile-application-development/" rel="external nofollow">Titanium Mobile - Appcelerator</a></p>

<p></section></p>

<p>Titanium Mobile を開発、提供している Appcelerator が用意してくれている Web 上のドキュメントは、Titanium Mobile を始めたばかりの人には分かりづらく、「こういうことがしたいんだけどどう書けばいいの？」という時には使いづらいのです。</p>

<p>本書は、そんな Titanium Mobile のドキュメントの弱さを補い、Titanium Mobile とはどういうふうに動作しているのか、こういうことをするときはどう書けばいいのかを学ぶのに最適な本です。</p>

<p>iPhone、Android 向けスマートフォンアプリとはいえ、プラットフォーム SDK が備える機能はとても豊富です。これらの SDK を JavaScript から扱えてしまう Titanium Mobile をよくここまでまとめたなぁという印象の良書です。</p>

<div class="option"><p>スマートフォン開発は、Windows や Mac などの GUI アプリケーションと同様、イベントドリブンモデルの開発になります。そのため、GUI アプリ開発の経験がない人には Titanium Mobile を使って JavaScript で開発を行うと、どうしても戸惑うことが出てくると思います。</p>

<p>本書をとりあえず読んでみて、<em>Titanium Mobile 上で JavaScript で GUI 開発（スマートフォンアプリ開発）ってこういうふうにするんだ</em>というのを体感してもらい、リファレンスとしてのお供にされるといいと思います。</p></div>


<p>本書の対象者は、<em>Titanium Mobile を使って開発を始めたい人、実際に開発を始めたがまとまった情報がほしい人</em>です。Titanium Mobile を使ってとにかく何か作ってみたいひとは、本書内のサンプルを写経してみるといいと思います。</p>

<p>Titanium Mobile を使って開発をしてみたものの、不安が残っている人に最適な一冊です。</p>

<!-- more -->




<h2>本書の目次</h2>




<ol>
<li>Appcelerator Titanium Mobile について
  <ol>
  <li>Appcelerator 社と Titanium シリーズ</li>
  <li>Titanium Mobile について
    <ol class="fontSmall">
    <li>Titanium Mobile が提供する機能</li>
    <li>Titanium Mobile の動作原理</li>
    <li>オープンソース開発されている Titanium Mobile </li>
    <li>日本で注目を集める Titanium Mobile</li>
    <li>今後のロードマップ</li>
    </ol>
  </li>
  <li>価格体系／ライセンス</li>
  <li>Titanium Mobile を利用するのに必要な環境
    <ol class="fontSmall">
      <li>iOS には Mac OS X 環境が必要</li>
      <li>Android 開発について</li>
    </ol>      
   </li>
   <li>ネイティブアプリケーション開発で代替手段を選択するリスク</li>
   </ol>
</li>
<li>開発環境導入とアプリケーションの第一歩
  <ol>
  <li>iOS 用開発環境の構築
    <ol class="fontSmall">
      <li>iOS SDK と Xcode</li>
      <li>IOS Developer Program の登録</li>
    </ol>
  </li>
  <li>Android 用開発環境の構築
    <ol class="fontSmall">
      <li>JDK の確認と Android SDK の入手</li>
      <li>Mac OS への導入</li>
      <li>Windows7 へのインストール</li>
    </ol>
  </li>
  <li>Titanium Developer のインストール
    <ol class="fontSmall">
      <li>Mac OS X の場合</li>
      <li>Windows7 の場合</li>
      <li>Titanium Developer の起動とサインアップ</li>
    </ol>
  </li>
  <li>Titanium Developer の画面解説
    <ol class="fontSmall">
      <li>パースペクティブ</li>
      <li>最新版 SDK のアップデート</li>
    </ol>
  </li>
  <li>Hello World プロジェクトの作成
    <ol class="fontSmall">
      <li>プロジェクトの新規作成</li>
      <li>iPhone(iPod touch)の場合</li>
      <li>Andorid の場合</li>
      <li>iPad の場合</li>
    </ol>
  </li>
  <li>Hello World プロジェクトを実機で動かす
    <ol class="fontSmall">
      <li>iOS(iPhone/iPad/iPod touch)の場合</li>
      <li>Android の場合</li>
    </ol>
  </li>
  <li>プロジェクトの中を探索する
    <ol class="fontSmall">
      <li>プロジェクトのフォルダ構成</li>
      <li>app.js の解説</li>
      <li>プラットフォームによる UI の違い</li>
    </ol>
  </li>
  <li>ネイティブ UI の部品紹介と KitchenSink
    <ol class="fontSmall">
      <li>ネイティブ UI の部品カタログ</li>
      <li>KitchenSink とは何か？</li>
    </ol>
  </li>
  <li>Hello World の中身をいじってみる
    <ol class="fontSmall">
      <li>win1 に機能を追加する</li>
      <li>win2 に機能を追加する</li>
      <li>Tab を使わない画面デザイン</li>
      <li>WebView を用いた HTML5 アプリケーション</li>
    </ol>
  </li>
  <li>アプリケーションアイコン／スプラッシュスクリーンを変更
    <ol class="fontSmall">
      <li>アプリケーションアイコン</li>
      <li>スプラッシュスクリーン（起動時画像）</li>
    </ol>
  </li>
  <li>アプリケーションの設定と拡張
    <ol class="fontSmall">
      <li>tiapp.xml</li>
      <li>iOS プラットフォームに依存したビルド</li>
      <li>Android プラットフォームに依存したビルド</li>
    </ol>
  </li>
  </ol>
</li>
<li>実践！ Twitter クライアントアプリ開発
  <ol>
  <li>TiTweets の目標</li>
  <li>プロジェクト作成</li>
  <li>タイムラインの表示
    <ol class="fontSmall">
      <li>HTTP クライアントとネットワークの状態の取得</li>
      <li>ログ出力メソッド</li>
      <li>TableView への表示</li>
      <li>TableViewRow の使用</li>
    </ol>
  </li>
  <li>app.js からスクリプトファイルの分割
    <ol class="fontSmall">
      <li>Titanium.include によるファイル分割</li>
      <li>Titanium.UI.createWindow の url 指定での分割</li>
      <li>ファイル分割と実行コンテキスト</li>
      <li>コンテキスト間の値の受け渡し</li>
      <li>アプリケーションプロパティを用いて実行コンテキストの違いを回避する</li>
    </ol>
  </li>
  <li>プラットフォームごとの再読込 UI の実装
    <ol class="fontSmall">
      <li>iPhoen の場合：ナビゲーションボタンを利用する</li>
      <li>Android の場合：メニューを利用する</li>
      <li>プラットフォームの違いを吸収する</li>
      <li>再読込処理を実装する</li>
    </ol>
  </li>
  <li>検索結果の表示を行う
    <ol class="fontSmall">
      <li>固定したハッシュタグの検索</li>
      <li>任意の検索文字列に基づく検索</li>
      <li>前回検索値の保存</li>
    </ol>
  </li>
  <li>共通ソースのオブジェクト化
    <ol class="fontSmall">
      <li>オブジェクトのひな形</li>
      <li>titwitter.js を実装する</li>
      <li>アプリケーション連携（OpenURL とインテント）</li>
    </ol>
  </li>
  <li>国際化対応（i18N）
    <ol class="fontSmall">
      <li>メッセージ定義ファイルの準備</li>
      <li>メッセージ定義ファイルの使用</li>
      <li>メッセージ中の文字列置き換え</li>
    </ol>
  </li>
  <li>もうすこし機能拡張
    <ol class="fontSmall">
      <li>タブの整理</li>
      <li>Tweet の単独表示</li>
      <li>Read it Later 連携</li>
    </ol>
  </li>
  <li>AppStore / Android Market への公開
    <ol class="fontSmall">
      <li>iOS の場合（Ad Hoc 配布／App Store 公開）</li>
      <li>Android Market への公開</li>
    </ol>
  </li>
  </ol>
</li>
<li>ライブラリやデバイスの活用 <span class="fontSmall">〜続・Twitter クライアントアプリ開発〜</span>
  <ol>
  <li>TinyTweet の目標</li>
  <li>OAuth 認証の設定をする
    <ol class="fontSmall">
      <li>アプリケーションを登録する</li>
      <li>OAuth 認証の動作検証を行う</li>
      <li>ホームタイムラインを取得する</li>
    </ol>
  </li>
  <li>Tweet を Post する
    <ol class="fontSmall">
      <li>TextArea を配置する</li>
      <li>キーボードツールバー（iOS のみ）</li>
      <li>返信機能などに対応する</li>
    </ol>
  </li>
  <li>カメラ撮影／フォトギャラリーの活用
    <ol class="fontSmall">
      <li>カメラ撮影の呼び出し</li>
      <li>撮影済みの写真データの取得</li>
      <li>TwitPic へのアップロード</li>
      <li>画像ファイルのリサイズ（iOS のみ）</li>
      <li>Andriod の場所のキーボードツールバー実現方法</li>
    </ol>
  </li>
  <li>アプリケーションの完成
    <ol class="fontSmall">
      <li>カメラ処理部分をソース分割する（require の活用）</li>
      <li>設定画面を作成する</li>
    </ol>
  </li>
  </ol>
</li>
<li>GPS 活用アプリケーション「食べナビ」
  <ol>
  <li>「食べナビ」における目標</li>
  <li>食べログ API に基づきデータを表示する
    <ol class="fontSmall">
      <li>API の動作検証</li>
      <li>テスト用モックデータ取得処理</li>
      <li>「もっと読む」機能</li>
      <li>店舗情報の出力</li>
    </ol>
  </li>
  <li>位置情報に基づいて地図を表示する
    <ol class="fontSmall">
      <li>地図表示部品 MapView の利用</li>
      <li>tiapps.xml への設定（Android のみ）</li>
      <li>latitudeDelta と longitudeDelta</li>
      <li>Annotation（マーカー／ピンの表示）</li>
    </ol>
  </li>
  <li>GPS で現在地の位置情報を取得する
    <ol class="fontSmall">
      <li>位置情報を取得する GPS 関連 API の利用</li>
      <li>軽遺族的な位置情報の取得</li>
    </ol>
  </li>
  <li>カバーフローによる写真一覧表示（iOSのみ）
    <ol class="fontSmall">
      <li>CoverFlowView</li>
      <li>問い合せ結果との組み合わせ</li>
    </ol>
  </li>
  <li>取得したデータをデータベースに保存する
    <ol class="fontSmall">
      <li>テーブルレイアウトと検証</li>
      <li>データの追加と更新</li>
      <li>お気に入りの表示</li>
      <li>データの削除</li>
    </ol>
  </li>
  </ol>
</li>
<li>Titanium Mobile API 簡易リファレンス
  <ol>
  <li>簡易リファレンスの読み方</li>
  <li>Window と View</li>
  <li>コントロール</li>
  <li>デバイス</li>
  <li>プラットフォーム</li>
  <li>通信</li>
  <li>その他</li>
  </ol>
</li>
<li>Appendix
  <ol style="list-style-type: none;margin-left: 0">
  <li>付録1  モダンな JavaScript コーディングの第一歩</li>
  <li>付録2  自動レイアウトと JSS 機能</li>
  <li>付録3  2DMatrix アニメーション</li>
  <li>付録4  Xib2js による UI 作成</li>
  <li>付録5  開発版ビルド（Continuous Build）を活用する</li>
  <li>付録6  モジュールを使う</li>
  <li>付録7  Titanium Studio</li>
  <li>付録8  Titanium Mobile 困ったときの情報源</li>
  </ol>
</li>
</ol>




<h2>覚書</h2>




<h3>Titanium Mobile の動作原理</h3>


<p>Titanium Mobile は JavaScript でソースコードを記述しますが、動作時には<em>Titanium Mobile の JS インタプリタ上で解釈されて動作します。</em></p>

<p>よく、JavaScript のコードがコンパイルされてネイティブコードに変換されているという誤解をしそうになりますが、そうではありません。</p>

<p>なので、ゲームなどのアニメーションをゴリゴリするようなアプリには、Titanium Mobile の利用は考えたほうが良いです。</p>

<p>Titanium Mobile が向いている分野としては</p>

<ul><li>Web上のサービスをクライアントから利用するアプリ</li>
<li>ちょっとしたユーティリティアプリ</li></ul>


<p>だと思います。（<a href="http://mogsnap.jp/" rel="external nofollow">MogSnap</a> のようなここまで Titanium で出来るのか！？っていうものもありますが）</p>

<h3>Appcelerator 社提供のアイコンリソース</h3>


<p>自分でアプリをつくろうと思ったときに「アイコン画像とか、俺つくれねーーー！！」ってなることがあります。。そんなときに利用出来るのがこれ！</p>

<p>Appcelerator から提供されているアイコンのリソースです。是非ご利用ください。</p>

<p><a href="http://developer.appcelerator.com/blog/2010/12/festivus-celebration-day-two-airing-of-grievances.html" rel="external nofollow">Festivus Celebration Day Two - Airing of Grievances - Appcelerator Developer Blog</a></p>

<h3>実行コンテキスト</h3>


<p>Titanium Mobilde で開発する際、Window ごとの処理を別々のソースコードに切り出すことができます。</p>

<p>このとき、実行コンテキストが分かれます。簡単に言うと、変数のスコープが分かれるというものです。</p>

<p><a href="http://developer.appcelerator.com/blog/2010/08/execution-contexts.html" rel="external nofollow">Understanding Execution Contexts - Appcelerator Developer Blog</a></p>

<h2>本書に書いていないこと</h2>




<h3>モジュールの開発</h3>


<p>Titanium Mobile は、プラットフォーム SDK のネイティブ機能へのラッパーを数多く提供してくれているので、ほとんどのことが Titanium Mobile のコンポーネントの組み合わせだけで行えます。</p>

<p>ただ、たまに、もうちょっとこの部分がこうなっていればいいのに！という、コンポーネントを拡張したい場合があります。</p>

<p>Titanium Mobile にはモジュールという形で、SDK を使って直接ネイティブコードを書いて、それを JavaScript から呼び出すということができます。</p>

<p>モジュールのインターフェースは、Titanium Mobile 上の呼び出し規約に沿った形で作成する必要があります。</p>

<p>モジュールの詳しい作り方は、公式のドキュメントを読むのが手っ取り早いと思います。そんなに難しい英語ではないのですんなり理解できるかと思います。</p>

<p><a href="http://developer.appcelerator.com/doc/mobile/guides" rel="external nofollow">Titanium Mobile Programming Guides - Appcelerator</a></p>

<h3>テスト</h3>


<p>Titanium Mobile での開発は JavaScript で記述したアプリケーションコードが Titanium のインタプリタ上で動くというアーキテクチャになっているため、GUI の実際の動作を確認するのは実機かエミュレータ（シミュレータ）を使う必要があります。</p>

<p>ただ、毎回実行してコードが意図したとおりに動いているかを確認するのは時間がかかります。</p>

<p>そういうことで、実装時には GUI の動作とロジックの部分をできるだけ分けて実装しておいて、下に挙げるようなテストフレームワークを使うよいと思います。</p>

<h4>テストフレームワーク</h4>




<dl><dt>drillbit</dt>
<dd><a href="http://d.hatena.ne.jp/Ehren/20110329/1301417692" rel="external nofollow">Titanium mobile で drillbit動いた - Ehrenの日記</a></dd>
<dt>QUnit</dt>
<dd><a href="http://higelog.brassworks.jp/?p=692" rel="external nofollow">Titaniumでユニットテスト - ひげろぐ</a></dd></dl>




<h3>同期処理のための Deferred</h3>


<p>JavaScript はシングルスレッドアーキテクチャなので、割り込みをコールバックという形で実装しています。</p>

<p>スマートフォンアプリのようなイベントドリブンモデルのプラットフォームでは、ユーザの反応をイベントとして発火し、リスナがそのイベントを処理するというモデルで実装していきます。</p>

<p>つまり、JavaScript で実装すると、イベントリスナをコールバック関数として実装して、イベントハンドラ（GUIコンポーネント）に登録しておくという書き方になります。</p>

<pre><code class="javascript">var button = Titanium.UI.createButton({...});
button.addEventListener(function(e) {
  // 処理
});
</code></pre>

<p>Titanium Mobile で開発をしているとコールバックを多用するため、処理が非同期に進んでしまって、何かのイベントの結果で処理を分岐するという事をしたいときに悩むことがあります。</p>

<p>そんなときは、Deferred を使って非同期処理の待ち合わせを行うとよいです。</p>

<p><a href="http://hamasyou.com/blog/archives/000398" rel="external nofollow">[Titanium] JSDeferred を使って現在位置の取得を順次処理する - それはBlog</a></p>

<h2>追記</h2>




<h3>Titanium Mobile 1.7ならびにTitanium Studio 1.0対応について</h3>


<p>Titanium Mobile1.7、Titanium Studio1.0 がリリースされたことで、本書の2章の内容が現実と合わなくなっています。</p>

<p>著者の方がフォローしてくれていますので、活用してみてください。</p>

<p><a href="http://code.google.com/p/titanium-mobile-doc-ja/downloads/detail?name=TMINTRO_ch02Plus.pdf" target="_blank" class="extlink">Titanium Mobileで開発するiPhone/Androidアプリ 第二章 補完稿 -  <br/>
titanium-mobile-doc-ja</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[WEB+DB PRESS Vol.61]]></title>
    <link href="http://hamasyou.com/blog/2011/02/16/4774145440/"/>
    <updated>2011-02-16T21:49:00+09:00</updated>
    <id>http://hamasyou.com/blog/2011/02/16/4774145440</id>
    <content type="html"><![CDATA[<p><a href="http://www.appcelerator.com/products/titanium-mobile-application-development/" rel="external nofollow"></a> Titanium で始める、iPhone / Android アプリ開発！</p>

<p><a href="http://d.hatena.ne.jp/r_kurain/" rel="external nofollow">マウントポジション</a>とで特集『<em>実践！Titanium JavaScriptでiPhone/Android本格アプリ開発</em>』を書かせていただきました。Titanium の特集です。</p>

<p>iPhone / Android でアプリを作りたいけど二の足を踏んでいた方、最近 <strong>Titanium</strong> という言葉をよく聞くけど何なんだろう？と思っていた方、おすすめです！</p>

<!-- more -->


<p>サンプルアプリも豊富に載っていますので、参考にしてみてください。（バグ情報ありましたらご連絡ください。。。）</p>

<p class="option">サンプルアプリのソースコードは github で公開しています。</p>




<ul><li><a href="http://gihyo.jp/magazine/wdpress/archive/2011/vol61/support" target="_blank" class="extlink">WEB+DB PRESS Vol.61 サポートページ - gihyo.jp<a></li>
<li><a href="https://github.com/mountposition/wdbv61" rel="external nofollow">WEB+DB PRESS Vol.61 特集1 サンプルソースコード（4-6章）- github</a></li>
<li><a href="https://github.com/kurain/HaikuSample" rel="external nofollow">WEB+DB PRESS Vol.61 特集1 サンプルソースコード（7章）- github</a></li></ul>



]]></content>
  </entry>
  
</feed>
