<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: コーディング | それはBooks]]></title>
  <link href="http://hamasyou.com/blog/tags/kodeingu/atom.xml" rel="self"/>
  <link href="http://hamasyou.com/"/>
  <updated>2014-02-18T12:07:34+09:00</updated>
  <id>http://hamasyou.com/</id>
  <author>
    <name><![CDATA[hamasyou]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Clean Coder プロフェッショナルプログラマへの道]]></title>
    <link href="http://hamasyou.com/blog/2012/09/23/4048860690/"/>
    <updated>2012-09-23T20:42:00+09:00</updated>
    <id>http://hamasyou.com/blog/2012/09/23/4048860690</id>
    <content type="html"><![CDATA[<p>本書は、Clean Coder（プログラマのプロ）とはどんな人物で、どういうことに心がける必要があるのかを解説した本です。</p>

<p><strong>プロ</strong>とは、自分の行いに責任を持つ人物。責任とは、清く正しく働くということ。コミュニケーションをうまくとること。見積りを確実にすること。時間をかんりすること。リスクと見返りの見極めが困難な状況に立ち向かうこと。</p>

<p>本書はこういった、プロのプログラマを育てる本です。コーディングだけではなく、どういう仕事の仕方をする必要があるか、どういうことに気を付けないといけないのかを解説しています。新入社員や初めて先輩になる人におすすめの一冊です。</p>

<!-- more -->




<h2>目次</h2>




<ol><li>プロ意識</li>
<li>「ノー」と言う</li>
<li>「イエス」と言う</li>
<li>コーディング</li>
<li>テスト駆動開発</li>
<li>練習</li>
<li>受け入れテスト</li>
<li>テスト戦略</li>
<li>時間管理</li>
<li>見積もり</li>
<li>プレッシャー</li>
<li>協力</li>
<li>チームとプロジェクト</li>
<li>指導・従弟制度・職人気質</li>
</ol>




<h2>おぼえがき</h2>




<h3>プロ意識</h3>


<p>プロは自分で後始末をする。プロは責任をともなう。</p>

<h4>コードを把握する</h4>


<p>プロのプログラマは、自分のコードが動作することを把握している。どうやって把握するかといえば、それは<em>テスト</em>である。</p>

<p>正常に動いていること、期待しているとおりに動くことは、テストでしか確認できない！</p>

<h4>過去を知る</h4>


<blockquote><p>「過去を記憶できない者は、それを繰り返す運命にある」</p></blockquote>

<p>これまでの業界の進歩や先人の知恵、経験は、色々な本から吸収できる。ソフトウェアのプロとして最低限覚えておかなければならないものが以下になる。</p>

<ul><li>デザインパターン</li><li>設計原則</li><li>方法論</li><li>規律・規範（ソフトウェア開発メソッド）</li><li>成果物・表記法（UML・構造チャート・状態遷移図等）</li></ul>




<h3>「ノー」と言う</h3>


<p>出来ないこと、ムリなこと、正しくないことには「ノー」という。誠実に！</p>

<h3>「イエス」と言う</h3>


<p>「イエス」と言う時には、確実に約束したと分かる言葉を使う。責任をもってやり遂げる！</p>

<h3>コーディング</h3>


<p>「完了」を定義する。何をしたら終わるか。それには、受け入れテストが必要だ。</p>

<p>TDD（テスト駆動開発）は、実施するに値する価値がある。プロは自分のコードがどう動くかを把握する必要がある。それにはテストが必要だ。プロはコーディングの終わり時を知っている。それには、受け入れテストが必要だ。</p>

<p>TDD は、テストでコーディングサイクルを回す。確実性、血管混入率の低下、勇気、ドキュメント、設計を促進する。</p>

<h3>受け入れテスト</h3>


<p>早過ぎる詳細化は癌である。<em>要求は変化するので詳細化は現実的ではない。</em>要求を詳細化すると、開発中のシステムとかけ離れていく。</p>

<p>プロは、開発に入るまで要求を詳細化しない！</p>

<p>いつ受け入れテストを書くか。最初のイテレーションが始まるまでに、最初の受け入れテストを準備しておかなければならない。</p>

<h3>時間管理</h3>


<p>無駄な会議には参加しない。ケント・ベックはこう言った。「5分で決着のつかない議論は、議論では決着がつかない」と。明確な裏付けのない根拠では議論は決着がつかない。</p>

<h3>プレッシャー</h3>


<p>プレッシャーから逃れるには、プレッシャーを生み出す状況から逃れること。ただし、最悪な逃げ方は<em>急いでやること</em>。この誘惑には何がなんでも抵抗しなければならない。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[まつもとゆきひろ コードの未来]]></title>
    <link href="http://hamasyou.com/blog/2012/05/26/4822234630/"/>
    <updated>2012-05-26T08:52:00+09:00</updated>
    <id>http://hamasyou.com/blog/2012/05/26/4822234630</id>
    <content type="html"><![CDATA[<p>本書は日経Linuxで2009年6月号から2012年6月号まで連載されていた「まつもとゆきひろ 技術を斬る」に加筆・修正を加えたものです。2009年からということで古い技術もあるのでは？と思われるかもしれませんが、さすがまつもとさん！きちんと未来を見据えたテーマでかかれていて、すごく参考になりました。</p>

<p>本書は読み物の色がつよく、言語の過去・未来や新しい言語（<em>Go</em>、<em>Dart</em>、<em>CoffeeScript</em>、<em>Lua</em>）の言語作成者ならではの視点での解説、クラウド時代のC10K問題やスケーラビリティの話、ビッグデータ時代の NoSQL の扱い方などをまつもとさん視点で解説しています。</p>

<p>実際にプログラミングをやっている人であれば、ニヤニヤしながら読めることまちがいなしです。最近の技術動向をさくっと知るというのにも良いと思います。僕もとても楽しく面白く読むことが出来ました。</p>

<p>新人教育にいかがですか？</p>

<!-- more -->




<h2>おぼえがき</h2>




<h3>エクストリーム未来予測</h3>


<p>未来を予測するときの簡単なテクニック。エクストリーム・プログラミング（XP）を考案した Kent Beck が著書の中で書いている言葉。</p>

<h3>DSL デザインの構成要素</h3>




<dl>
<dt>コンテキスト</dt>
<dd>DSL の記述がどのような意味を持つか規定する。</dd>
<dt>センテンス</dt>
<dd>コンテキストの内部の記述で、関数呼び出しやメソッド呼び出しで表現される個別の動作。</dd>
<dt>ユニット</dt>
<dd>単位。20.hours の hours など。</dd>
<dt>ボキャブラリ</dt>
<dd>目的分野にふさわしいメソッドをどれだけ用意できるか。</dd>
<dt>ヒエラルキ</dt>
<dd>ネストしたコンテキスト</dd>
</dl>




<h3>GC（ガベージコレクション）の3つの基本方式</h3>




<h4>マークアンドスイープ方式</h4>


<p>先頭から生きているオブジェクトに印をつけていき、最後まで印をつけたら印の付いていないオブジェクトを回収する方式。</p>

<p>処理時間は、「生きているオブジェクト数」 + 「全オブジェクト数」の和（マークを付ける処理 + 回収する処理）。</p>

<h4>コピーコレクション方式</h4>


<p>マークアンドスイープ方式では、<em>大量のオブジェクトが割り当てられ、そのうちごく一部だけが生き残るような場合に必要以上に時間がかかってしまう</em>。</p>

<p>コピーコレクションは、マークアンドスイープ方式でいうマークを付ける処理（マークフェーズ）で、生きているオブジェクトを新しい領域にコピーするようにし、すべてのコピー（マーク）が終わったら古い領域を回収することで行う。</p>

<p>マークをつける処理よりもコピーする処理のほうがコストが高いため、生きているオブジェクトの数が多いと不利な方式になる。</p>

<h4>リファレンスカウント方式</h4>


<p>オブジェクト自身が、自分が参照されているカウント（リファレンスカウント）を知っていて、参照が増減する度にリファレンスカウントを書き換える方式。</p>

<p>メリットは簡単に実装ができること。</p>

<p>デメリットは、循環参照に対応できないこと。また、並列処理と相性がわるいこと。</p>

<h4>応用方式</h4>


<p>基本方式を組み合わせる形で、応用方式が多くの場合利用されている。</p>

<p><em>世代別GC</em>、<em>インクリメンタルGC</em>、<em>並列GC</em>である。</p>

<p>世代別GCは、「オブジェクトのほとんどは短時間でゴミになり、長い時間生き残ったオブジェクトはより長い寿命を持つ」という性質を利用して、オブジェクトに新しい、古いのタグをつけ、新しいものだけをGCするマイナーGCと古いものも対象にするメジャーGCの２つを使い分ける方式。</p>

<p>インクリメンタルGCは、リアルタイム処理などで GC の中断時間を減らす目的で、GC を少しずつ処理していく方式。</p>

<p>並列GCは、複数 CPU を利用して GC を行う方式。</p>

<h3>例外処理</h3>


<p>例外が発生したときの対応には大きく2つある。ひとつは、<em>実行を中止すること</em>。もうひとつは、<em>例外が発生した原因を取り除き再挑戦すること</em>。</p>

<h3>クロージャ</h3>


<p>「関数オブジェクトから外側の変数がアクセス（参照や更新）できる」というのがクロージャを構成する要件の一つ。</p>

<pre><code class="javascript">function echo(func) {
  console.log(func());
}

for (var i = 0; i &lt; 3; i++) {
  echo(function() {
    return i * i;
  });
}
&gt; 0
&gt; 1
&gt; 4
</code></pre>

<p>外側のスコープに属する変数を参照している関数オブジェクトは、そのローカル変数を「閉じ込め」る。</p>

<pre><code class="javascript">function extent() {
  var n = 0;
  return function() {
    n++;
    console.log("n=" + n);
  }
}

var f = extent();
f();
&gt; n=1
f();
&gt; n=2
</code></pre>

<p class="option">Ruby 1.9では、関数っぽいプログラミングを支援するために、lambda の代わりに「->」という式がつかえるようになり、また「call」メソッドを省略して「f.()」と呼び出せるようになっています。</p>




<h3>Go</h3>


<p>Google からリリースされた新言語「<em>Go</em>」は、システムプログラミング言語では初となる言語仕様のレベルで並列プログラミングを意識している。</p>

<p>Go の関数やメソッドは複数の値を戻り値として返すことができる。</p>

<p>Go には例外機構がないが、戻り値の多値をもちいて、本来の戻り値とエラーが発生したかどうかを区別できる「<strong>コンマOK</strong>」スタイルをとっている。</p>

<pre><code class="go">f,ok = os.Open(ファイル名, os.O_RDONLY, 0);
if ok != nil {
  //... open に失敗したときの処理
}
</code></pre>

<p>Go の goroutine は、メモリ空間の共有を行い、軽量であり、コンテキストスイッチが自動でマルチコアを活用できる。</p>

<h3>ブルームフィルタ</h3>


<p><em>ブルームフィルタ</em>は、あるデータが登録されているかどうかを判定できるデータ構造。</p>

<ul><li>判定時間がデータ件数に依存しない（O(1)）</li>
<li>空間効率が非常に良い</li>
<li>要素の削除ができない</li>
<li><em>たまに間違える</em></li></ul>


<p>ブルームフィルタは、本当は要素に入っていないけれども入っているとみなされるという疑陽性（false positive）がある。</p>

<h3>C10K問題</h3>


<p>OS の select コールを使わないで、<em>epoll</em> や <em>kqueue</em> などの別のAPIを利用する。または、ノンブロッキングI/O を使う。Ruby のイベントループフレームワークには、EventMachine がある。</p>

<h3>アプリサーバ</h3>


<p>Unicone は一般的な Master プロセスからワーカープロセスにリクエストを転送するプッシュモデルではなく、<em>プルモデル</em>を採用しているため。プルモデルとは、ワーカー側が処理が Master に処理を受け取りに行く方式。</p>

<h3>key-value ストア</h3>


<p>ACID （Atomicity:原子性、Consistency:一貫性、Isolation:独立性、Durability:持続性）特性はデータベースの世界では一般的だが、近年大規模データを扱うために分散を考えるようになってくると ACID を満たすのが厳しくなってきている。</p>

<p>CAP 定理というものがあり、大規模環境では、Consistency:一貫性、Availability:可用性、Partition Tolerance:分割体制 のうち同時に2つまでしか満たすことができないとされている。</p>

<p>大規模分散環境では、多くは Consistency を捨てている。多くの key-value ストアはトランザクション処理を持たないのはそういうこと。</p>

<h3>アムダールの法則</h3>


<p>一般的にマルチコアコンピュータは、CPU を複数積んでいても、その他のデバイスは共有している事が多い。たとえば、メモリやディスク、ネットワークデバイスなど。もし、CPU 以外のところに処理のボトルネックがある場合は、マルチコアを投入しても性能は改善されない。</p>

<h3>ノンブロッキングI/O</h3>


<p>大量の接続をさばくサーバでは、スレッドを使うとメモリ負荷やスレッド切り替えのコストが大きくなりすぎる傾向がある。そのためイベントを待ち受けてそれに対応する処理を「シングルスレッド」で処理するやり方のほうが効率的になる。</p>

<p>シングルスレッドで処理をするときに気を付けないといけないのは、そのスレッドが「<em>ブロック</em>」されると、プログラム全体が止まってしまうことである。</p>

<p>ブロックは、<em>入出力待ち</em>の場合がほとんどなため、入出力待ちを以下にブロックしないかが重要になる。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rubyベストプラクティス -プロフェッショナルによるコードとテクニック]]></title>
    <link href="http://hamasyou.com/blog/2010/09/17/4873114454/"/>
    <updated>2010-09-17T22:12:00+09:00</updated>
    <id>http://hamasyou.com/blog/2010/09/17/4873114454</id>
    <content type="html"><![CDATA[<p>本書は、Ruby プログラミングの中級者向け指南書のようなものです。様々なコーディングテクニック（例えば、順序付き引数の使いどころ、ブロックの使い方、メソッド名のつけ方、メタプログラミング、関数型プログラミングテクニック、プロジェクトでRubyを使う際の慣習などなど）が満載です。</p>

<p>さすがオライリーといえる深い内容になっていて、Ruby を始めたばかりの人よりは、<em>一通り Ruby でプログラミングをしたことがある人、Ruby を使いこなせているのか不安な人が読むと良い</em>と思います。</p>

<p>今すぐ使えるテクニック！とはちょっと違うかもしれませんが、Ruby の動的な振る舞いや柔軟な拡張性を理解してさらに Ruby を使いこなすための一冊になると思います。</p>

<p>なお、<strong>Ruby1.9に対応</strong>していますので、サンプルコードは Ruby1.9で動きますし、最新 Ruby ではどうするの？を一発で解決できるようになっています。</p>

<!-- more -->




<h2>目次</h2>




<ul class="none">
<li>１章 テストでコードを駆動する</li>
<li>２章 美しい API を設計する</li>
<li>３章 動的な機能を使いこなす</li>
<li>４章 テキスト処理とファイル管理</li>
<li>５章 関数型プログラミングのテクニック</li>
<li>６章 うまういかないとき</li>
<li>７章 文化の壁を取り払う</li>
<li>８章 上手なプロジェクトメンテナンス</li>
<li>付録Ａ 後方互換性のあるコードを書く</li>
<li>付録Ｂ Ruby の標準ライブラリを活用する</li>
<li>付録Ｃ Ruby ワーストプラクティス</li>
</ul>




<h2>２章 美しい API を設計する - 覚書</h2>




<h3>メソッドの引数にデフォルト値を持つパラメータが複数ある場合は擬似キーワード引数を使う</h3>


<p>デフォルト値をもつパラメータが複数ある場合は、Ruby の「メソッドの引数の末尾に要素がひとつ以上のハッシュを渡す際は中括弧（{,}）を省略できる」という仕様を利用して、<strong>擬似キーワード引数</strong>が使えます。</p>

<pre><code class="ruby">def hello(name, options = {})
  options = { nickname: "hamasyou", age: 28 }.merge(options)
  p "Hello #{name}! " + options.to_s
end

hello("Syougo")
# =&gt; "Hello Syougo! {:nickname=&gt;"hamasyou", :age=&gt;28}"
hello("Syougo", age: 27)
# =&gt; "Hello Syougo! {:nickname=&gt;"hamasyou", :age=&gt;27}"
</code></pre>

<h3>インターフェースをシンプルにするためのブロック</h3>


<p>Rails の Configuration に使われているオブジェクトショートカットのことです。次のようなコードを</p>

<pre><code class="ruby">server = Server.new

server.handle(/hello/i) { "Hello from server at #{Time.now}" }
server.handle(/goodby/i) { "Goodby from server at #{Time.now}" }
server.handle(/name is (\w+)/) {|m| "Nice to meet you #{m[1]}!" }

server.run
</code></pre>

<p>次のように書けるようにします。</p>

<pre><code class="ruby">Server.run do
  handle(/hello/i) { "Hello from server at #{Time.now}" }
  handle(/goodby/i) { "Goodby from server at #{Time.now}" }
  handle(/name is (\w+)/) {|m| "Nice to meet you #{m[1]}!" }
end
</code></pre>

<p>これを実現するには、次のようなコードになります。</p>

<pre><code class="ruby">class Server
  def self.run(port, &amp;block)
    server = Server.new(port)
    server.instance_eval(&amp;block)
    server.run
  end
end
</code></pre>

<p>インスタンス化したオブジェクトの <em>instance_eval()</em> メソッドにブロックを渡すことで、ブロックをそのインスタンスのコンテキストで実行しています。</p>

<p>この方法を使うと、ブロックはインスタンス化したオブジェクトのコンテキストで実行されるため、ブロックのスコープ内で定義されたローカル変数にしかアクセスできません。つまり、次のコードは<em>動きません</em>。</p>

<pre><code class="ruby">class MyClass
  def nickname
    "hamasyou"
  end

  def my_method
    Server.run do
      p "Hello #{nickname}"
    end
  end
end

MyClass.new.my_method
# =&gt; NameError: undefined local variable or method `nickname' for #&lt;Server:0x000001020478a8&gt;
</code></pre>

<p>この問題を解決するには、ブロックをインスタンスのコンテキストで評価するのではなく、クロージャとして実行すればよいです。</p>

<pre><code class="ruby">class Server
  def self.run(&amp;block)
    server = Server.new
    block.arity &lt; 1 ? server.instance_eval(&amp;block) : block.call(server)
    server.run
  end
end
</code></pre>

<pre><code class="ruby">class MyClass
  def nickname
    "hamasyou"
  end

  def my_method
    Server.run do |server|
      p "Hello #{nickname}"
    end
  end
end

MyClass.new.my_method
# =&gt; "Hello hamasyou"
</code></pre>

<p>block.arity を使ってコードブロックに引数がいくつあるかを調べて、引数がひとつ以上あればブロックをクロージャとして呼び出すようにしています。　</p>

<h3>method? と method! の意味</h3>


<p><section></p>

<h4>method? 疑問符</h4>


<p><em>method?</em> のようにメソッド名の末尾に疑問符（?）をつけるのは目的は、<strong>オブジェクトに何かを問い合わせる</strong>ことになります。条件分岐などにメソッドを利用する際に使えます。</p>

<p>疑問符をつけたメソッドの戻り値は、<em>true</em> か <em>false or nil</em> を返すようにします。</p>

<p></section></p>

<p><section></p>

<h4>method! 感嘆符</h4>


<p><em>method!</em> のようにメソッド名の末尾に感嘆符（!）をつける目的は、<strong>このメソッドは特別だ、「注意しろ！」</strong>になります。</p>

<p><blockquote><p>よくある誤解は、受け取ったオブジェクトを変更することを知らせたいときに感嘆符を使う、というものだ。たいていの場合、感嘆符は私たちに何か警告をするものだからだろう。</p></p><p><p></p><footer><strong>method?とmethod!が何を意味しているか理解しよう - 本書 P.57</strong></footer></blockquote></p>

<p>Ruby の組み込みクラスのメソッドには破壊的メソッドでも感嘆符がついているのとついていないものがあります。</p>

<p>これはすなわち、メソッドに感嘆符をつける目的はこのメソッドが特別であることを知らせるのであって、破壊的であるとか危険であることを知らせるのではないということです。</p>

<p><blockquote><p>したがって、同じようなことをする　foo() メソッドがないのに foo!() メソッドだけがあるのは、あまり意味のないことだ。（中略）感嘆符は必ずしもそのメソッドが<em>破壊的な操作</em>をすることを意味するわけではないと考えると、&hellip;</p></p><p><p></p><footer><strong>本書 P.59</strong></footer></blockquote></p>

<p></section></p>

<h3>２章のポイント</h3>




<h4>引数</h4>




<ul>
<li>options ハッシュによる擬似キーワード引数が使えないか検討する</li>
<li>順序付き引数と options ハッシュを組み合わせて使うときは、配列 splat 演算子（*）は使わない</li>
<li>必須パラメータは、options ハッシュには入れないこと。必須パラメータは順序付き引数として扱う</li>
</ul>




<h4>ブロック</h4>




<ul>
<li>前処理後処理の間に、ブロックを yield するようなヘルパメソッドを検討する</li>
<li>&amp;block と instance_eval() を組み合わせると任意のオブジェクトのコンテキストでブロックを実行できる</li>
<li>yield と block.call の戻り値は、与えられた戻り値と同じにする</li>
</ul>




<h2>３章 動的な機能を使いこなす - 覚書</h2>




<h3>define_method() を使って動的にインスタンスメソッドを定義する</h3>


<p>メソッドを定義するというのは、クラスのインスタンスメソッドを定義するということなので、動的にインスタンスメソッドを定義するにはクラスのスコープで define_method() を呼び出します。</p>

<pre><code class="ruby">class MyClass
  def self.define(method_name, &amp;block)
    define_method(method_name, &amp;block)
  end
end

obj = MyClass.new
obj.hello
# =&gt; NoMethodError: undefined method `hello'

MyClass.define(:hello) do
  "Hello World"
end

obj.hello
# =&gt; "Hello World"
</code></pre>

<h3>define_method() を使って動的にクラスメソッドを定義する</h3>


<p>クラスメソッドを定義するには、クラスの特異クラスにメソッドを定義する必要があります。特異クラスをオープンするには、class &lt;&lt; obj 構文を使います。</p>

<pre><code class="ruby">class MyClass
  def self.define(method_name, &amp;block)
    obj = class &lt;&lt; self; self; end
    obj.send(:define_method, method_name, &amp;block)
  end
end

MyClass.define(:hello) do
  "Hello World"
end

MyClass.hello
# =&gt; "Hello World"
</code></pre>

<p><section></p>

<h4>define_method() は private メソッド</h4>


<p>define_method() は特異クラス上でプライベートになっているため、レシーバを指定して呼び出すには send() メソッドを使う必要があります。</p>

<p></section></p>

<h3>モジュールのメソッドをモジュールのクラスメソッドにする</h3>




<pre>extend self</pre>


<p>extend self を使うと、自信のインスタンスメソッドを特異クラスに定義することになりクラスメソッド化することができます。</p>

<pre><code class="ruby">module MyModule
  extend self

  def hello
    "Hello World"
  end
end

MyModule.hello
# =&gt; "Hello World"
</code></pre>

<h3>３章のポイント</h3>




<ul>
<li>Ruby ではすべてのクラスがオープン。振る舞いを実行時に変更することができる</li>
<li>オブジェクト毎の振る舞いは、class &lt;&lt; obj 構文を使ってオブジェクトの特異クラスにアクセスすることで実装できる</li>
<li>拡張するときはできるだけオブジェクトごとの振る舞いを拡張するほうがよい。obj.extend() を使うようにする</li>
<li>クラスもモジュールも動的につくることができる。メソッドを定義するためのブロックを受け付けるようにする</li>
<li>モジュールをクラスに混ぜるとき、include を使うとインスタンスレベルで利用可能になり、extend を使うとクラスレベルで利用可能になる</li>
<li>フックは特定のクラスやモジュールに実装することができ、それより下位のすべてを捕捉する</li>
</ul>




<h3>３章のまとめ</h3>


<p>３章で学習したことが詰まったコードの読み解きです。</p>

<pre><code class="ruby">module NativeCampingRoutes

  extend self

  def R(url)
    route_lookup = routes

    klass = Class.new
    meta = class &lt;&lt; klass; self; end
    meta.send(:define_method, :inherited) do |base|
      raise "Already defined" if route_lookup[url]
      route_lookup[url] = base
    end
    klass
  end

  def routes
    @routes ||= {}
  end

  def process(url, params = {})
    routes[url].new.get(params)
  end
end

module NativeCampingRoutes
  class Hello &lt; R '/hello'
    def get(params)
      puts "hello #{params[:name]}"
    end
  end

  class Goodbye &lt; R '/goodbye'
    def get(params)
      puts "goodbye #{params[:name]}"
    end
  end
end

NativeCampingRoutes.process('/hello', name: "greg")
# =&gt; hello greg
NativeCampingRoutes.process('/goodbye', name: "joe")
# =&gt; goodbye joe
</code></pre>

<h4>3行目 extend self</h4>


<p>Object#extend は引数で渡されたモジュールのインスタンスメソッドを特異クラスのメソッド（つまり、クラスメソッド）として追加します。</p>

<p>すなわち、この後に続く def で定義されたモジュールのインスタンスメソッドを自身のクラスメソッドに再定義しています。</p>

<h4>6行目 route_lookup = routes</h4>


<p>10行目で呼び出している define_method() メソッドに渡すブロックはクロージャなので、ローカル変数にアクセスできます。define_method() メソッド内で @routes にアクセスしたいので、ローカル変数に格納しています。</p>

<h4>9行目 meta = class &lt;&lt; klass; self; end</h4>


<p>10行目で定義する Class#inherited メソッドは、継承されるクラス（klass）のクラスメソッドとして定義します。クラスメソッドは特異クラスのメソッドとして定義する必要があるので、特異クラスを取り出しています。</p>

<h4>10行目 meta.send(:define_method, :inherited) do |base|</h4>


<p>define_method() メソッドは private メソッドなので、meta.define_method() という呼出はできません。</p>

<p>そこで、send() メソッドを使って private メソッドを呼び出しています。特異クラスである meta に対して inherited メソッド（クラスが継承された際に呼び出されるフックメソッド）を定義しています。</p>

<p>inherited メソッドは、呼び出される際に引数として継承先の子クラス（NativeCampingRoutes::Hello、NativeCampingRoutes::Goodbye）が渡されるので、ブロック引数の base として受け取っています。</p>

<h4>14行目 klass</h4>


<p>R() メソッドは継承元として使うことを想定しているので、クラスを返しています。</p>

<h4>22行目 routes[url].new.get(params)</h4>


<p>routes メソッドで返される @routes ハッシュに対して url をキーにアクセスします。</p>

<p>R() メソッドで @routes[url] に継承先クラスが格納されているので、Class#new を使ってインスタンス化し、get() メソッドを呼び出しています。</p>

<h4>27, 28行目 class Hello &lt; R '/hello'</h4>


<p>定義した NativeCamppingRoutes モジュールのサブクラスとして Hello を定義し、R() メソッドで返される無名クラスを継承しています。</p>

<p>クラスに get() メソッドを定義して、21行目の process メソッドでインスタンス化したオブジェクトから呼び出せるようにしています。</p>

<h2>６章 うまくいかないとき - 覚書</h2>




<h3>データ構造を確認するのに YAML がつかえる</h3>


<p>YAML というデータシリアライゼーションのための標準ライブラリを使うと、データ構造をプリントしてくれる y() メソッドが使えるようになる。</p>

<pre><code class="ruby">require "yaml"

data = { name: "hamasyou", age: 28, address: { zip: "272-0000", pref: "Chiba", city: "Ichikawa" } }
y data
#---
#:name: hamasyou
#:age: 28
#:address:
#  :zip: 272-0000
#  :pref: Chiba
#  :city: Ichikawa
</code></pre>

<h3>テストデータ生成用ライブラリ faker</h3>


<p>テスト用のデータ生成に、Faker というライブラリが使えます。gem install faker でインストールできます。</p>

<p><div class="terminal-window">
          <nav class="terminal-control-window">
            <a href="#" class="terminal-close" data-rel="close">close</a>
            <a href="#" class="terminal-minimize">minimize</a>
            <a href="#" class="terminal-deactivate">deactivate</a>
          </nav>
          <h1 class="terminal-title">Terminal</h1>
          <div class="terminal-container"><div class="terminal"><table><tr><td class='gutter'><pre class='line-numbers'><span class='line-number'>$</span></pre></td><td class='code'><pre><code><span class='line command'>sudo gem install faker</span></code></pre></td></tr></table></div></div>
        </div></p>

<p>次のように使います。</p>

<pre><code class="ruby">require "faker"
require "pp"

data = 5.times.map do
  { name: Faker::Name.name, phone: Faker::PhoneNumber.phone_number }
end

pp data
#[{:name=&gt;"Johnathan Lowe III", :phone=&gt;"(859)707-2471 x1926"},
# {:name=&gt;"Lucius Murray", :phone=&gt;"(760)338-6980"},
# {:name=&gt;"Queen Beahan II", :phone=&gt;"1-085-613-9274 x52563"},
# {:name=&gt;"Daniela Boyle", :phone=&gt;"956.964.3848"},
# {:name=&gt;"Mrs. Jarret Wisozk", :phone=&gt;"(760)687-0168 x68429"}]
</code></pre>

<p>Faker で作れるダミーデータには次のようなものがあります。</p>

<table class="table table-bordered">
  <tr><th>クラス</th><th>作れるデータ</th><th>サンプル</th></tr>
  <tr><td>Faker::Address</td><td>住所データ</td><td><ul class="none"><li>zip_code<br/>"15832-6995"</li><li>city<br/>"South Verlie"</li></ul></td></tr>
  <tr><td>Faker::Company</td><td>会社データ</td><td><ul class="none"><li>name<br/>"Carroll, Kuhlman and Glover"</li><li>bs<br/>"orchestrate vertical action-items"</li></ul></td></tr>
  <tr><td>Faker::Internet</td><td>ネットワークデータ</td><td><ul class="none"><li>email<br/>"wiley@andersoncrist.us"</li><li>free_email<br/>"aubree.waters@gmail.com"</li><li>domain_name<br/>"littel.com"</li></ul></td></tr>
  <tr><td>Faker::Lorem</td><td>文章データ</td><td><ul class="none"><li>words<br/>["quaerat", "blanditiis", "qui"]</li><li>sentences<br/>["Maiores dicta sed voluptas corrupti repudiandae eos aliquam eligendi.", "Dolorem eius ut nam esse nihil illum.", "Non sapiente accusamus maiores neque eum est ea."]</li></ul></td></tr>
  <tr><td>Faker::Name</td><td>名前データ</td><td><ul class="none"><li>name<br/>"Nicklaus Swift"</li><li>first_name<br/>"Angus"</li><li>last_name<br/>"Morissette"</li></ul></td></tr>
  <tr><td>Faker::PhoneNumber</td><td>電話番号</td><td><ul class="none"><li>phone_number<br/>"024-597-6027 x86091"</li></ul></td></tr>
</table>


<p>Faker::PhoneNumber::Formats に phone_number() メソッドで返される電話番号のフォーマットの一覧が入っています。テスト時にフォーマットをいじることで、phone_number() メソッドの戻り値の形式を変更できます。</p>

<pre><code class="ruby">Faker::PhoneNumber::Formats = ["(###)##-####", "###-####-####"]
Faker::PhoneNumber::phone_number
# =&gt; "(109)29-6592"
</code></pre>

<h2>７章 文化の壁を取り払う - 覚書</h2>




<h3>ソースコードのエンコーディングを明示する</h3>


<p>Ruby1.9 から多言語対応に注意を払わなければいけなくなりました。<em>M17N（MultilingualizatioN）</em> です。</p>

<p>M17N 可能なプロジェクトで作成するソースコードには、ソースコード中に<strong>マジックコメント</strong>を埋め込む必要があります。</p>

<p>Ruby ソースコード中に #! がない限り、マジックコメントはファイルの一行目に書きます。#! がある場合は2行目に書きます。</p>

<p>マジックコメントのフォーマットは次のとおりです。</p>

<pre># coding: UTF-8</pre>




<pre># -*- coding: utf-8 -*-</pre>




<h3>ファイルを扱う場合</h3>


<p>例えば、EUC-JP で書かれたファイルを UTF-8 で書かれた Ruby のソースコード上で処理したい場合、次のようにします。</p>

<pre><code class="ruby">File.open("euc.txt", encoding: "EUC-JP:UTF-8").each do |line|
  p line
end
</code></pre>

<p><em>encoding:</em> パラメータを指定してファイルを開きます。encoding パラメータは &quot;&lt;ファイルのエンコード&gt;:&lt;処理するソースコードのエンコード&gt;&quot; のように書きます。</p>

<p>例の場合、EUC-JP で書かれた euc.txt ファイルを UTF-8 のソースコードで処理するので、encoding:&quot;EUC-JP:UTF-8&quot; としています。</p>

<p>なお、ファイルのエンコーディングがソースコードのエンコーディングと同じ場合は、encoding: &quot;UTF-8&quot; と書くことができます。</p>

<p class="option">encodingオプションを指定しない場合、Ruby は Encoding#default_external で指定されているエンコーディングでファイルを解釈しようとします。</p>




<h3>バイナリファイルを扱う場合</h3>


<pre><code class="ruby">img = File.read("hoge.png");
</code></pre>

<p>上記のようにバイナリデータを読み込んでいる場合は注意が必要です。Ruby1.9 からは encoding が指定されない場合、<em>Encoding#default_external</em> の値がエンコーディングとして使われます。</p>

<p>そのため、read() メソッドで encoding を指定しないと、中身がバイナリデータであっても default_external のエンコーディングだと解釈されてしまいます。</p>

<p>バイナリデータを読み込む際は、<em>File#binread()</em> メソッドを使うようにします。</p>

<h3>閑話休題</h3>


<p>７章の P.223 に L10N の話題が載っています。そこで見つけたソースコード。</p>

<pre><code class="ruby">data = { given_name: "姉ヶ崎", surname: "寧々" }
Gibberish::Simple.use_language(:ja) do
  p T("{given_name}{surname}", [:name, data]) #=&gt; "姉ヶ崎寧々"
end
</code></pre>

<p>ね、寧々さん！！？</p>

<h2>８章 プロジェクトメンテナンス - 覚書</h2>




<h3>README ファイルに書くとよいこと</h3>




<dl>
<dt>Description（説明）</dt>
<dd>なんのためのプロジェクトなのか、何を解決するものなのか、1〜2段落程度で説明する。</dd>
<dt>Documentation（ドキュメント）</dt>
<dd>プロジェクトの公開 API となっている主要なクラスを2〜3個紹介するとよい。</dd>
<dt>Examples（サンプル）</dt>
<dd>基本的な使い方、何が出来るのか？どうやってクラスを使うのか？の概要を説明するとよい</dd>
<dt>Install（インストール方法）</dt>
<dd>インストール手順が簡単であれば、README にインストール手順を書いておくとよい。</dd>
<dt>Q&amp;A（質問の宛先）</dt>
<dd>自分たちへの質問の方法を記述する。Eメール、電話、会社の住所などなど。</dd>
</dl>




<h3>ライブラリのレイアウト</h3>




<h4>ライブラリディレクトリ</h4>


<p>lib フォルダを作り、ひとつのファイルとひとつのサブディレクトリを用意します。</p>

<p>ひとつのファイルとは、プロジェクト名と同じファイルになっており、依存関係のあるライブラリなどをロードするための出発点としての役割を果たすものになります。</p>

<p>ひとつのサブディレクトリには、プロジェクト名と同じディレクトリ名にしておき、必要なライブラリやソースコードをすべてこの中に閉じ込める。</p>

<pre>
- lib
  - csvparser/
    - ...ライブラリ群...
  - csvparser.rb
</pre>


<p>クラス名とファイル名の対応等は、<a href="http://shugo.net/ruby-codeconv/codeconv.html" rel="external nofollow">Ruby コーディング規約 - Shugo.net</a> 等を参考にする。</p>

<h4>実行ファイル</h4>


<p>実行ファイルは bin ディレクトリに置く。</p>

<h4>テストコード</h4>


<p>テストコードは、test ディレクトリに置く。</p>

<h4>サンプルコード</h4>


<p>サンプルコードがあれば、examples ディレクトリに置く。</p>

<h4>ここまでをまとめると</h4>


<p>次のようなディレクトリ構成になる。</p>

<pre>-Projectルート/
  - README
  - bin/
  - examples/
  - lib/
    - csvparser/
      - ...ソースコード...
    - csvparser.rb
  - test</pre>



]]></content>
  </entry>
  
</feed>
