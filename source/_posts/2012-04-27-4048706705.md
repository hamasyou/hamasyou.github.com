---
layout: post
title: "オブジェクト指向JavaScript"
date: 2012-04-27 12:54
comments: true
categories: [Programming]
keywords: "JavaScript,オブジェクト指向,プロトタイプ指向"
tags: [JavaScript,いいまとめ,これは読むべき,わかりやすい]
author: hamasyou
amazon_url: "http://www.amazon.co.jp/gp/product/4048706705?ie=UTF8&tag=sorehabooks-22&linkCode=xm2&camp=247&creativeASIN=4048706705"
amazon_author: "Stoyan Stefanov (著), 水野貴明 (翻訳), 渋川よしき (翻訳)"
amazon_image: "http://ec2.images-amazon.com/images/I/51ttiBI82cL._SL500_AA300_.jpg"
amazon_publisher: "アスキー・メディアワークス"
---

本書は、JavaScript を理解するためのものです。JavaScript はプロトタイプベースの言語で、クラスがなかったり、プロパティのアクセス修飾子がなかったり、継承の仕方が特別だったりします。

JavaScript を理解するには、JavaScript は全てがオブジェクトであることを覚えておく必要があります。本書は、こう言った、JavaScript が他のオブジェクト指向言語と違う点を整理し、JavaScript ではこう書くというのを丁寧に解説してくれています。

「JavaScript はブラウザ上で動く小さな言語」という認識だった昔とは、昨今では JavaScript の扱いは変わりました。サーバサイドでも JavaScript を動かしたり、スマートフォンの開発に JavaScript を使ったりと、JavaScript が使える舞台は広がっています。

JavaScript をもう一度ちゃんと理解したいという人に、本書はおすすめです。


<!-- more -->

<h2>おぼえがき</h2>

<h3>プリミティブデータ型</h3>

<dl>
<dt>Number</dt>
<dd>1, 100, 3.14 などの数値。浮動小数点を含む。</dd>
<dt>String</dt>
<dd>'hoge', &quot;foo bar&quot;, などで表現される文字列。</dd>
<dt>Boolean</dt>
<dd>true と false。</dd>
<dt>undefined</dt>
<dd>まだ存在していない変数にアクセスすると得られる値。</dd>
<dt>null</dt>
<dd>値がないことを表す値。</dd>
</dl>

<h3>変数の型をしる <code>typeof</code> 演算子</h3>

変数や値の型を調べるときに使える <strong>typeof演算子</strong>は、<em>&quot;number&quot;</em>、<em>&quot;string&quot;</em>、<em>&quot;boolean&quot;</em>、<em>&quot;undefined&quot;</em>、<em>&quot;object&quot;</em>、<em>&quot;function&quot;</em> のいずれかの値（文字列）を返す。

<h3>Infinity（無限）</h3>

<strong>Infinity</strong> は JavaScript で扱えない大きな数値を表すのにつかう値。JavaScript で扱える最大の数値は 1.7976931348623157e+308、最小は 5e-324である。

<pre class="code">>>> Infinity
<em>Infinity</em>
>>> typeof Infinity
<em>"number"</em>
>>> 1e309
<em>Infinity</em></pre>

<h3>Boolean に変換されると false になる値</h3>

<ul>
<li>空文字列&quot;&quot;</li>
<li>null</li>
<li>undefined</li>
<li>数値の 0</li>
<li>数値の NaN</li>
<li>Boolean型の false</li>
</ul>

<h3>型変換の Tips</h3>

数字のような文字列を数値に変換する方法は parseInt() 関数を使う方法の他に、1 を掛けるという方法もある。

<pre class="code">>>> <span class="keyword">var</span> s = <span class="literal">"100"</span>;
>>> s = s * <span class="literal">1</span>;
>>> <span class="keyword">typeof</span> s;
<em>"number"</em></pre>

文字列に変換する場合、空文字と結合する方法がある。

<pre class="code">>>> <span class="keyword">var</span> n = <span class="literal">10</span>;
>>> n = <span class="literal">""</span> + n;
>>> <span class="keyword">typeof</span> n;
<em>"string"</em></pre>

<h3>配列の要素の削除</h3>

配列の要素の削除には delete 演算子を使うが、この演算子は配列の要素を減らすわけではなく、undefined を設定する。

<pre class="code">>>> <span class="keyword">var</span> a = [1, 2, 3];
>>> delete a[1];
<em>true</em>
>>> a.length;
<em>3</em>
>>> a;
<em>[1, undefined, 3]</em></pre>

<h3>変数が定義されていて、値が割り当てられているかどうかを確認する方法</h3>

<pre class="code"><span class="keyword">if</span> (<span class="keyword">typeof</span> something !== <span class="literal">"undefined"</span>) {
  <span class="rem">// 何かの処理</span>
}</pre>

<h3>自分自身を書き換える関数</h3>

自分自身を書き換える関数の仕組みは、初期化などの一度だけ行ないたい処理がある場合に使う。

<pre class="code"><span class="keyword">var</span> a = <span class="keyword">function</span>() {
  <span class="keyword">function</span> someSetup() {
    <span class="keyword">var</span> setup = <span class="literal">'done'</span>;
  }
  <span class="keyword">function</span> actualWork() {
    alert(<span class="literal">'Worky-worky'</span>);
  }
  someSetup();
  <span class="keyword">return</span> actualWork;
}();</pre>

<h2>オブジェクト</h2>

<h3>オブジェクトリテラル表記</h3>

{} を使ってオブジェクトを定義することをオブジェクトリテラル表記を呼ぶ。

<pre class="code"><span class="keyword">var</span> hero = {
  breed: <span class="literal">'Turtle'</span>,
  occupation: <span class="literal">'Ninja'</span>
};</pre>

オブジェクトのプロパティ名はクウォートしないのが推奨されている。ちなみに、連想配列（ハッシュ）のキーは文字列である。

<h3>コンストラクタ関数</h3>

関数を new してオブジェクトを作ることで、関数をコンストラクタとして利用することができる。

<pre class="code"><span class="keyword">function</span> Hero(name) {
  this.name = name;
}
 
>>> <span class="keyword">var</span> h1 = <span class="keyword">new</span> Hero(<span class="literal">'hamasyou'</span>);
>>> h1.name;
"hamasyou"</pre>

<h3>グローバル変数</h3>

JavaScript のプログラムは様々なホスト環境（たとえばブラウザ環境）で動作する。JavaScript のホスト環境はグローバルオブジェクトを提供していて、グローバル変数はグローバルオブジェクトのプロパティになる。

たとえば、ブラウザ環境では <em>window</em> というグローバルオブジェクトが提供されており、グローバル変数はすべて、window のプロパティになる。

<p class="option">コンストラクタ関数を定義したにもかかわらず、new でオブジェクトをつくらなかった場合、this はグローバルオブジェクトを指すことになる。</p>

<h3>constructor プロパティ</h3>

オブジェクトが作成されると、<em>constructor</em> プロパティと呼ばれる特別なプロパティに、オブジェクトを作成したときに使われたコンストラクタ関数がセットされる。

<pre class="code">>>> h1.constructor;
Hero(name)</pre>

<h3>instanceof 演算子</h3>

<em>instanceof 演算子</em>を使うと constructor プロパティが指定した関数かどうかを調べることができる。

<pre class="code">>>> h1 <span class="keyword">instanceof</span> Hero;
true</pre>

<h3>オブジェクトの比較</h3>

オブジェクト同士を比較すると、両方の変数が同じオブジェクトの参照の場合のみ true を返す。

<h2>プロトタイプ</h2>

{% blockquote  %}<li>このプロパティは関数がコンストラクタのときのみ使われる</li>
<li>この関数を使って作られたオブジェクトも、prototype プロパティを持ち、関数の prototype と同じオブジェクトを参照する。このオブジェクトのプロパティは自分のプロパティと同じように使える</li></ul>
{% endblockquote %}

<h3>prototype プロパティ</h3>

関数は、<em>prototype</em> と呼ばれるプロパティを保持している。初期値は空のオブジェクトになっている。

<pre class="code"><span class="keyword">function</span> multiply(a, b) {
  <span class="keyword">return</span> a * b;
}
>>> multiply.constructor;
Function()
 
>>> <span class="keywrod">typeof<span> multiply.prototype;
"object"
 
>>> multiply.prototype;
multiply {}</pre>

prototype プロパティに設定されているオブジェクトには、プロパティとメソッドを追加していくことができる。このオブジェクトは、multiply 関数自身にはなんの影響も与えない。追加したプロパティとメソッドは、multiply をコンストラクタとして利用した場合にのみ使われる。

<pre class="code">>>> multiply.prototype.name = <span class="literal">'hamasyou'</span>;
>>> multiply.name;
"multiply"
 
>>> <span class="keywrod">var</span> hoge = <span class="keyword">new</span> multiply();
>>> hoge.name;
"hamasyou"</pre>

prototype プロパティをいつ変更しても、すべてのオブジェクトが影響を受ける点は注意が必要。

<h3>prototype オブジェクトのプロパティを上書きする</h3>

オブジェクト自身のプロパティの方が、prototype オブジェクトのプロパティよりも優先して解決される。

<pre class="code"><span class="keyword">var</span> Salary = (<span class="keyword">function</span>() {
  <span class="keyword">var</span> salary = <span class="keyword">function</span>() {};
  salary.prototype.base = <span class="literal">50000</span>;
  salary.prototype.total = <span class="keyword">function</span>() {
    <span class="keyword">return</span> this.base * <span class="literal">1.05</span>;
  };
  <span class="keyword">return</span> salary;
})();
 
>>> <span class="keyword">var</span> hoge_salary = <span class="keyword">new</span> Salary();
>>> hoge_salary.base = <span class="literal">20000</span>;
>>> hoge_salary.total();
21000
 
<span class="keyword">var</span> hama_salary = <span class="keyword">new</span> Salary();
>>> hama_salary.total();
52500</pre>

<h2>継承</h2>

<h3>プロトタイプチェーンで継承を実現する</h3>

JavaScript の prototype プロパティはオブジェクトであるので、自身の prototype も持っている。このように prototype をチェーンして辿っていくことで、継承を実現することができる。

次の例は、本書 P.183 のプロトタイプチェーンの例である。

<pre class="code"><span class="keyword">function</span> Shape() {
  this.name = <span class="literal">'shape'</span>;
  this.toString = <span class="keyword">function</span>() { <span class="keyword">return</span> this.name; }
}
 
<span class="keyword">function</span> TwoDShape() {
  this.name = <span class="literal">'2D shape'</span>;
}
 
<span class="keyword">function</span> Triangle(side, height) {
  this.name = <span class="literal">'Triangle'</span>;
  this.side = side;
  this.height = height;
  this.getArea = <span class="keyword">function</span>() {
    return this.side * this.height / 2;
  };
}
 
TwoDShape.prototype = <span class="keyword">new</span> Shape();
Triangle.prototype = <span class="keyword">new</span> TwoDShape();
TwoDShape.prototype.constructor = TwoDShape;
Triangle.prototype.constructor = Triangle;
 
>>> <span class="keyword">var</span> my = <span class="keyword">new</span> Triangle(5, 10);
>>> my.getArea();
25
>>> my.toString();
"Triangle"</pre>

Triangle クラスには toString メソッドは定義されていないが、Shape 関数で定義されていることで、プロトタイプチェーンをたどって呼び出すことができる。

<p class="option">継承を行った後は、constructor を再設定しておくとよい。</p>





