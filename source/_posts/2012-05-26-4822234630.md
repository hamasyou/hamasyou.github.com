---
layout: post
title: "まつもとゆきひろ コードの未来"
date: 2012-05-26 08:52
comments: true
categories: [Programming]
keywords: "まつもとゆきひろ,コード,プログラマ,未来,技術"
tags: [これは読むべき,プログラマ,コーディング]
author: hamasyou
amazon_url: "http://www.amazon.co.jp/gp/product/4822234630?ie=UTF8&tag=sorehabooks-22&linkCode=xm2&camp=247&creativeASIN=4822234630"
amazon_author: "まつもと ゆきひろ"
amazon_image: "http://ec2.images-amazon.com/images/I/51cTLYbHDRL._SL500_AA300_.jpg"
amazon_publisher: "日経BP社"
---

本書は日経Linuxで2009年6月号から2012年6月号まで連載されていた「まつもとゆきひろ 技術を斬る」に加筆・修正を加えたものです。2009年からということで古い技術もあるのでは？と思われるかもしれませんが、さすがまつもとさん！きちんと未来を見据えたテーマでかかれていて、すごく参考になりました。

本書は読み物の色がつよく、言語の過去・未来や新しい言語（<em>Go</em>、<em>Dart</em>、<em>CoffeeScript</em>、<em>Lua</em>）の言語作成者ならではの視点での解説、クラウド時代のC10K問題やスケーラビリティの話、ビッグデータ時代の NoSQL の扱い方などをまつもとさん視点で解説しています。

実際にプログラミングをやっている人であれば、ニヤニヤしながら読めることまちがいなしです。最近の技術動向をさくっと知るというのにも良いと思います。僕もとても楽しく面白く読むことが出来ました。

新人教育にいかがですか？


<!-- more -->

<h2>おぼえがき</h2>

<h3>エクストリーム未来予測</h3>

未来を予測するときの簡単なテクニック。エクストリーム・プログラミング（XP）を考案した Kent Beck が著書の中で書いている言葉。

<h3>DSL デザインの構成要素</h3>

<dl>
<dt>コンテキスト</dt>
<dd>DSL の記述がどのような意味を持つか規定する。</dd>
<dt>センテンス</dt>
<dd>コンテキストの内部の記述で、関数呼び出しやメソッド呼び出しで表現される個別の動作。</dd>
<dt>ユニット</dt>
<dd>単位。20.hours の hours など。</dd>
<dt>ボキャブラリ</dt>
<dd>目的分野にふさわしいメソッドをどれだけ用意できるか。</dd>
<dt>ヒエラルキ</dt>
<dd>ネストしたコンテキスト</dd>
</dl>

<h3>GC（ガベージコレクション）の3つの基本方式</h3>

<h4>マークアンドスイープ方式</h4>

先頭から生きているオブジェクトに印をつけていき、最後まで印をつけたら印の付いていないオブジェクトを回収する方式。

処理時間は、「生きているオブジェクト数」 + 「全オブジェクト数」の和（マークを付ける処理 + 回収する処理）。

<h4>コピーコレクション方式</h4>

マークアンドスイープ方式では、<em>大量のオブジェクトが割り当てられ、そのうちごく一部だけが生き残るような場合に必要以上に時間がかかってしまう</em>。

コピーコレクションは、マークアンドスイープ方式でいうマークを付ける処理（マークフェーズ）で、生きているオブジェクトを新しい領域にコピーするようにし、すべてのコピー（マーク）が終わったら古い領域を回収することで行う。

マークをつける処理よりもコピーする処理のほうがコストが高いため、生きているオブジェクトの数が多いと不利な方式になる。

<h4>リファレンスカウント方式</h4>

オブジェクト自身が、自分が参照されているカウント（リファレンスカウント）を知っていて、参照が増減する度にリファレンスカウントを書き換える方式。

メリットは簡単に実装ができること。

デメリットは、循環参照に対応できないこと。また、並列処理と相性がわるいこと。

<h4>応用方式</h4>

基本方式を組み合わせる形で、応用方式が多くの場合利用されている。

<em>世代別GC</em>、<em>インクリメンタルGC</em>、<em>並列GC</em>である。

世代別GCは、「オブジェクトのほとんどは短時間でゴミになり、長い時間生き残ったオブジェクトはより長い寿命を持つ」という性質を利用して、オブジェクトに新しい、古いのタグをつけ、新しいものだけをGCするマイナーGCと古いものも対象にするメジャーGCの２つを使い分ける方式。

インクリメンタルGCは、リアルタイム処理などで GC の中断時間を減らす目的で、GC を少しずつ処理していく方式。

並列GCは、複数 CPU を利用して GC を行う方式。

<h3>例外処理</h3>

例外が発生したときの対応には大きく2つある。ひとつは、<em>実行を中止すること</em>。もうひとつは、<em>例外が発生した原因を取り除き再挑戦すること</em>。

<h3>クロージャ</h3>

「関数オブジェクトから外側の変数がアクセス（参照や更新）できる」というのがクロージャを構成する要件の一つ。

```javascript
function echo(func) {
  console.log(func());
}

for (var i = 0; i < 3; i++) {
  echo(function() {
    return i * i;
  });
}
> 0
> 1
> 4
```

外側のスコープに属する変数を参照している関数オブジェクトは、そのローカル変数を「閉じ込め」る。

```javascript
function extent() {
  var n = 0;
  return function() {
    n++;
    console.log("n=" + n);
  }
}

var f = extent();
f();
> n=1
f();
> n=2
```

<p class="option">Ruby 1.9では、関数っぽいプログラミングを支援するために、lambda の代わりに「->」という式がつかえるようになり、また「call」メソッドを省略して「f.()」と呼び出せるようになっています。</p>

<h3>Go</h3>

Google からリリースされた新言語「<em>Go</em>」は、システムプログラミング言語では初となる言語仕様のレベルで並列プログラミングを意識している。

Go の関数やメソッドは複数の値を戻り値として返すことができる。

Go には例外機構がないが、戻り値の多値をもちいて、本来の戻り値とエラーが発生したかどうかを区別できる「**コンマOK**」スタイルをとっている。

```go
f,ok = os.Open(ファイル名, os.O_RDONLY, 0);
if ok != nil {
  //... open に失敗したときの処理
}
```

Go の goroutine は、メモリ空間の共有を行い、軽量であり、コンテキストスイッチが自動でマルチコアを活用できる。

<h3>ブルームフィルタ</h3>

<em>ブルームフィルタ</em>は、あるデータが登録されているかどうかを判定できるデータ構造。

<ul><li>判定時間がデータ件数に依存しない（O(1)）</li>
<li>空間効率が非常に良い</li>
<li>要素の削除ができない</li>
<li><em>たまに間違える</em></li></ul>

ブルームフィルタは、本当は要素に入っていないけれども入っているとみなされるという疑陽性（false positive）がある。

<h3>C10K問題</h3>

OS の select コールを使わないで、<em>epoll</em> や <em>kqueue</em> などの別のAPIを利用する。または、ノンブロッキングI/O を使う。Ruby のイベントループフレームワークには、EventMachine がある。

<h3>アプリサーバ</h3>

Unicone は一般的な Master プロセスからワーカープロセスにリクエストを転送するプッシュモデルではなく、<em>プルモデル</em>を採用しているため。プルモデルとは、ワーカー側が処理が Master に処理を受け取りに行く方式。

<h3>key-value ストア</h3>

ACID （Atomicity:原子性、Consistency:一貫性、Isolation:独立性、Durability:持続性）特性はデータベースの世界では一般的だが、近年大規模データを扱うために分散を考えるようになってくると ACID を満たすのが厳しくなってきている。

CAP 定理というものがあり、大規模環境では、Consistency:一貫性、Availability:可用性、Partition Tolerance:分割体制 のうち同時に2つまでしか満たすことができないとされている。

大規模分散環境では、多くは Consistency を捨てている。多くの key-value ストアはトランザクション処理を持たないのはそういうこと。

<h3>アムダールの法則</h3>

一般的にマルチコアコンピュータは、CPU を複数積んでいても、その他のデバイスは共有している事が多い。たとえば、メモリやディスク、ネットワークデバイスなど。もし、CPU 以外のところに処理のボトルネックがある場合は、マルチコアを投入しても性能は改善されない。

<h3>ノンブロッキングI/O</h3>

大量の接続をさばくサーバでは、スレッドを使うとメモリ負荷やスレッド切り替えのコストが大きくなりすぎる傾向がある。そのためイベントを待ち受けてそれに対応する処理を「シングルスレッド」で処理するやり方のほうが効率的になる。

シングルスレッドで処理をするときに気を付けないといけないのは、そのスレッドが「<em>ブロック</em>」されると、プログラム全体が止まってしまうことである。

ブロックは、<em>入出力待ち</em>の場合がほとんどなため、入出力待ちを以下にブロックしないかが重要になる。




